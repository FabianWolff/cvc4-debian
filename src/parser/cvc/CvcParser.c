/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ../../../../../../src/parser/cvc/Cvc.g
 *     -                            On : 2017-03-16 01:03:03
 *     -                for the parser : CvcParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 ** This file is part of CVC4.
 ** Copyright (c) 2009-2014  New York University and The University of Iowa
 ** See the file COPYING in the top-level source directory for licensing
 ** information.
 **/

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "CvcParser.h"


#include <sstream>
#include <string>
#include <vector>

#include "base/output.h"
#include "base/ptr_closer.h"
#include "expr/expr.h"
#include "expr/kind.h"
#include "expr/type.h"
#include "parser/antlr_input.h"
#include "parser/parser.h"


#define REPEAT_COMMAND(k, CommandCtor)                      \
  ({                                                        \
    unsigned __k = (k);                                     \
    (__k <= 1)                                              \
      ? (Command*) new CommandCtor                          \
      : ({                                                  \
          CommandSequence* __seq = new CommandSequence();   \
          while(__k-- > 0) {                                \
            __seq->addCommand(new CommandCtor);             \
          }                                                 \
          (Command*) __seq;                                 \
        });                                                 \
  })

using namespace CVC4;
using namespace CVC4::parser;

/* These need to be macros so they can refer to the PARSER macro, which will be defined
 * by ANTLR *after* this section. (If they were functions, PARSER would be undefined.) */
#undef PARSER_STATE
#define PARSER_STATE ((Parser*)PARSER->super)
#undef EXPR_MANAGER
#define EXPR_MANAGER PARSER_STATE->getExprManager()
#undef MK_EXPR
#define MK_EXPR EXPR_MANAGER->mkExpr
#undef MK_CONST
#define MK_CONST EXPR_MANAGER->mkConst
#define UNSUPPORTED PARSER_STATE->unimplementedFeature

#define ENSURE_BV_SIZE(k, f)                                   \
{                                                              \
  unsigned size = BitVectorType(f.getType()).getSize();        \
  if(k > size) {                                               \
    f = MK_EXPR(MK_CONST(BitVectorZeroExtend(k - size)), f);   \
  } else if (k < size) {                                       \
    f = MK_EXPR(MK_CONST(BitVectorExtract(k - 1, 0)), f);      \
  }                                                            \
}


/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCvcParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCvcParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCvcParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pCvcParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   CvcParserTokenNames[188+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ABS_TOK",
        (pANTLR3_UINT8) "ALPHA",
        (pANTLR3_UINT8) "AND_TOK",
        (pANTLR3_UINT8) "ARITH_VAR_ORDER_TOK",
        (pANTLR3_UINT8) "ARRAY_TOK",
        (pANTLR3_UINT8) "ARROW_TOK",
        (pANTLR3_UINT8) "ASSERTIONS_TOK",
        (pANTLR3_UINT8) "ASSERT_TOK",
        (pANTLR3_UINT8) "ASSIGN_TOK",
        (pANTLR3_UINT8) "ASSUMPTIONS_TOK",
        (pANTLR3_UINT8) "BAR",
        (pANTLR3_UINT8) "BINARY_LITERAL",
        (pANTLR3_UINT8) "BITVECTOR_TOK",
        (pANTLR3_UINT8) "BOOLEAN_TOK",
        (pANTLR3_UINT8) "BVAND_TOK",
        (pANTLR3_UINT8) "BVASHR_TOK",
        (pANTLR3_UINT8) "BVCOMP_TOK",
        (pANTLR3_UINT8) "BVGE_TOK",
        (pANTLR3_UINT8) "BVGT_TOK",
        (pANTLR3_UINT8) "BVLE_TOK",
        (pANTLR3_UINT8) "BVLSHR_TOK",
        (pANTLR3_UINT8) "BVLT_TOK",
        (pANTLR3_UINT8) "BVMULT_TOK",
        (pANTLR3_UINT8) "BVNAND_TOK",
        (pANTLR3_UINT8) "BVNEG_TOK",
        (pANTLR3_UINT8) "BVNOR_TOK",
        (pANTLR3_UINT8) "BVPLUS_TOK",
        (pANTLR3_UINT8) "BVREPEAT_TOK",
        (pANTLR3_UINT8) "BVROTL_TOK",
        (pANTLR3_UINT8) "BVROTR_TOK",
        (pANTLR3_UINT8) "BVSDIV_TOK",
        (pANTLR3_UINT8) "BVSGE_TOK",
        (pANTLR3_UINT8) "BVSGT_TOK",
        (pANTLR3_UINT8) "BVSHL_TOK",
        (pANTLR3_UINT8) "BVSLE_TOK",
        (pANTLR3_UINT8) "BVSLT_TOK",
        (pANTLR3_UINT8) "BVSMOD_TOK",
        (pANTLR3_UINT8) "BVSREM_TOK",
        (pANTLR3_UINT8) "BVSUB_TOK",
        (pANTLR3_UINT8) "BVUDIV_TOK",
        (pANTLR3_UINT8) "BVUMINUS_TOK",
        (pANTLR3_UINT8) "BVUREM_TOK",
        (pANTLR3_UINT8) "BVXNOR_TOK",
        (pANTLR3_UINT8) "BVXOR_TOK",
        (pANTLR3_UINT8) "BVZEROEXTEND_TOK",
        (pANTLR3_UINT8) "CALL_TOK",
        (pANTLR3_UINT8) "CHECKSAT_TOK",
        (pANTLR3_UINT8) "CHECK_TYPE_TOK",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONCAT_TOK",
        (pANTLR3_UINT8) "CONTEXT_TOK",
        (pANTLR3_UINT8) "CONTINUE_TOK",
        (pANTLR3_UINT8) "COUNTEREXAMPLE_TOK",
        (pANTLR3_UINT8) "COUNTERMODEL_TOK",
        (pANTLR3_UINT8) "DATATYPE_TOK",
        (pANTLR3_UINT8) "DBG_TOK",
        (pANTLR3_UINT8) "DECIMAL_LITERAL",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DISEQUAL_TOK",
        (pANTLR3_UINT8) "DISTINCT_TOK",
        (pANTLR3_UINT8) "DIVISIBLE_TOK",
        (pANTLR3_UINT8) "DIV_TOK",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "DOTDOT",
        (pANTLR3_UINT8) "DUMP_ASSUMPTIONS_TOK",
        (pANTLR3_UINT8) "DUMP_CLOSURE_PROOF_TOK",
        (pANTLR3_UINT8) "DUMP_CLOSURE_TOK",
        (pANTLR3_UINT8) "DUMP_PROOF_TOK",
        (pANTLR3_UINT8) "DUMP_SIG_TOK",
        (pANTLR3_UINT8) "DUMP_TCC_ASSUMPTIONS_TOK",
        (pANTLR3_UINT8) "DUMP_TCC_PROOF_TOK",
        (pANTLR3_UINT8) "DUMP_TCC_TOK",
        (pANTLR3_UINT8) "DUMP_UNSAT_CORE_TOK",
        (pANTLR3_UINT8) "ECHO_TOK",
        (pANTLR3_UINT8) "ELSEIF_TOK",
        (pANTLR3_UINT8) "ELSE_TOK",
        (pANTLR3_UINT8) "ENDIF_TOK",
        (pANTLR3_UINT8) "END_TOK",
        (pANTLR3_UINT8) "EQUAL_TOK",
        (pANTLR3_UINT8) "ESCAPE",
        (pANTLR3_UINT8) "EXISTS_TOK",
        (pANTLR3_UINT8) "EXIT_TOK",
        (pANTLR3_UINT8) "EXP_TOK",
        (pANTLR3_UINT8) "FALSE_TOK",
        (pANTLR3_UINT8) "FLOOR_TOK",
        (pANTLR3_UINT8) "FMF_CARD_TOK",
        (pANTLR3_UINT8) "FORALL_TOK",
        (pANTLR3_UINT8) "FORGET_TOK",
        (pANTLR3_UINT8) "GEQ_TOK",
        (pANTLR3_UINT8) "GET_CHILD_TOK",
        (pANTLR3_UINT8) "GET_OP_TOK",
        (pANTLR3_UINT8) "GET_TYPE_TOK",
        (pANTLR3_UINT8) "GET_VALUE_TOK",
        (pANTLR3_UINT8) "GT_TOK",
        (pANTLR3_UINT8) "HASHPAREN",
        (pANTLR3_UINT8) "HASHSQ",
        (pANTLR3_UINT8) "HELP_TOK",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "HEX_LITERAL",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IFF_TOK",
        (pANTLR3_UINT8) "IF_TOK",
        (pANTLR3_UINT8) "IMPLIES_TOK",
        (pANTLR3_UINT8) "INCLUDE_TOK",
        (pANTLR3_UINT8) "INTDIV_TOK",
        (pANTLR3_UINT8) "INTEGER_LITERAL",
        (pANTLR3_UINT8) "INT_TOK",
        (pANTLR3_UINT8) "IN_TOK",
        (pANTLR3_UINT8) "IS_INTEGER_TOK",
        (pANTLR3_UINT8) "JOIN_TOK",
        (pANTLR3_UINT8) "LAMBDA",
        (pANTLR3_UINT8) "LBRACE",
        (pANTLR3_UINT8) "LBRACKET",
        (pANTLR3_UINT8) "LEFTSHIFT_TOK",
        (pANTLR3_UINT8) "LEQ_TOK",
        (pANTLR3_UINT8) "LET_TOK",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "LT_TOK",
        (pANTLR3_UINT8) "MEMBER_TOK",
        (pANTLR3_UINT8) "MINUS_TOK",
        (pANTLR3_UINT8) "MOD_TOK",
        (pANTLR3_UINT8) "NOT_TOK",
        (pANTLR3_UINT8) "NUMBER_OR_RANGEOP",
        (pANTLR3_UINT8) "OF_TOK",
        (pANTLR3_UINT8) "OPTION_TOK",
        (pANTLR3_UINT8) "OR_TOK",
        (pANTLR3_UINT8) "PARENHASH",
        (pANTLR3_UINT8) "PATTERN_TOK",
        (pANTLR3_UINT8) "PLUS_TOK",
        (pANTLR3_UINT8) "POPTO_SCOPE_TOK",
        (pANTLR3_UINT8) "POPTO_TOK",
        (pANTLR3_UINT8) "POP_SCOPE_TOK",
        (pANTLR3_UINT8) "POP_TOK",
        (pANTLR3_UINT8) "PRINT_TOK",
        (pANTLR3_UINT8) "PRINT_TYPE_TOK",
        (pANTLR3_UINT8) "PRODUCT_TOK",
        (pANTLR3_UINT8) "PUSH_SCOPE_TOK",
        (pANTLR3_UINT8) "PUSH_TOK",
        (pANTLR3_UINT8) "QUERY_TOK",
        (pANTLR3_UINT8) "RBRACE",
        (pANTLR3_UINT8) "RBRACKET",
        (pANTLR3_UINT8) "REAL_TOK",
        (pANTLR3_UINT8) "RESET_TOK",
        (pANTLR3_UINT8) "RESTART_TOK",
        (pANTLR3_UINT8) "RIGHTSHIFT_TOK",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "SETS_CARD_TOK",
        (pANTLR3_UINT8) "SET_TOK",
        (pANTLR3_UINT8) "SQHASH",
        (pANTLR3_UINT8) "STAR_TOK",
        (pANTLR3_UINT8) "STRING_CHARAT_TOK",
        (pANTLR3_UINT8) "STRING_CONCAT_TOK",
        (pANTLR3_UINT8) "STRING_CONTAINS_TOK",
        (pANTLR3_UINT8) "STRING_INDEXOF_TOK",
        (pANTLR3_UINT8) "STRING_ITOS_TOK",
        (pANTLR3_UINT8) "STRING_LENGTH_TOK",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "STRING_PREFIXOF_TOK",
        (pANTLR3_UINT8) "STRING_REPLACE_TOK",
        (pANTLR3_UINT8) "STRING_STOI_TOK",
        (pANTLR3_UINT8) "STRING_STOU16_TOK",
        (pANTLR3_UINT8) "STRING_STOU32_TOK",
        (pANTLR3_UINT8) "STRING_SUBSTR_TOK",
        (pANTLR3_UINT8) "STRING_SUFFIXOF_TOK",
        (pANTLR3_UINT8) "STRING_TOK",
        (pANTLR3_UINT8) "STRING_U16TOS_TOK",
        (pANTLR3_UINT8) "STRING_U32TOS_TOK",
        (pANTLR3_UINT8) "SUBSTITUTE_TOK",
        (pANTLR3_UINT8) "SUBTYPE_TOK",
        (pANTLR3_UINT8) "SX_TOK",
        (pANTLR3_UINT8) "THEN_TOK",
        (pANTLR3_UINT8) "TRACE_TOK",
        (pANTLR3_UINT8) "TRANSCLOSURE_TOK",
        (pANTLR3_UINT8) "TRANSFORM_TOK",
        (pANTLR3_UINT8) "TRANSPOSE_TOK",
        (pANTLR3_UINT8) "TRUE_TOK",
        (pANTLR3_UINT8) "TUPLE_TOK",
        (pANTLR3_UINT8) "TYPE_TOK",
        (pANTLR3_UINT8) "UNDERSCORE",
        (pANTLR3_UINT8) "UNIVSET_TOK",
        (pANTLR3_UINT8) "UNTRACE_TOK",
        (pANTLR3_UINT8) "WHERE_TOK",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "WITH_TOK",
        (pANTLR3_UINT8) "XOR_TOK"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 CVC4::Expr
	parseExpr    (pCvcParser ctx);
static 
 CVC4::Command*
	parseCommand    (pCvcParser ctx);
static 
 void
	command    (pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	typeOrVarLetDecl    (pCvcParser ctx, CVC4::parser::DeclarationCheck check);
static 
 void
	mainCommand    (pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	simpleSymbolicExpr    (pCvcParser ctx, CVC4::SExpr& sexpr);
static 
 void
	symbolicExpr    (pCvcParser ctx, CVC4::SExpr& sexpr);
static 
 void
	toplevelDeclaration    (pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	boundVarDecl    (pCvcParser ctx, std::vector<std::string>& ids, CVC4::Type& t);
static 
 void
	boundVarDecls    (pCvcParser ctx);
static 
 void
	boundVarDeclsReturn    (pCvcParser ctx, std::vector<CVC4::Expr>& terms, std::vector<CVC4::Type>& types);
static 
 void
	boundVarDeclReturn    (pCvcParser ctx, std::vector<CVC4::Expr>& terms, std::vector<CVC4::Type>& types);
static 
 void
	declareTypes    (pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd, const std::vector<std::string>& idList);
static 
 void
	declareVariables    (pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd, CVC4::Type& t, const std::vector<std::string>& idList, bool topLevel);
static 
 void
	identifierList    (pCvcParser ctx, std::vector<std::string>& idList, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type);
static 
 void
	identifier    (pCvcParser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type);
static 
 void
	type    (pCvcParser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check);
static 
 void
	restrictedType    (pCvcParser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check);
static 
 void
	restrictedTypePossiblyFunctionLHS    (pCvcParser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check, bool& lhs);
static 
 void
	parameterization    (pCvcParser ctx, CVC4::parser::DeclarationCheck check, std::vector<CVC4::Type>& params);
static 
 CVC4::parser::cvc::mySubrangeBound
	bound    (pCvcParser ctx);
static 
 void
	typeLetDecl    (pCvcParser ctx, CVC4::parser::DeclarationCheck check);
static 
 void
	formula    (pCvcParser ctx, CVC4::Expr& f);
static 
 size_t
	morecomparisons    (pCvcParser ctx, std::vector<CVC4::Expr>& expressions, std::vector<unsigned>& operators);
static 
 size_t
	nots    (pCvcParser ctx);
static 
 void
	prefixFormula    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	instantiationPatterns    (pCvcParser ctx, CVC4::Expr& expr);
static 
 void
	letDecl    (pCvcParser ctx);
static 
 void
	booleanBinop    (pCvcParser ctx, unsigned& op);
static 
 void
	comparison    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	comparisonBinop    (pCvcParser ctx, unsigned& op);
static 
 void
	arithmeticBinop    (pCvcParser ctx, unsigned& op);
static 
 void
	term    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	arrayStore    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	tupleStore    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	recordStore    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	uminusTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	bvBinaryOpTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	bvBinop    (pCvcParser ctx, unsigned& op);
static 
 void
	bvNegTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	postfixTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	bvTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	stringTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	setsTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	simpleTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	typeAscription    (pCvcParser ctx, const CVC4::Expr& f, CVC4::Type& t);
static 
 void
	recordEntry    (pCvcParser ctx, std::string& name, CVC4::Expr& ex);
static 
 void
	iteTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	iteElseTerm    (pCvcParser ctx, CVC4::Expr& f);
static 
 void
	datatypeDef    (pCvcParser ctx, std::vector<CVC4::Datatype>& datatypes);
static 
 void
	constructorDef    (pCvcParser ctx, CVC4::Datatype& type);
static 
 void
	selector    (pCvcParser ctx, CVC4::PtrCloser<CVC4::DatatypeConstructor>* ctor);
static 
 unsigned
	numeral    (pCvcParser ctx);
static 
 CVC4::Rational
	integer    (pCvcParser ctx);
static 
 void
	str    (pCvcParser ctx, std::string& s);
static 
 ANTLR3_BOOLEAN
	synpred1_Cvc    (pCvcParser ctx);
static void	CvcParserFree(pCvcParser ctx);
static void     CvcParserReset (pCvcParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "../../../../../../src/parser/cvc/Cvc.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new CvcParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCvcParser
CvcParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return CvcParserNewSSD(instream, NULL);
}

/** \brief Create a new CvcParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCvcParser
CvcParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pCvcParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pCvcParser) ANTLR3_CALLOC(1, sizeof(CvcParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in CvcParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our CvcParser interface
     */
    ctx->parseExpr	= parseExpr;
    ctx->parseCommand	= parseCommand;
    ctx->command	= command;
    ctx->typeOrVarLetDecl	= typeOrVarLetDecl;
    ctx->mainCommand	= mainCommand;
    ctx->simpleSymbolicExpr	= simpleSymbolicExpr;
    ctx->symbolicExpr	= symbolicExpr;
    ctx->toplevelDeclaration	= toplevelDeclaration;
    ctx->boundVarDecl	= boundVarDecl;
    ctx->boundVarDecls	= boundVarDecls;
    ctx->boundVarDeclsReturn	= boundVarDeclsReturn;
    ctx->boundVarDeclReturn	= boundVarDeclReturn;
    ctx->declareTypes	= declareTypes;
    ctx->declareVariables	= declareVariables;
    ctx->identifierList	= identifierList;
    ctx->identifier	= identifier;
    ctx->type	= type;
    ctx->restrictedType	= restrictedType;
    ctx->restrictedTypePossiblyFunctionLHS	= restrictedTypePossiblyFunctionLHS;
    ctx->parameterization	= parameterization;
    ctx->bound	= bound;
    ctx->typeLetDecl	= typeLetDecl;
    ctx->formula	= formula;
    ctx->morecomparisons	= morecomparisons;
    ctx->nots	= nots;
    ctx->prefixFormula	= prefixFormula;
    ctx->instantiationPatterns	= instantiationPatterns;
    ctx->letDecl	= letDecl;
    ctx->booleanBinop	= booleanBinop;
    ctx->comparison	= comparison;
    ctx->comparisonBinop	= comparisonBinop;
    ctx->arithmeticBinop	= arithmeticBinop;
    ctx->term	= term;
    ctx->arrayStore	= arrayStore;
    ctx->tupleStore	= tupleStore;
    ctx->recordStore	= recordStore;
    ctx->uminusTerm	= uminusTerm;
    ctx->bvBinaryOpTerm	= bvBinaryOpTerm;
    ctx->bvBinop	= bvBinop;
    ctx->bvNegTerm	= bvNegTerm;
    ctx->postfixTerm	= postfixTerm;
    ctx->bvTerm	= bvTerm;
    ctx->stringTerm	= stringTerm;
    ctx->setsTerm	= setsTerm;
    ctx->simpleTerm	= simpleTerm;
    ctx->typeAscription	= typeAscription;
    ctx->recordEntry	= recordEntry;
    ctx->iteTerm	= iteTerm;
    ctx->iteElseTerm	= iteElseTerm;
    ctx->datatypeDef	= datatypeDef;
    ctx->constructorDef	= constructorDef;
    ctx->selector	= selector;
    ctx->numeral	= numeral;
    ctx->integer	= integer;
    ctx->str	= str;
    ctx->synpred1_Cvc	= synpred1_Cvc;
    ctx->free			= CvcParserFree;
    ctx->reset			= CvcParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = CvcParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
CvcParserReset (pCvcParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 CvcParserFree(pCvcParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return CvcParserTokenNames;
}



    // Idea and code guidance from Sam Harwell,
    // http://www.antlr.org/wiki/display/ANTLR3/Operator+precedence+parser

    bool isRightToLeft(int type) {
      // return true here for any operators that are right-to-left associative
      switch(type) {
      case IMPLIES_TOK: return true;
      default: return false;
      }
    }/* isRightToLeft() */

    int getOperatorPrecedence(int type) {
      switch(type) {
      case BITVECTOR_TOK: return 1;
      //case DOT:
      case LPAREN:
      case LBRACE: return 2;
      case LBRACKET: return 3;
      case ARROW_TOK: return 4;
      case IS_INTEGER_TOK: return 5;
      case BVSLT_TOK:
      case BVSLE_TOK:
      case BVSGT_TOK:
      case BVSGE_TOK: return 6;
      case BVLT_TOK:
      case BVLE_TOK:
      case BVGT_TOK:
      case BVGE_TOK: return 7;
      case LEFTSHIFT_TOK:
      case RIGHTSHIFT_TOK: return 8;
      case SX_TOK:
      case BVZEROEXTEND_TOK:
      case BVREPEAT_TOK:
      case BVROTL_TOK:
      case BVROTR_TOK: return 9;
      case BVUDIV_TOK:
      case BVSDIV_TOK:
      case BVUREM_TOK:
      case BVSREM_TOK:
      case BVSMOD_TOK:
      case BVSHL_TOK:
      case BVASHR_TOK:
      case BVLSHR_TOK: return 10;
      case BVUMINUS_TOK:
      case BVPLUS_TOK:
      case BVSUB_TOK: return 11;
      case BVNEG_TOK: return 12;
      case BVXNOR_TOK: return 13;
      case BVNOR_TOK:
      case BVCOMP_TOK: return 14;
      case BVNAND_TOK: return 15;
      case BVXOR_TOK: return 16;
      case BVAND_TOK: return 17;
      case BAR: return 18;
      case CONCAT_TOK: return 19;
    //case UMINUS_TOK: return 20;
      case WITH_TOK: return 21;
      case EXP_TOK: return 22;
      case STAR_TOK:
      case INTDIV_TOK:
      case DIV_TOK:
      case TUPLE_TOK:
      case MOD_TOK: return 23;
      case PLUS_TOK:
      case MINUS_TOK:
      case JOIN_TOK:
      case TRANSPOSE_TOK:
      case PRODUCT_TOK:
      case TRANSCLOSURE_TOK: return 24;
      case LEQ_TOK:
      case LT_TOK:
      case GEQ_TOK:
      case GT_TOK:
      case MEMBER_TOK: 
      case SETS_CARD_TOK:
      case FMF_CARD_TOK: return 25;
      case EQUAL_TOK:
      case DISEQUAL_TOK: return 26;
      case NOT_TOK: return 27;
      case AND_TOK: return 28;
      case OR_TOK:
      case XOR_TOK: return 29;
      case IMPLIES_TOK: return 30;// right-to-left
      case IFF_TOK: return 31;
      case FORALL_TOK:
      case EXISTS_TOK: return 32;
      case ASSIGN_TOK:
      case IN_TOK: return 33;

      default:
        std::stringstream ss;
        ss << "internal error: no entry in precedence table for operator " << CvcParserTokenNames[type];
        throw ParserException(ss.str());
      }
    }/* getOperatorPrecedence() */

    Kind getOperatorKind(int type, bool& negate) {
      negate = false;

      switch(type) {
        // booleanBinop
      case IFF_TOK: return kind::EQUAL;
      case IMPLIES_TOK: return kind::IMPLIES;
      case OR_TOK: return kind::OR;
      case XOR_TOK: return kind::XOR;
      case AND_TOK: return kind::AND;
      
      case PRODUCT_TOK: return kind::PRODUCT;
      case JOIN_TOK: return kind::JOIN;

        // comparisonBinop
      case EQUAL_TOK: return kind::EQUAL;
      case DISEQUAL_TOK: negate = true; return kind::EQUAL;
      case GT_TOK: return kind::GT;
      case GEQ_TOK: return kind::GEQ;
      case LT_TOK: return kind::LT;
      case LEQ_TOK: return kind::LEQ;
      case MEMBER_TOK: return kind::MEMBER;
      case SETS_CARD_TOK: return kind::CARD;
      case FMF_CARD_TOK: return kind::CARDINALITY_CONSTRAINT;

        // arithmeticBinop
      case PLUS_TOK: return kind::PLUS;
      case MINUS_TOK: return kind::MINUS;
      case STAR_TOK: return kind::MULT;
      case INTDIV_TOK: return kind::INTS_DIVISION;
      case MOD_TOK: return kind::INTS_MODULUS;
      case DIV_TOK: return kind::DIVISION;
      case EXP_TOK: return kind::POW;

        // bvBinop
      case CONCAT_TOK: return kind::BITVECTOR_CONCAT;
      case BAR: return kind::BITVECTOR_OR;
      case BVAND_TOK: return kind::BITVECTOR_AND;
      
      }

      std::stringstream ss;
      ss << "internal error: no entry in operator-kind table for operator " << CvcParserTokenNames[type];
      throw ParserException(ss.str());

    }/* getOperatorKind() */

    unsigned findPivot(const std::vector<unsigned>& operators,
                       unsigned startIndex, unsigned stopIndex) {
      unsigned pivot = startIndex;
      unsigned pivotRank = getOperatorPrecedence(operators[pivot]);
      /*Debug("prec") << "initial pivot at " << pivot
                    << "(" << CvcParserTokenNames[operators[pivot]] << ") "
                    << "level " << pivotRank << std::endl;*/
      for(unsigned i = startIndex + 1; i <= stopIndex; ++i) {
        unsigned current = getOperatorPrecedence(operators[i]);
        bool rtl = isRightToLeft(operators[i]);
        if(current > pivotRank || (current == pivotRank && !rtl)) {
          /*Debug("prec") << "new pivot at " << i
                        << "(" << CvcParserTokenNames[operators[i]] << ") "
                        << "level " << current << " rtl == " << rtl << std::endl;*/
          pivot = i;
          pivotRank = current;
        }
      }
      return pivot;
    }/* findPivot() */

    Expr createPrecedenceTree(Parser* parser, ExprManager* em,
                              const std::vector<CVC4::Expr>& expressions,
                              const std::vector<unsigned>& operators,
                              unsigned startIndex, unsigned stopIndex) {
      assert(expressions.size() == operators.size() + 1);
      assert(startIndex < expressions.size());
      assert(stopIndex < expressions.size());
      assert(startIndex <= stopIndex);

      if(stopIndex == startIndex) {
        return expressions[startIndex];
      }

      unsigned pivot = findPivot(operators, startIndex, stopIndex - 1);
      //Debug("prec") << "pivot[" << startIndex << "," << stopIndex - 1 << "] at " << pivot << std::endl;
      bool negate;
      Kind k = getOperatorKind(operators[pivot], negate);
      Expr lhs = createPrecedenceTree(parser, em, expressions, operators, startIndex, pivot);
      Expr rhs = createPrecedenceTree(parser, em, expressions, operators, pivot + 1, stopIndex);

      switch(k) {
      case kind::LEQ          : if(lhs.getType().isSet()) { k = kind::SUBSET; } break;
      case kind::MINUS        : if(lhs.getType().isSet()) { k = kind::SETMINUS; } break;
      case kind::BITVECTOR_AND: if(lhs.getType().isSet()) { k = kind::INTERSECTION; } break;
      case kind::BITVECTOR_OR : if(lhs.getType().isSet()) { k = kind::UNION; } break;
      default: break;
      }
      Expr e = em->mkExpr(k, lhs, rhs);
      return negate ? em->mkExpr(e.getType().isSet() ? kind::COMPLEMENT : kind::NOT, e) : e;
    }/* createPrecedenceTree() recursive variant */

    Expr createPrecedenceTree(Parser* parser, ExprManager* em,
                              const std::vector<CVC4::Expr>& expressions,
                              const std::vector<unsigned>& operators) {
      if(Debug.isOn("prec") && operators.size() > 1) {
        for(unsigned i = 0; i < expressions.size(); ++i) {
          Debug("prec") << expressions[i];
          if(operators.size() > i) {
            Debug("prec") << ' ' << CvcParserTokenNames[operators[i]] << ' ';
          }
        }
        Debug("prec") << std::endl;
      }

      Expr e = createPrecedenceTree(parser, em, expressions, operators, 0, expressions.size() - 1);
      if(Debug.isOn("prec") && operators.size() > 1) {
        language::SetLanguage::Scope ls(Debug("prec"), language::output::LANG_AST);
        Debug("prec") << "=> " << e << std::endl;
      }
      return e;
    }/* createPrecedenceTree() base variant */

    /** Add n NOTs to the front of e and return the result. */
    Expr addNots(ExprManager* em, size_t n, Expr e) {
      Kind k = e.getType().isSet() ? kind::COMPLEMENT : kind::NOT;
      while(n-- > 0) {
        e = em->mkExpr(k, e);
      }
      return e;
    }/* addNots() */



/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_parseExpr1800  */
static	ANTLR3_BITWORD FOLLOW_formula_in_parseExpr1800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_parseExpr1800	= { FOLLOW_formula_in_parseExpr1800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseExpr1807  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseExpr1807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseExpr1807	= { FOLLOW_EOF_in_parseExpr1807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_parseCommand1838  */
static	ANTLR3_BITWORD FOLLOW_command_in_parseCommand1838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_parseCommand1838	= { FOLLOW_command_in_parseCommand1838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_parseCommand1845  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_parseCommand1845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_parseCommand1845	= { FOLLOW_LPAREN_in_parseCommand1845_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_parseCommand1847  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_parseCommand1847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_parseCommand1847	= { FOLLOW_IDENTIFIER_in_parseCommand1847_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseCommand1859  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseCommand1859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseCommand1859	= { FOLLOW_EOF_in_parseCommand1859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mainCommand_in_command1878  */
static	ANTLR3_BITWORD FOLLOW_mainCommand_in_command1878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_mainCommand_in_command1878	= { FOLLOW_mainCommand_in_command1878_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_command1881  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_command1881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_command1881	= { FOLLOW_SEMICOLON_in_command1881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_command1889  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_command1889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_command1889	= { FOLLOW_SEMICOLON_in_command1889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_command1897  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_command1897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_command1897	= { FOLLOW_LET_TOK_in_command1897_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeOrVarLetDecl_in_command1907  */
static	ANTLR3_BITWORD FOLLOW_typeOrVarLetDecl_in_command1907_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeOrVarLetDecl_in_command1907	= { FOLLOW_typeOrVarLetDecl_in_command1907_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_command1922  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_command1922_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_command1922	= { FOLLOW_COMMA_in_command1922_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeOrVarLetDecl_in_command1924  */
static	ANTLR3_BITWORD FOLLOW_typeOrVarLetDecl_in_command1924_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeOrVarLetDecl_in_command1924	= { FOLLOW_typeOrVarLetDecl_in_command1924_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IN_TOK_in_command1936  */
static	ANTLR3_BITWORD FOLLOW_IN_TOK_in_command1936_bits[]	= { ANTLR3_UINT64_LIT(0x3F0E000000002C80), ANTLR3_UINT64_LIT(0x02002247A080FFC0), ANTLR3_UINT64_LIT(0x181440000131DF84) };
static  ANTLR3_BITSET_LIST FOLLOW_IN_TOK_in_command1936	= { FOLLOW_IN_TOK_in_command1936_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_command1938  */
static	ANTLR3_BITWORD FOLLOW_command_in_command1938_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_command1938	= { FOLLOW_command_in_command1938_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_command1965  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_command1965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_command1965	= { FOLLOW_IDENTIFIER_in_command1965_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_command1967  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_command1967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_command1967	= { FOLLOW_SEMICOLON_in_command1967_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_letDecl_in_typeOrVarLetDecl1998  */
static	ANTLR3_BITWORD FOLLOW_letDecl_in_typeOrVarLetDecl1998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_letDecl_in_typeOrVarLetDecl1998	= { FOLLOW_letDecl_in_typeOrVarLetDecl1998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLetDecl_in_typeOrVarLetDecl2002  */
static	ANTLR3_BITWORD FOLLOW_typeLetDecl_in_typeOrVarLetDecl2002_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLetDecl_in_typeOrVarLetDecl2002	= { FOLLOW_typeLetDecl_in_typeOrVarLetDecl2002_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSERT_TOK_in_mainCommand2028  */
static	ANTLR3_BITWORD FOLLOW_ASSERT_TOK_in_mainCommand2028_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSERT_TOK_in_mainCommand2028	= { FOLLOW_ASSERT_TOK_in_mainCommand2028_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2030  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2030	= { FOLLOW_formula_in_mainCommand2030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUERY_TOK_in_mainCommand2040  */
static	ANTLR3_BITWORD FOLLOW_QUERY_TOK_in_mainCommand2040_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_QUERY_TOK_in_mainCommand2040	= { FOLLOW_QUERY_TOK_in_mainCommand2040_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2042  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2042	= { FOLLOW_formula_in_mainCommand2042_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECKSAT_TOK_in_mainCommand2051  */
static	ANTLR3_BITWORD FOLLOW_CHECKSAT_TOK_in_mainCommand2051_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C112), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECKSAT_TOK_in_mainCommand2051	= { FOLLOW_CHECKSAT_TOK_in_mainCommand2051_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2053  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2053	= { FOLLOW_formula_in_mainCommand2053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTION_TOK_in_mainCommand2073  */
static	ANTLR3_BITWORD FOLLOW_OPTION_TOK_in_mainCommand2073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTION_TOK_in_mainCommand2073	= { FOLLOW_OPTION_TOK_in_mainCommand2073_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_mainCommand2081  */
static	ANTLR3_BITWORD FOLLOW_str_in_mainCommand2081_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000008002), ANTLR3_UINT64_LIT(0x2400830002000000), ANTLR3_UINT64_LIT(0x0040000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_mainCommand2081	= { FOLLOW_str_in_mainCommand2081_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_mainCommand2086  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_mainCommand2086_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000008002), ANTLR3_UINT64_LIT(0x2400830002000000), ANTLR3_UINT64_LIT(0x0040000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_mainCommand2086	= { FOLLOW_IDENTIFIER_in_mainCommand2086_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_mainCommand2098  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_mainCommand2098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_mainCommand2098	= { FOLLOW_symbolicExpr_in_mainCommand2098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_TOK_in_mainCommand2115  */
static	ANTLR3_BITWORD FOLLOW_TRUE_TOK_in_mainCommand2115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_TOK_in_mainCommand2115	= { FOLLOW_TRUE_TOK_in_mainCommand2115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_TOK_in_mainCommand2125  */
static	ANTLR3_BITWORD FOLLOW_FALSE_TOK_in_mainCommand2125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_TOK_in_mainCommand2125	= { FOLLOW_FALSE_TOK_in_mainCommand2125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PUSH_TOK_in_mainCommand2154  */
static	ANTLR3_BITWORD FOLLOW_PUSH_TOK_in_mainCommand2154_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PUSH_TOK_in_mainCommand2154	= { FOLLOW_PUSH_TOK_in_mainCommand2154_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_mainCommand2160  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_mainCommand2160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_mainCommand2160	= { FOLLOW_numeral_in_mainCommand2160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POP_TOK_in_mainCommand2189  */
static	ANTLR3_BITWORD FOLLOW_POP_TOK_in_mainCommand2189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_POP_TOK_in_mainCommand2189	= { FOLLOW_POP_TOK_in_mainCommand2189_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_mainCommand2195  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_mainCommand2195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_mainCommand2195	= { FOLLOW_numeral_in_mainCommand2195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POPTO_TOK_in_mainCommand2223  */
static	ANTLR3_BITWORD FOLLOW_POPTO_TOK_in_mainCommand2223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_POPTO_TOK_in_mainCommand2223	= { FOLLOW_POPTO_TOK_in_mainCommand2223_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_mainCommand2227  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_mainCommand2227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_mainCommand2227	= { FOLLOW_numeral_in_mainCommand2227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PUSH_SCOPE_TOK_in_mainCommand2247  */
static	ANTLR3_BITWORD FOLLOW_PUSH_SCOPE_TOK_in_mainCommand2247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PUSH_SCOPE_TOK_in_mainCommand2247	= { FOLLOW_PUSH_SCOPE_TOK_in_mainCommand2247_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_mainCommand2251  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_mainCommand2251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_mainCommand2251	= { FOLLOW_numeral_in_mainCommand2251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POP_SCOPE_TOK_in_mainCommand2264  */
static	ANTLR3_BITWORD FOLLOW_POP_SCOPE_TOK_in_mainCommand2264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_POP_SCOPE_TOK_in_mainCommand2264	= { FOLLOW_POP_SCOPE_TOK_in_mainCommand2264_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_mainCommand2268  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_mainCommand2268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_mainCommand2268	= { FOLLOW_numeral_in_mainCommand2268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POPTO_SCOPE_TOK_in_mainCommand2281  */
static	ANTLR3_BITWORD FOLLOW_POPTO_SCOPE_TOK_in_mainCommand2281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_POPTO_SCOPE_TOK_in_mainCommand2281	= { FOLLOW_POPTO_SCOPE_TOK_in_mainCommand2281_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_mainCommand2285  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_mainCommand2285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_mainCommand2285	= { FOLLOW_numeral_in_mainCommand2285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESET_TOK_in_mainCommand2299  */
static	ANTLR3_BITWORD FOLLOW_RESET_TOK_in_mainCommand2299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RESET_TOK_in_mainCommand2299	= { FOLLOW_RESET_TOK_in_mainCommand2299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESET_TOK_in_mainCommand2312  */
static	ANTLR3_BITWORD FOLLOW_RESET_TOK_in_mainCommand2312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_RESET_TOK_in_mainCommand2312	= { FOLLOW_RESET_TOK_in_mainCommand2312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSERTIONS_TOK_in_mainCommand2314  */
static	ANTLR3_BITWORD FOLLOW_ASSERTIONS_TOK_in_mainCommand2314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSERTIONS_TOK_in_mainCommand2314	= { FOLLOW_ASSERTIONS_TOK_in_mainCommand2314_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATATYPE_TOK_in_mainCommand2342  */
static	ANTLR3_BITWORD FOLLOW_DATATYPE_TOK_in_mainCommand2342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DATATYPE_TOK_in_mainCommand2342	= { FOLLOW_DATATYPE_TOK_in_mainCommand2342_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypeDef_in_mainCommand2354  */
static	ANTLR3_BITWORD FOLLOW_datatypeDef_in_mainCommand2354_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypeDef_in_mainCommand2354	= { FOLLOW_datatypeDef_in_mainCommand2354_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_mainCommand2363  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_mainCommand2363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_mainCommand2363	= { FOLLOW_COMMA_in_mainCommand2363_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypeDef_in_mainCommand2365  */
static	ANTLR3_BITWORD FOLLOW_datatypeDef_in_mainCommand2365_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypeDef_in_mainCommand2365	= { FOLLOW_datatypeDef_in_mainCommand2365_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_TOK_in_mainCommand2375  */
static	ANTLR3_BITWORD FOLLOW_END_TOK_in_mainCommand2375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_END_TOK_in_mainCommand2375	= { FOLLOW_END_TOK_in_mainCommand2375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTEXT_TOK_in_mainCommand2388  */
static	ANTLR3_BITWORD FOLLOW_CONTEXT_TOK_in_mainCommand2388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTEXT_TOK_in_mainCommand2388	= { FOLLOW_CONTEXT_TOK_in_mainCommand2388_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_mainCommand2398  */
static	ANTLR3_BITWORD FOLLOW_str_in_mainCommand2398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_mainCommand2398	= { FOLLOW_str_in_mainCommand2398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_mainCommand2403  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_mainCommand2403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_mainCommand2403	= { FOLLOW_IDENTIFIER_in_mainCommand2403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORGET_TOK_in_mainCommand2436  */
static	ANTLR3_BITWORD FOLLOW_FORGET_TOK_in_mainCommand2436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FORGET_TOK_in_mainCommand2436	= { FOLLOW_FORGET_TOK_in_mainCommand2436_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_mainCommand2438  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_mainCommand2438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_mainCommand2438	= { FOLLOW_identifier_in_mainCommand2438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_TYPE_TOK_in_mainCommand2452  */
static	ANTLR3_BITWORD FOLLOW_GET_TYPE_TOK_in_mainCommand2452_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_TYPE_TOK_in_mainCommand2452	= { FOLLOW_GET_TYPE_TOK_in_mainCommand2452_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2454  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2454	= { FOLLOW_formula_in_mainCommand2454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECK_TYPE_TOK_in_mainCommand2468  */
static	ANTLR3_BITWORD FOLLOW_CHECK_TYPE_TOK_in_mainCommand2468_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECK_TYPE_TOK_in_mainCommand2468	= { FOLLOW_CHECK_TYPE_TOK_in_mainCommand2468_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2470  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2470_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2470	= { FOLLOW_formula_in_mainCommand2470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_mainCommand2473  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_mainCommand2473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_mainCommand2473	= { FOLLOW_COLON_in_mainCommand2473_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_mainCommand2475  */
static	ANTLR3_BITWORD FOLLOW_type_in_mainCommand2475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_mainCommand2475	= { FOLLOW_type_in_mainCommand2475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_CHILD_TOK_in_mainCommand2489  */
static	ANTLR3_BITWORD FOLLOW_GET_CHILD_TOK_in_mainCommand2489_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_CHILD_TOK_in_mainCommand2489	= { FOLLOW_GET_CHILD_TOK_in_mainCommand2489_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2491  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2491	= { FOLLOW_formula_in_mainCommand2491_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_mainCommand2496  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_mainCommand2496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_mainCommand2496	= { FOLLOW_numeral_in_mainCommand2496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_OP_TOK_in_mainCommand2509  */
static	ANTLR3_BITWORD FOLLOW_GET_OP_TOK_in_mainCommand2509_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_OP_TOK_in_mainCommand2509	= { FOLLOW_GET_OP_TOK_in_mainCommand2509_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2511  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2511	= { FOLLOW_formula_in_mainCommand2511_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_VALUE_TOK_in_mainCommand2525  */
static	ANTLR3_BITWORD FOLLOW_GET_VALUE_TOK_in_mainCommand2525_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_VALUE_TOK_in_mainCommand2525	= { FOLLOW_GET_VALUE_TOK_in_mainCommand2525_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2527  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2527	= { FOLLOW_formula_in_mainCommand2527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SUBSTITUTE_TOK_in_mainCommand2541  */
static	ANTLR3_BITWORD FOLLOW_SUBSTITUTE_TOK_in_mainCommand2541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SUBSTITUTE_TOK_in_mainCommand2541	= { FOLLOW_SUBSTITUTE_TOK_in_mainCommand2541_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_mainCommand2543  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_mainCommand2543_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_mainCommand2543	= { FOLLOW_identifier_in_mainCommand2543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_mainCommand2546  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_mainCommand2546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_mainCommand2546	= { FOLLOW_COLON_in_mainCommand2546_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_mainCommand2552  */
static	ANTLR3_BITWORD FOLLOW_type_in_mainCommand2552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_mainCommand2552	= { FOLLOW_type_in_mainCommand2552_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_mainCommand2555  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_mainCommand2555_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_mainCommand2555	= { FOLLOW_EQUAL_TOK_in_mainCommand2555_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2557  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2557	= { FOLLOW_formula_in_mainCommand2557_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_mainCommand2560  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_mainCommand2560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_mainCommand2560	= { FOLLOW_LBRACKET_in_mainCommand2560_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_mainCommand2566  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_mainCommand2566_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_mainCommand2566	= { FOLLOW_identifier_in_mainCommand2566_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_TOK_in_mainCommand2569  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_TOK_in_mainCommand2569_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_TOK_in_mainCommand2569	= { FOLLOW_ASSIGN_TOK_in_mainCommand2569_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2571  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2571	= { FOLLOW_formula_in_mainCommand2571_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACKET_in_mainCommand2574  */
static	ANTLR3_BITWORD FOLLOW_RBRACKET_in_mainCommand2574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACKET_in_mainCommand2574	= { FOLLOW_RBRACKET_in_mainCommand2574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DBG_TOK_in_mainCommand2593  */
static	ANTLR3_BITWORD FOLLOW_DBG_TOK_in_mainCommand2593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DBG_TOK_in_mainCommand2593	= { FOLLOW_DBG_TOK_in_mainCommand2593_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_mainCommand2603  */
static	ANTLR3_BITWORD FOLLOW_str_in_mainCommand2603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_mainCommand2603	= { FOLLOW_str_in_mainCommand2603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_mainCommand2608  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_mainCommand2608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_mainCommand2608	= { FOLLOW_IDENTIFIER_in_mainCommand2608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRACE_TOK_in_mainCommand2641  */
static	ANTLR3_BITWORD FOLLOW_TRACE_TOK_in_mainCommand2641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_TRACE_TOK_in_mainCommand2641	= { FOLLOW_TRACE_TOK_in_mainCommand2641_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_mainCommand2651  */
static	ANTLR3_BITWORD FOLLOW_str_in_mainCommand2651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_mainCommand2651	= { FOLLOW_str_in_mainCommand2651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_mainCommand2656  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_mainCommand2656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_mainCommand2656	= { FOLLOW_IDENTIFIER_in_mainCommand2656_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNTRACE_TOK_in_mainCommand2688  */
static	ANTLR3_BITWORD FOLLOW_UNTRACE_TOK_in_mainCommand2688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_UNTRACE_TOK_in_mainCommand2688	= { FOLLOW_UNTRACE_TOK_in_mainCommand2688_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_mainCommand2698  */
static	ANTLR3_BITWORD FOLLOW_str_in_mainCommand2698_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_mainCommand2698	= { FOLLOW_str_in_mainCommand2698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_mainCommand2703  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_mainCommand2703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_mainCommand2703	= { FOLLOW_IDENTIFIER_in_mainCommand2703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HELP_TOK_in_mainCommand2736  */
static	ANTLR3_BITWORD FOLLOW_HELP_TOK_in_mainCommand2736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_HELP_TOK_in_mainCommand2736	= { FOLLOW_HELP_TOK_in_mainCommand2736_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_mainCommand2746  */
static	ANTLR3_BITWORD FOLLOW_str_in_mainCommand2746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_mainCommand2746	= { FOLLOW_str_in_mainCommand2746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_mainCommand2751  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_mainCommand2751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_mainCommand2751	= { FOLLOW_IDENTIFIER_in_mainCommand2751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRANSFORM_TOK_in_mainCommand2792  */
static	ANTLR3_BITWORD FOLLOW_TRANSFORM_TOK_in_mainCommand2792_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_TRANSFORM_TOK_in_mainCommand2792	= { FOLLOW_TRANSFORM_TOK_in_mainCommand2792_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2794  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2794_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2794	= { FOLLOW_formula_in_mainCommand2794_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRINT_TOK_in_mainCommand2808  */
static	ANTLR3_BITWORD FOLLOW_PRINT_TOK_in_mainCommand2808_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_PRINT_TOK_in_mainCommand2808	= { FOLLOW_PRINT_TOK_in_mainCommand2808_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2810  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2810	= { FOLLOW_formula_in_mainCommand2810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRINT_TYPE_TOK_in_mainCommand2823  */
static	ANTLR3_BITWORD FOLLOW_PRINT_TYPE_TOK_in_mainCommand2823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_PRINT_TYPE_TOK_in_mainCommand2823	= { FOLLOW_PRINT_TYPE_TOK_in_mainCommand2823_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_mainCommand2825  */
static	ANTLR3_BITWORD FOLLOW_type_in_mainCommand2825_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_mainCommand2825	= { FOLLOW_type_in_mainCommand2825_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CALL_TOK_in_mainCommand2839  */
static	ANTLR3_BITWORD FOLLOW_CALL_TOK_in_mainCommand2839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CALL_TOK_in_mainCommand2839	= { FOLLOW_CALL_TOK_in_mainCommand2839_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_mainCommand2841  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_mainCommand2841_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_mainCommand2841	= { FOLLOW_identifier_in_mainCommand2841_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand2844  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand2844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand2844	= { FOLLOW_formula_in_mainCommand2844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ECHO_TOK_in_mainCommand2858  */
static	ANTLR3_BITWORD FOLLOW_ECHO_TOK_in_mainCommand2858_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000008002), ANTLR3_UINT64_LIT(0x2000830000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ECHO_TOK_in_mainCommand2858	= { FOLLOW_ECHO_TOK_in_mainCommand2858_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExpr_in_mainCommand2866  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExpr_in_mainCommand2866_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExpr_in_mainCommand2866	= { FOLLOW_simpleSymbolicExpr_in_mainCommand2866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXIT_TOK_in_mainCommand2896  */
static	ANTLR3_BITWORD FOLLOW_EXIT_TOK_in_mainCommand2896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXIT_TOK_in_mainCommand2896	= { FOLLOW_EXIT_TOK_in_mainCommand2896_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_TOK_in_mainCommand2909  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_TOK_in_mainCommand2909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_TOK_in_mainCommand2909	= { FOLLOW_INCLUDE_TOK_in_mainCommand2909_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_mainCommand2919  */
static	ANTLR3_BITWORD FOLLOW_str_in_mainCommand2919_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_mainCommand2919	= { FOLLOW_str_in_mainCommand2919_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_mainCommand2924  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_mainCommand2924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_mainCommand2924	= { FOLLOW_IDENTIFIER_in_mainCommand2924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DUMP_PROOF_TOK_in_mainCommand2957  */
static	ANTLR3_BITWORD FOLLOW_DUMP_PROOF_TOK_in_mainCommand2957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DUMP_PROOF_TOK_in_mainCommand2957	= { FOLLOW_DUMP_PROOF_TOK_in_mainCommand2957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DUMP_UNSAT_CORE_TOK_in_mainCommand2970  */
static	ANTLR3_BITWORD FOLLOW_DUMP_UNSAT_CORE_TOK_in_mainCommand2970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DUMP_UNSAT_CORE_TOK_in_mainCommand2970	= { FOLLOW_DUMP_UNSAT_CORE_TOK_in_mainCommand2970_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_mainCommand2983  */
static	ANTLR3_BITWORD FOLLOW_set_in_mainCommand2983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_mainCommand2983	= { FOLLOW_set_in_mainCommand2983_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_mainCommand3054  */
static	ANTLR3_BITWORD FOLLOW_set_in_mainCommand3054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_mainCommand3054	= { FOLLOW_set_in_mainCommand3054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COUNTEREXAMPLE_TOK_in_mainCommand3079  */
static	ANTLR3_BITWORD FOLLOW_COUNTEREXAMPLE_TOK_in_mainCommand3079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COUNTEREXAMPLE_TOK_in_mainCommand3079	= { FOLLOW_COUNTEREXAMPLE_TOK_in_mainCommand3079_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COUNTERMODEL_TOK_in_mainCommand3091  */
static	ANTLR3_BITWORD FOLLOW_COUNTERMODEL_TOK_in_mainCommand3091_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COUNTERMODEL_TOK_in_mainCommand3091	= { FOLLOW_COUNTERMODEL_TOK_in_mainCommand3091_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARITH_VAR_ORDER_TOK_in_mainCommand3104  */
static	ANTLR3_BITWORD FOLLOW_ARITH_VAR_ORDER_TOK_in_mainCommand3104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ARITH_VAR_ORDER_TOK_in_mainCommand3104	= { FOLLOW_ARITH_VAR_ORDER_TOK_in_mainCommand3104_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_mainCommand3106  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_mainCommand3106_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_mainCommand3106	= { FOLLOW_LPAREN_in_mainCommand3106_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand3108  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand3108_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand3108	= { FOLLOW_formula_in_mainCommand3108_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_mainCommand3113  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_mainCommand3113_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_mainCommand3113	= { FOLLOW_COMMA_in_mainCommand3113_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand3115  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand3115_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand3115	= { FOLLOW_formula_in_mainCommand3115_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_mainCommand3121  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_mainCommand3121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_mainCommand3121	= { FOLLOW_RPAREN_in_mainCommand3121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTINUE_TOK_in_mainCommand3134  */
static	ANTLR3_BITWORD FOLLOW_CONTINUE_TOK_in_mainCommand3134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTINUE_TOK_in_mainCommand3134	= { FOLLOW_CONTINUE_TOK_in_mainCommand3134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESTART_TOK_in_mainCommand3146  */
static	ANTLR3_BITWORD FOLLOW_RESTART_TOK_in_mainCommand3146_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_RESTART_TOK_in_mainCommand3146	= { FOLLOW_RESTART_TOK_in_mainCommand3146_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_mainCommand3148  */
static	ANTLR3_BITWORD FOLLOW_formula_in_mainCommand3148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_mainCommand3148	= { FOLLOW_formula_in_mainCommand3148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_toplevelDeclaration_in_mainCommand3157  */
static	ANTLR3_BITWORD FOLLOW_toplevelDeclaration_in_mainCommand3157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_toplevelDeclaration_in_mainCommand3157	= { FOLLOW_toplevelDeclaration_in_mainCommand3157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3177  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3177	= { FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_TOK_in_simpleSymbolicExpr3189  */
static	ANTLR3_BITWORD FOLLOW_MINUS_TOK_in_simpleSymbolicExpr3189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_TOK_in_simpleSymbolicExpr3189	= { FOLLOW_MINUS_TOK_in_simpleSymbolicExpr3189_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3191  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3191	= { FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExpr3203  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExpr3203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExpr3203	= { FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExpr3203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_simpleSymbolicExpr3215  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_simpleSymbolicExpr3215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_simpleSymbolicExpr3215	= { FOLLOW_HEX_LITERAL_in_simpleSymbolicExpr3215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINARY_LITERAL_in_simpleSymbolicExpr3227  */
static	ANTLR3_BITWORD FOLLOW_BINARY_LITERAL_in_simpleSymbolicExpr3227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BINARY_LITERAL_in_simpleSymbolicExpr3227	= { FOLLOW_BINARY_LITERAL_in_simpleSymbolicExpr3227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_simpleSymbolicExpr3239  */
static	ANTLR3_BITWORD FOLLOW_str_in_simpleSymbolicExpr3239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_simpleSymbolicExpr3239	= { FOLLOW_str_in_simpleSymbolicExpr3239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simpleSymbolicExpr3252  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simpleSymbolicExpr3252_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simpleSymbolicExpr3252	= { FOLLOW_IDENTIFIER_in_simpleSymbolicExpr3252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExpr_in_symbolicExpr3277  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExpr_in_symbolicExpr3277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExpr_in_symbolicExpr3277	= { FOLLOW_simpleSymbolicExpr_in_symbolicExpr3277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_symbolicExpr3284  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_symbolicExpr3284_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000008000), ANTLR3_UINT64_LIT(0x2400830000000000), ANTLR3_UINT64_LIT(0x0000000800800000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_symbolicExpr3284	= { FOLLOW_LPAREN_in_symbolicExpr3284_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_symbolicExpr3287  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_symbolicExpr3287_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000008000), ANTLR3_UINT64_LIT(0x2400830000000000), ANTLR3_UINT64_LIT(0x0000000800800000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_symbolicExpr3287	= { FOLLOW_symbolicExpr_in_symbolicExpr3287_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_symbolicExpr3295  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_symbolicExpr3295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_symbolicExpr3295	= { FOLLOW_RPAREN_in_symbolicExpr3295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifierList_in_toplevelDeclaration3322  */
static	ANTLR3_BITWORD FOLLOW_identifierList_in_toplevelDeclaration3322_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifierList_in_toplevelDeclaration3322	= { FOLLOW_identifierList_in_toplevelDeclaration3322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_toplevelDeclaration3325  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_toplevelDeclaration3325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x010088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_toplevelDeclaration3325	= { FOLLOW_COLON_in_toplevelDeclaration3325_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declareVariables_in_toplevelDeclaration3333  */
static	ANTLR3_BITWORD FOLLOW_declareVariables_in_toplevelDeclaration3333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declareVariables_in_toplevelDeclaration3333	= { FOLLOW_declareVariables_in_toplevelDeclaration3333_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declareTypes_in_toplevelDeclaration3342  */
static	ANTLR3_BITWORD FOLLOW_declareTypes_in_toplevelDeclaration3342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declareTypes_in_toplevelDeclaration3342	= { FOLLOW_declareTypes_in_toplevelDeclaration3342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifierList_in_boundVarDecl3366  */
static	ANTLR3_BITWORD FOLLOW_identifierList_in_boundVarDecl3366_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifierList_in_boundVarDecl3366	= { FOLLOW_identifierList_in_boundVarDecl3366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_boundVarDecl3369  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_boundVarDecl3369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_boundVarDecl3369	= { FOLLOW_COLON_in_boundVarDecl3369_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declareVariables_in_boundVarDecl3375  */
static	ANTLR3_BITWORD FOLLOW_declareVariables_in_boundVarDecl3375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declareVariables_in_boundVarDecl3375	= { FOLLOW_declareVariables_in_boundVarDecl3375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarDecl_in_boundVarDecls3396  */
static	ANTLR3_BITWORD FOLLOW_boundVarDecl_in_boundVarDecls3396_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarDecl_in_boundVarDecls3396	= { FOLLOW_boundVarDecl_in_boundVarDecls3396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_boundVarDecls3401  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_boundVarDecls3401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_boundVarDecls3401	= { FOLLOW_COMMA_in_boundVarDecls3401_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarDecl_in_boundVarDecls3403  */
static	ANTLR3_BITWORD FOLLOW_boundVarDecl_in_boundVarDecls3403_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarDecl_in_boundVarDecls3403	= { FOLLOW_boundVarDecl_in_boundVarDecls3403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3426  */
static	ANTLR3_BITWORD FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3426_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3426	= { FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_boundVarDeclsReturn3431  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_boundVarDeclsReturn3431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_boundVarDeclsReturn3431	= { FOLLOW_COMMA_in_boundVarDeclsReturn3431_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3433  */
static	ANTLR3_BITWORD FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3433_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3433	= { FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifierList_in_boundVarDeclReturn3456  */
static	ANTLR3_BITWORD FOLLOW_identifierList_in_boundVarDeclReturn3456_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifierList_in_boundVarDeclReturn3456	= { FOLLOW_identifierList_in_boundVarDeclReturn3456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_boundVarDeclReturn3459  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_boundVarDeclReturn3459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_boundVarDeclReturn3459	= { FOLLOW_COLON_in_boundVarDeclReturn3459_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_boundVarDeclReturn3461  */
static	ANTLR3_BITWORD FOLLOW_type_in_boundVarDeclReturn3461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_boundVarDeclReturn3461	= { FOLLOW_type_in_boundVarDeclReturn3461_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_TOK_in_declareTypes3495  */
static	ANTLR3_BITWORD FOLLOW_TYPE_TOK_in_declareTypes3495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_TOK_in_declareTypes3495	= { FOLLOW_TYPE_TOK_in_declareTypes3495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_TOK_in_declareTypes3514  */
static	ANTLR3_BITWORD FOLLOW_TYPE_TOK_in_declareTypes3514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_TOK_in_declareTypes3514	= { FOLLOW_TYPE_TOK_in_declareTypes3514_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_declareTypes3516  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_declareTypes3516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_declareTypes3516	= { FOLLOW_EQUAL_TOK_in_declareTypes3516_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_declareTypes3518  */
static	ANTLR3_BITWORD FOLLOW_type_in_declareTypes3518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_declareTypes3518	= { FOLLOW_type_in_declareTypes3518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_declareVariables3552  */
static	ANTLR3_BITWORD FOLLOW_type_in_declareVariables3552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_declareVariables3552	= { FOLLOW_type_in_declareVariables3552_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_declareVariables3557  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_declareVariables3557_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_declareVariables3557	= { FOLLOW_EQUAL_TOK_in_declareVariables3557_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_declareVariables3559  */
static	ANTLR3_BITWORD FOLLOW_formula_in_declareVariables3559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_declareVariables3559	= { FOLLOW_formula_in_declareVariables3559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_identifierList3590  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_identifierList3590_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_identifierList3590	= { FOLLOW_identifier_in_identifierList3590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_identifierList3601  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_identifierList3601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_identifierList3601	= { FOLLOW_COMMA_in_identifierList3601_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_identifierList3603  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_identifierList3603_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_identifierList3603	= { FOLLOW_identifier_in_identifierList3603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_identifier3625  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_identifier3625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_identifier3625	= { FOLLOW_IDENTIFIER_in_identifier3625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedTypePossiblyFunctionLHS_in_type3658  */
static	ANTLR3_BITWORD FOLLOW_restrictedTypePossiblyFunctionLHS_in_type3658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedTypePossiblyFunctionLHS_in_type3658	= { FOLLOW_restrictedTypePossiblyFunctionLHS_in_type3658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARROW_TOK_in_type3673  */
static	ANTLR3_BITWORD FOLLOW_ARROW_TOK_in_type3673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_ARROW_TOK_in_type3673	= { FOLLOW_ARROW_TOK_in_type3673_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_type3675  */
static	ANTLR3_BITWORD FOLLOW_type_in_type3675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_type3675	= { FOLLOW_type_in_type3675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_type3700  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_type3700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_type3700	= { FOLLOW_LET_TOK_in_type3700_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLetDecl_in_type3708  */
static	ANTLR3_BITWORD FOLLOW_typeLetDecl_in_type3708_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLetDecl_in_type3708	= { FOLLOW_typeLetDecl_in_type3708_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_type3713  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_type3713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_type3713	= { FOLLOW_COMMA_in_type3713_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLetDecl_in_type3715  */
static	ANTLR3_BITWORD FOLLOW_typeLetDecl_in_type3715_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLetDecl_in_type3715	= { FOLLOW_typeLetDecl_in_type3715_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IN_TOK_in_type3721  */
static	ANTLR3_BITWORD FOLLOW_IN_TOK_in_type3721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_IN_TOK_in_type3721	= { FOLLOW_IN_TOK_in_type3721_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_type3723  */
static	ANTLR3_BITWORD FOLLOW_type_in_type3723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_type3723	= { FOLLOW_type_in_type3723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedTypePossiblyFunctionLHS_in_restrictedType3759  */
static	ANTLR3_BITWORD FOLLOW_restrictedTypePossiblyFunctionLHS_in_restrictedType3759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedTypePossiblyFunctionLHS_in_restrictedType3759	= { FOLLOW_restrictedTypePossiblyFunctionLHS_in_restrictedType3759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS3793  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS3793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS3793	= { FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS3793_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterization_in_restrictedTypePossiblyFunctionLHS3800  */
static	ANTLR3_BITWORD FOLLOW_parameterization_in_restrictedTypePossiblyFunctionLHS3800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterization_in_restrictedTypePossiblyFunctionLHS3800	= { FOLLOW_parameterization_in_restrictedTypePossiblyFunctionLHS3800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARRAY_TOK_in_restrictedTypePossiblyFunctionLHS3821  */
static	ANTLR3_BITWORD FOLLOW_ARRAY_TOK_in_restrictedTypePossiblyFunctionLHS3821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_ARRAY_TOK_in_restrictedTypePossiblyFunctionLHS3821	= { FOLLOW_ARRAY_TOK_in_restrictedTypePossiblyFunctionLHS3821_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3823  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3823	= { FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3823_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3826  */
static	ANTLR3_BITWORD FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3826	= { FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3826_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3828  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3828	= { FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_TOK_in_restrictedTypePossiblyFunctionLHS3841  */
static	ANTLR3_BITWORD FOLLOW_SET_TOK_in_restrictedTypePossiblyFunctionLHS3841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_TOK_in_restrictedTypePossiblyFunctionLHS3841	= { FOLLOW_SET_TOK_in_restrictedTypePossiblyFunctionLHS3841_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3843  */
static	ANTLR3_BITWORD FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3843_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3843	= { FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3843_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3845  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3845	= { FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SUBTYPE_TOK_in_restrictedTypePossiblyFunctionLHS3868  */
static	ANTLR3_BITWORD FOLLOW_SUBTYPE_TOK_in_restrictedTypePossiblyFunctionLHS3868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SUBTYPE_TOK_in_restrictedTypePossiblyFunctionLHS3868	= { FOLLOW_SUBTYPE_TOK_in_restrictedTypePossiblyFunctionLHS3868_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS3870  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS3870_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS3870	= { FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS3870_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3888  */
static	ANTLR3_BITWORD FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3888_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3888	= { FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3888_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3893  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3893_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3893	= { FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3893_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3895  */
static	ANTLR3_BITWORD FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3895	= { FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3895_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS3901  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS3901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS3901	= { FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS3901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3920  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x2000800000000000), ANTLR3_UINT64_LIT(0x0200000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3920	= { FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3920_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3924  */
static	ANTLR3_BITWORD FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3924	= { FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3924_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOTDOT_in_restrictedTypePossiblyFunctionLHS3926  */
static	ANTLR3_BITWORD FOLLOW_DOTDOT_in_restrictedTypePossiblyFunctionLHS3926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x2000800000000000), ANTLR3_UINT64_LIT(0x0200000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOTDOT_in_restrictedTypePossiblyFunctionLHS3926	= { FOLLOW_DOTDOT_in_restrictedTypePossiblyFunctionLHS3926_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3930  */
static	ANTLR3_BITWORD FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3930	= { FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3930_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3932  */
static	ANTLR3_BITWORD FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3932_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3932	= { FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3932_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3951  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3951_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C0C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3951	= { FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3951_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3955  */
static	ANTLR3_BITWORD FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3955_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3955	= { FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3955_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3966  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3966	= { FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3966_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3968  */
static	ANTLR3_BITWORD FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3968_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3968	= { FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3968_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3979  */
static	ANTLR3_BITWORD FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3979	= { FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SQHASH_in_restrictedTypePossiblyFunctionLHS3998  */
static	ANTLR3_BITWORD FOLLOW_SQHASH_in_restrictedTypePossiblyFunctionLHS3998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000022000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SQHASH_in_restrictedTypePossiblyFunctionLHS3998	= { FOLLOW_SQHASH_in_restrictedTypePossiblyFunctionLHS3998_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4002  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4002_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4002	= { FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4002_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4005  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4005	= { FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4005_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4007  */
static	ANTLR3_BITWORD FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4007_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4007	= { FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4007_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4018  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4018	= { FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4018_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4020  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4020_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4020	= { FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4023  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4023	= { FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4023_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4025  */
static	ANTLR3_BITWORD FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4025_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4025	= { FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4025_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HASHSQ_in_restrictedTypePossiblyFunctionLHS4036  */
static	ANTLR3_BITWORD FOLLOW_HASHSQ_in_restrictedTypePossiblyFunctionLHS4036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HASHSQ_in_restrictedTypePossiblyFunctionLHS4036	= { FOLLOW_HASHSQ_in_restrictedTypePossiblyFunctionLHS4036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BITVECTOR_TOK_in_restrictedTypePossiblyFunctionLHS4055  */
static	ANTLR3_BITWORD FOLLOW_BITVECTOR_TOK_in_restrictedTypePossiblyFunctionLHS4055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BITVECTOR_TOK_in_restrictedTypePossiblyFunctionLHS4055	= { FOLLOW_BITVECTOR_TOK_in_restrictedTypePossiblyFunctionLHS4055_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4057  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4057	= { FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4057_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_restrictedTypePossiblyFunctionLHS4061  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_restrictedTypePossiblyFunctionLHS4061_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_restrictedTypePossiblyFunctionLHS4061	= { FOLLOW_numeral_in_restrictedTypePossiblyFunctionLHS4061_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4063  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4063	= { FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4063_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_TOK_in_restrictedTypePossiblyFunctionLHS4082  */
static	ANTLR3_BITWORD FOLLOW_STRING_TOK_in_restrictedTypePossiblyFunctionLHS4082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_TOK_in_restrictedTypePossiblyFunctionLHS4082	= { FOLLOW_STRING_TOK_in_restrictedTypePossiblyFunctionLHS4082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOLEAN_TOK_in_restrictedTypePossiblyFunctionLHS4097  */
static	ANTLR3_BITWORD FOLLOW_BOOLEAN_TOK_in_restrictedTypePossiblyFunctionLHS4097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOLEAN_TOK_in_restrictedTypePossiblyFunctionLHS4097	= { FOLLOW_BOOLEAN_TOK_in_restrictedTypePossiblyFunctionLHS4097_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REAL_TOK_in_restrictedTypePossiblyFunctionLHS4105  */
static	ANTLR3_BITWORD FOLLOW_REAL_TOK_in_restrictedTypePossiblyFunctionLHS4105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REAL_TOK_in_restrictedTypePossiblyFunctionLHS4105	= { FOLLOW_REAL_TOK_in_restrictedTypePossiblyFunctionLHS4105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_TOK_in_restrictedTypePossiblyFunctionLHS4113  */
static	ANTLR3_BITWORD FOLLOW_INT_TOK_in_restrictedTypePossiblyFunctionLHS4113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_TOK_in_restrictedTypePossiblyFunctionLHS4113	= { FOLLOW_INT_TOK_in_restrictedTypePossiblyFunctionLHS4113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4128  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4128	= { FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4128_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4130  */
static	ANTLR3_BITWORD FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4130_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4130	= { FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4130_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4141  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4141	= { FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4141_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4143  */
static	ANTLR3_BITWORD FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4143_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4143	= { FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4143_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4151  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4151	= { FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_parameterization4176  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_parameterization4176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_parameterization4176	= { FOLLOW_LBRACKET_in_parameterization4176_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_parameterization4178  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_parameterization4178_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_parameterization4178	= { FOLLOW_restrictedType_in_parameterization4178_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_parameterization4189  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_parameterization4189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_parameterization4189	= { FOLLOW_COMMA_in_parameterization4189_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_parameterization4191  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_parameterization4191_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_parameterization4191	= { FOLLOW_restrictedType_in_parameterization4191_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACKET_in_parameterization4199  */
static	ANTLR3_BITWORD FOLLOW_RBRACKET_in_parameterization4199_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACKET_in_parameterization4199	= { FOLLOW_RBRACKET_in_parameterization4199_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNDERSCORE_in_bound4216  */
static	ANTLR3_BITWORD FOLLOW_UNDERSCORE_in_bound4216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNDERSCORE_in_bound4216	= { FOLLOW_UNDERSCORE_in_bound4216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_bound4226  */
static	ANTLR3_BITWORD FOLLOW_integer_in_bound4226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_bound4226	= { FOLLOW_integer_in_bound4226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_typeLetDecl4245  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_typeLetDecl4245_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_typeLetDecl4245	= { FOLLOW_identifier_in_typeLetDecl4245_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_typeLetDecl4249  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_typeLetDecl4249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_typeLetDecl4249	= { FOLLOW_COLON_in_typeLetDecl4249_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_TOK_in_typeLetDecl4251  */
static	ANTLR3_BITWORD FOLLOW_TYPE_TOK_in_typeLetDecl4251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_TOK_in_typeLetDecl4251	= { FOLLOW_TYPE_TOK_in_typeLetDecl4251_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_typeLetDecl4255  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_typeLetDecl4255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_typeLetDecl4255	= { FOLLOW_EQUAL_TOK_in_typeLetDecl4255_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_typeLetDecl4257  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_typeLetDecl4257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_typeLetDecl4257	= { FOLLOW_restrictedType_in_typeLetDecl4257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nots_in_formula4287  */
static	ANTLR3_BITWORD FOLLOW_nots_in_formula4287_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_nots_in_formula4287	= { FOLLOW_nots_in_formula4287_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefixFormula_in_formula4295  */
static	ANTLR3_BITWORD FOLLOW_prefixFormula_in_formula4295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_prefixFormula_in_formula4295	= { FOLLOW_prefixFormula_in_formula4295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparison_in_formula4312  */
static	ANTLR3_BITWORD FOLLOW_comparison_in_formula4312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042), ANTLR3_UINT64_LIT(0x0008140000000000), ANTLR3_UINT64_LIT(0x8000000000002008) };
static  ANTLR3_BITSET_LIST FOLLOW_comparison_in_formula4312	= { FOLLOW_comparison_in_formula4312_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_morecomparisons_in_formula4329  */
static	ANTLR3_BITWORD FOLLOW_morecomparisons_in_formula4329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_morecomparisons_in_formula4329	= { FOLLOW_morecomparisons_in_formula4329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_booleanBinop_in_morecomparisons4368  */
static	ANTLR3_BITWORD FOLLOW_booleanBinop_in_morecomparisons4368_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_booleanBinop_in_morecomparisons4368	= { FOLLOW_booleanBinop_in_morecomparisons4368_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nots_in_morecomparisons4379  */
static	ANTLR3_BITWORD FOLLOW_nots_in_morecomparisons4379_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_nots_in_morecomparisons4379	= { FOLLOW_nots_in_morecomparisons4379_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefixFormula_in_morecomparisons4387  */
static	ANTLR3_BITWORD FOLLOW_prefixFormula_in_morecomparisons4387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_prefixFormula_in_morecomparisons4387	= { FOLLOW_prefixFormula_in_morecomparisons4387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparison_in_morecomparisons4404  */
static	ANTLR3_BITWORD FOLLOW_comparison_in_morecomparisons4404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042), ANTLR3_UINT64_LIT(0x0008140000000000), ANTLR3_UINT64_LIT(0x8000000000002008) };
static  ANTLR3_BITSET_LIST FOLLOW_comparison_in_morecomparisons4404	= { FOLLOW_comparison_in_morecomparisons4404_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_morecomparisons_in_morecomparisons4421  */
static	ANTLR3_BITWORD FOLLOW_morecomparisons_in_morecomparisons4421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_morecomparisons_in_morecomparisons4421	= { FOLLOW_morecomparisons_in_morecomparisons4421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_nots4450  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_nots4450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_nots4450	= { FOLLOW_NOT_TOK_in_nots4450_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_prefixFormula4482  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_prefixFormula4482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_prefixFormula4482	= { FOLLOW_FORALL_TOK_in_prefixFormula4482_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_prefixFormula4488  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_prefixFormula4488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_prefixFormula4488	= { FOLLOW_EXISTS_TOK_in_prefixFormula4488_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_prefixFormula4500  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_prefixFormula4500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_prefixFormula4500	= { FOLLOW_LPAREN_in_prefixFormula4500_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarDecl_in_prefixFormula4506  */
static	ANTLR3_BITWORD FOLLOW_boundVarDecl_in_prefixFormula4506_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarDecl_in_prefixFormula4506	= { FOLLOW_boundVarDecl_in_prefixFormula4506_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_prefixFormula4521  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_prefixFormula4521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_prefixFormula4521	= { FOLLOW_COMMA_in_prefixFormula4521_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarDecl_in_prefixFormula4523  */
static	ANTLR3_BITWORD FOLLOW_boundVarDecl_in_prefixFormula4523_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarDecl_in_prefixFormula4523	= { FOLLOW_boundVarDecl_in_prefixFormula4523_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_prefixFormula4541  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_prefixFormula4541_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_prefixFormula4541	= { FOLLOW_RPAREN_in_prefixFormula4541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_prefixFormula4549  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_prefixFormula4549_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000030) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_prefixFormula4549	= { FOLLOW_COLON_in_prefixFormula4549_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instantiationPatterns_in_prefixFormula4551  */
static	ANTLR3_BITWORD FOLLOW_instantiationPatterns_in_prefixFormula4551_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_instantiationPatterns_in_prefixFormula4551	= { FOLLOW_instantiationPatterns_in_prefixFormula4551_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_prefixFormula4555  */
static	ANTLR3_BITWORD FOLLOW_formula_in_prefixFormula4555_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_prefixFormula4555	= { FOLLOW_formula_in_prefixFormula4555_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_prefixFormula4574  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_prefixFormula4574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_prefixFormula4574	= { FOLLOW_LET_TOK_in_prefixFormula4574_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_letDecl_in_prefixFormula4582  */
static	ANTLR3_BITWORD FOLLOW_letDecl_in_prefixFormula4582_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_letDecl_in_prefixFormula4582	= { FOLLOW_letDecl_in_prefixFormula4582_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_prefixFormula4586  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_prefixFormula4586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_prefixFormula4586	= { FOLLOW_COMMA_in_prefixFormula4586_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_letDecl_in_prefixFormula4588  */
static	ANTLR3_BITWORD FOLLOW_letDecl_in_prefixFormula4588_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_letDecl_in_prefixFormula4588	= { FOLLOW_letDecl_in_prefixFormula4588_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IN_TOK_in_prefixFormula4597  */
static	ANTLR3_BITWORD FOLLOW_IN_TOK_in_prefixFormula4597_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_IN_TOK_in_prefixFormula4597	= { FOLLOW_IN_TOK_in_prefixFormula4597_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_prefixFormula4599  */
static	ANTLR3_BITWORD FOLLOW_formula_in_prefixFormula4599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_prefixFormula4599	= { FOLLOW_formula_in_prefixFormula4599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LAMBDA_in_prefixFormula4614  */
static	ANTLR3_BITWORD FOLLOW_LAMBDA_in_prefixFormula4614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LAMBDA_in_prefixFormula4614	= { FOLLOW_LAMBDA_in_prefixFormula4614_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_prefixFormula4618  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_prefixFormula4618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_prefixFormula4618	= { FOLLOW_LPAREN_in_prefixFormula4618_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarDeclsReturn_in_prefixFormula4624  */
static	ANTLR3_BITWORD FOLLOW_boundVarDeclsReturn_in_prefixFormula4624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarDeclsReturn_in_prefixFormula4624	= { FOLLOW_boundVarDeclsReturn_in_prefixFormula4624_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_prefixFormula4631  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_prefixFormula4631_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_prefixFormula4631	= { FOLLOW_RPAREN_in_prefixFormula4631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_prefixFormula4633  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_prefixFormula4633_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_prefixFormula4633	= { FOLLOW_COLON_in_prefixFormula4633_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_prefixFormula4635  */
static	ANTLR3_BITWORD FOLLOW_formula_in_prefixFormula4635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_prefixFormula4635	= { FOLLOW_formula_in_prefixFormula4635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PATTERN_TOK_in_instantiationPatterns4663  */
static	ANTLR3_BITWORD FOLLOW_PATTERN_TOK_in_instantiationPatterns4663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PATTERN_TOK_in_instantiationPatterns4663	= { FOLLOW_PATTERN_TOK_in_instantiationPatterns4663_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_instantiationPatterns4665  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_instantiationPatterns4665_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_instantiationPatterns4665	= { FOLLOW_LPAREN_in_instantiationPatterns4665_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_instantiationPatterns4667  */
static	ANTLR3_BITWORD FOLLOW_formula_in_instantiationPatterns4667_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_instantiationPatterns4667	= { FOLLOW_formula_in_instantiationPatterns4667_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_instantiationPatterns4673  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_instantiationPatterns4673_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_instantiationPatterns4673	= { FOLLOW_COMMA_in_instantiationPatterns4673_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_instantiationPatterns4675  */
static	ANTLR3_BITWORD FOLLOW_formula_in_instantiationPatterns4675_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_instantiationPatterns4675	= { FOLLOW_formula_in_instantiationPatterns4675_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_instantiationPatterns4683  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_instantiationPatterns4683_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_instantiationPatterns4683	= { FOLLOW_RPAREN_in_instantiationPatterns4683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_instantiationPatterns4685  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_instantiationPatterns4685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_instantiationPatterns4685	= { FOLLOW_COLON_in_instantiationPatterns4685_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_letDecl4722  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_letDecl4722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_letDecl4722	= { FOLLOW_identifier_in_letDecl4722_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_letDecl4725  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_letDecl4725_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_letDecl4725	= { FOLLOW_EQUAL_TOK_in_letDecl4725_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_letDecl4727  */
static	ANTLR3_BITWORD FOLLOW_formula_in_letDecl4727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_letDecl4727	= { FOLLOW_formula_in_letDecl4727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_comparison4808  */
static	ANTLR3_BITWORD FOLLOW_term_in_comparison4808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x1900000848100001) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_comparison4808	= { FOLLOW_term_in_comparison4808_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparisonBinop_in_comparison4819  */
static	ANTLR3_BITWORD FOLLOW_comparisonBinop_in_comparison4819_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA4248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_comparisonBinop_in_comparison4819	= { FOLLOW_comparisonBinop_in_comparison4819_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_comparison4822  */
static	ANTLR3_BITWORD FOLLOW_term_in_comparison4822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x1900000848100001) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_comparison4822	= { FOLLOW_term_in_comparison4822_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uminusTerm_in_term4977  */
static	ANTLR3_BITWORD FOLLOW_uminusTerm_in_term4977_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x6000400001000008), ANTLR3_UINT64_LIT(0x4000000010000040) };
static  ANTLR3_BITSET_LIST FOLLOW_uminusTerm_in_term4977	= { FOLLOW_uminusTerm_in_term4977_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WITH_TOK_in_term4986  */
static	ANTLR3_BITWORD FOLLOW_WITH_TOK_in_term4986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0040000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_WITH_TOK_in_term4986	= { FOLLOW_WITH_TOK_in_term4986_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arrayStore_in_term4996  */
static	ANTLR3_BITWORD FOLLOW_arrayStore_in_term4996_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_arrayStore_in_term4996	= { FOLLOW_arrayStore_in_term4996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_term5001  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_term5001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_term5001	= { FOLLOW_COMMA_in_term5001_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arrayStore_in_term5003  */
static	ANTLR3_BITWORD FOLLOW_arrayStore_in_term5003_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_arrayStore_in_term5003	= { FOLLOW_arrayStore_in_term5003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_term5017  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_term5017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000820000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_term5017	= { FOLLOW_DOT_in_term5017_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tupleStore_in_term5021  */
static	ANTLR3_BITWORD FOLLOW_tupleStore_in_term5021_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tupleStore_in_term5021	= { FOLLOW_tupleStore_in_term5021_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_term5026  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_term5026_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_term5026	= { FOLLOW_COMMA_in_term5026_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_term5028  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_term5028_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_term5028	= { FOLLOW_DOT_in_term5028_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tupleStore_in_term5030  */
static	ANTLR3_BITWORD FOLLOW_tupleStore_in_term5030_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tupleStore_in_term5030	= { FOLLOW_tupleStore_in_term5030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_recordStore_in_term5050  */
static	ANTLR3_BITWORD FOLLOW_recordStore_in_term5050_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_recordStore_in_term5050	= { FOLLOW_recordStore_in_term5050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_term5055  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_term5055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_term5055	= { FOLLOW_COMMA_in_term5055_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_term5057  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_term5057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_term5057	= { FOLLOW_DOT_in_term5057_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_recordStore_in_term5059  */
static	ANTLR3_BITWORD FOLLOW_recordStore_in_term5059_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_recordStore_in_term5059	= { FOLLOW_recordStore_in_term5059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arithmeticBinop_in_term5085  */
static	ANTLR3_BITWORD FOLLOW_arithmeticBinop_in_term5085_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA4248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_arithmeticBinop_in_term5085	= { FOLLOW_arithmeticBinop_in_term5085_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uminusTerm_in_term5088  */
static	ANTLR3_BITWORD FOLLOW_uminusTerm_in_term5088_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x6000400001000008), ANTLR3_UINT64_LIT(0x0000000010000040) };
static  ANTLR3_BITSET_LIST FOLLOW_uminusTerm_in_term5088	= { FOLLOW_uminusTerm_in_term5088_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_arrayStore5129  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_arrayStore5129_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_arrayStore5129	= { FOLLOW_LBRACKET_in_arrayStore5129_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_arrayStore5131  */
static	ANTLR3_BITWORD FOLLOW_formula_in_arrayStore5131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_arrayStore5131	= { FOLLOW_formula_in_arrayStore5131_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACKET_in_arrayStore5134  */
static	ANTLR3_BITWORD FOLLOW_RBRACKET_in_arrayStore5134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0040000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACKET_in_arrayStore5134	= { FOLLOW_RBRACKET_in_arrayStore5134_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arrayStore_in_arrayStore5150  */
static	ANTLR3_BITWORD FOLLOW_arrayStore_in_arrayStore5150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_arrayStore_in_arrayStore5150	= { FOLLOW_arrayStore_in_arrayStore5150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_arrayStore5161  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_arrayStore5161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000820000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_arrayStore5161	= { FOLLOW_DOT_in_arrayStore5161_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tupleStore_in_arrayStore5165  */
static	ANTLR3_BITWORD FOLLOW_tupleStore_in_arrayStore5165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tupleStore_in_arrayStore5165	= { FOLLOW_tupleStore_in_arrayStore5165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_recordStore_in_arrayStore5182  */
static	ANTLR3_BITWORD FOLLOW_recordStore_in_arrayStore5182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_recordStore_in_arrayStore5182	= { FOLLOW_recordStore_in_arrayStore5182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_TOK_in_arrayStore5195  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_TOK_in_arrayStore5195_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA4248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_TOK_in_arrayStore5195	= { FOLLOW_ASSIGN_TOK_in_arrayStore5195_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_arrayStore5197  */
static	ANTLR3_BITWORD FOLLOW_term_in_arrayStore5197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_arrayStore5197	= { FOLLOW_term_in_arrayStore5197_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_tupleStore5229  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_tupleStore5229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0040000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_tupleStore5229	= { FOLLOW_numeral_in_tupleStore5229_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arrayStore_in_tupleStore5245  */
static	ANTLR3_BITWORD FOLLOW_arrayStore_in_tupleStore5245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_arrayStore_in_tupleStore5245	= { FOLLOW_arrayStore_in_tupleStore5245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_tupleStore5256  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_tupleStore5256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000820000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_tupleStore5256	= { FOLLOW_DOT_in_tupleStore5256_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tupleStore_in_tupleStore5260  */
static	ANTLR3_BITWORD FOLLOW_tupleStore_in_tupleStore5260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tupleStore_in_tupleStore5260	= { FOLLOW_tupleStore_in_tupleStore5260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_recordStore_in_tupleStore5277  */
static	ANTLR3_BITWORD FOLLOW_recordStore_in_tupleStore5277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_recordStore_in_tupleStore5277	= { FOLLOW_recordStore_in_tupleStore5277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_TOK_in_tupleStore5290  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_TOK_in_tupleStore5290_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA4248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_TOK_in_tupleStore5290	= { FOLLOW_ASSIGN_TOK_in_tupleStore5290_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_tupleStore5292  */
static	ANTLR3_BITWORD FOLLOW_term_in_tupleStore5292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_tupleStore5292	= { FOLLOW_term_in_tupleStore5292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_recordStore5322  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_recordStore5322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000), ANTLR3_UINT64_LIT(0x0040000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_recordStore5322	= { FOLLOW_identifier_in_recordStore5322_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arrayStore_in_recordStore5339  */
static	ANTLR3_BITWORD FOLLOW_arrayStore_in_recordStore5339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_arrayStore_in_recordStore5339	= { FOLLOW_arrayStore_in_recordStore5339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_recordStore5350  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_recordStore5350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000820000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_recordStore5350	= { FOLLOW_DOT_in_recordStore5350_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tupleStore_in_recordStore5354  */
static	ANTLR3_BITWORD FOLLOW_tupleStore_in_recordStore5354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tupleStore_in_recordStore5354	= { FOLLOW_tupleStore_in_recordStore5354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_recordStore_in_recordStore5371  */
static	ANTLR3_BITWORD FOLLOW_recordStore_in_recordStore5371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_recordStore_in_recordStore5371	= { FOLLOW_recordStore_in_recordStore5371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_TOK_in_recordStore5384  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_TOK_in_recordStore5384_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA4248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_TOK_in_recordStore5384	= { FOLLOW_ASSIGN_TOK_in_recordStore5384_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_recordStore5386  */
static	ANTLR3_BITWORD FOLLOW_term_in_recordStore5386_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_recordStore5386	= { FOLLOW_term_in_recordStore5386_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_TOK_in_uminusTerm5423  */
static	ANTLR3_BITWORD FOLLOW_MINUS_TOK_in_uminusTerm5423_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA4248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_TOK_in_uminusTerm5423	= { FOLLOW_MINUS_TOK_in_uminusTerm5423_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvBinaryOpTerm_in_uminusTerm5429  */
static	ANTLR3_BITWORD FOLLOW_bvBinaryOpTerm_in_uminusTerm5429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvBinaryOpTerm_in_uminusTerm5429	= { FOLLOW_bvBinaryOpTerm_in_uminusTerm5429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvBinaryOpTerm_in_uminusTerm5442  */
static	ANTLR3_BITWORD FOLLOW_bvBinaryOpTerm_in_uminusTerm5442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvBinaryOpTerm_in_uminusTerm5442	= { FOLLOW_bvBinaryOpTerm_in_uminusTerm5442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvNegTerm_in_bvBinaryOpTerm5464  */
static	ANTLR3_BITWORD FOLLOW_bvNegTerm_in_bvBinaryOpTerm5464_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000044002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvNegTerm_in_bvBinaryOpTerm5464	= { FOLLOW_bvNegTerm_in_bvBinaryOpTerm5464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvBinop_in_bvBinaryOpTerm5475  */
static	ANTLR3_BITWORD FOLLOW_bvBinop_in_bvBinaryOpTerm5475_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0x84248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_bvBinop_in_bvBinaryOpTerm5475	= { FOLLOW_bvBinop_in_bvBinaryOpTerm5475_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvNegTerm_in_bvBinaryOpTerm5478  */
static	ANTLR3_BITWORD FOLLOW_bvNegTerm_in_bvBinaryOpTerm5478_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000044002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvNegTerm_in_bvBinaryOpTerm5478	= { FOLLOW_bvNegTerm_in_bvBinaryOpTerm5478_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNEG_TOK_in_bvNegTerm5541  */
static	ANTLR3_BITWORD FOLLOW_BVNEG_TOK_in_bvNegTerm5541_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0x84248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNEG_TOK_in_bvNegTerm5541	= { FOLLOW_BVNEG_TOK_in_bvNegTerm5541_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvNegTerm_in_bvNegTerm5543  */
static	ANTLR3_BITWORD FOLLOW_bvNegTerm_in_bvNegTerm5543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvNegTerm_in_bvNegTerm5543	= { FOLLOW_bvNegTerm_in_bvNegTerm5543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_bvNegTerm5556  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_bvNegTerm5556_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0x84248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_bvNegTerm5556	= { FOLLOW_NOT_TOK_in_bvNegTerm5556_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvNegTerm_in_bvNegTerm5558  */
static	ANTLR3_BITWORD FOLLOW_bvNegTerm_in_bvNegTerm5558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvNegTerm_in_bvNegTerm5558	= { FOLLOW_bvNegTerm_in_bvNegTerm5558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRANSPOSE_TOK_in_bvNegTerm5572  */
static	ANTLR3_BITWORD FOLLOW_TRANSPOSE_TOK_in_bvNegTerm5572_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0x84248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_TRANSPOSE_TOK_in_bvNegTerm5572	= { FOLLOW_TRANSPOSE_TOK_in_bvNegTerm5572_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvNegTerm_in_bvNegTerm5574  */
static	ANTLR3_BITWORD FOLLOW_bvNegTerm_in_bvNegTerm5574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvNegTerm_in_bvNegTerm5574	= { FOLLOW_bvNegTerm_in_bvNegTerm5574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRANSCLOSURE_TOK_in_bvNegTerm5588  */
static	ANTLR3_BITWORD FOLLOW_TRANSCLOSURE_TOK_in_bvNegTerm5588_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0x84248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_TRANSCLOSURE_TOK_in_bvNegTerm5588	= { FOLLOW_TRANSCLOSURE_TOK_in_bvNegTerm5588_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvNegTerm_in_bvNegTerm5590  */
static	ANTLR3_BITWORD FOLLOW_bvNegTerm_in_bvNegTerm5590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bvNegTerm_in_bvNegTerm5590	= { FOLLOW_bvNegTerm_in_bvNegTerm5590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TUPLE_TOK_in_bvNegTerm5603  */
static	ANTLR3_BITWORD FOLLOW_TUPLE_TOK_in_bvNegTerm5603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_TUPLE_TOK_in_bvNegTerm5603	= { FOLLOW_TUPLE_TOK_in_bvNegTerm5603_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvNegTerm5605  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvNegTerm5605_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0x84248B0006000006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvNegTerm5605	= { FOLLOW_LPAREN_in_bvNegTerm5605_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvNegTerm_in_bvNegTerm5607  */
static	ANTLR3_BITWORD FOLLOW_bvNegTerm_in_bvNegTerm5607_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_bvNegTerm_in_bvNegTerm5607	= { FOLLOW_bvNegTerm_in_bvNegTerm5607_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvNegTerm5610  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvNegTerm5610_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvNegTerm5610	= { FOLLOW_RPAREN_in_bvNegTerm5610_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postfixTerm_in_bvNegTerm5635  */
static	ANTLR3_BITWORD FOLLOW_postfixTerm_in_bvNegTerm5635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_postfixTerm_in_bvNegTerm5635	= { FOLLOW_postfixTerm_in_bvNegTerm5635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bvTerm_in_postfixTerm5659  */
static	ANTLR3_BITWORD FOLLOW_bvTerm_in_postfixTerm5659_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002), ANTLR3_UINT64_LIT(0x04C0000000000010), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_bvTerm_in_postfixTerm5659	= { FOLLOW_bvTerm_in_postfixTerm5659_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_postfixTerm5676  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_postfixTerm5676_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_postfixTerm5676	= { FOLLOW_LBRACKET_in_postfixTerm5676_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm5688  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm5688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm5688	= { FOLLOW_formula_in_postfixTerm5688_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_postfixTerm5705  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_postfixTerm5705_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_postfixTerm5705	= { FOLLOW_numeral_in_postfixTerm5705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_postfixTerm5707  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_postfixTerm5707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_postfixTerm5707	= { FOLLOW_COLON_in_postfixTerm5707_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_postfixTerm5711  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_postfixTerm5711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_postfixTerm5711	= { FOLLOW_numeral_in_postfixTerm5711_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACKET_in_postfixTerm5723  */
static	ANTLR3_BITWORD FOLLOW_RBRACKET_in_postfixTerm5723_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002), ANTLR3_UINT64_LIT(0x04C0000000000010), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACKET_in_postfixTerm5723	= { FOLLOW_RBRACKET_in_postfixTerm5723_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFTSHIFT_TOK_in_postfixTerm5749  */
static	ANTLR3_BITWORD FOLLOW_LEFTSHIFT_TOK_in_postfixTerm5749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFTSHIFT_TOK_in_postfixTerm5749	= { FOLLOW_LEFTSHIFT_TOK_in_postfixTerm5749_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHTSHIFT_TOK_in_postfixTerm5761  */
static	ANTLR3_BITWORD FOLLOW_RIGHTSHIFT_TOK_in_postfixTerm5761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RIGHTSHIFT_TOK_in_postfixTerm5761	= { FOLLOW_RIGHTSHIFT_TOK_in_postfixTerm5761_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_postfixTerm5769  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_postfixTerm5769_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002), ANTLR3_UINT64_LIT(0x04C0000000000010), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_postfixTerm5769	= { FOLLOW_numeral_in_postfixTerm5769_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_postfixTerm5794  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_postfixTerm5794_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_postfixTerm5794	= { FOLLOW_LPAREN_in_postfixTerm5794_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm5804  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm5804_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm5804	= { FOLLOW_formula_in_postfixTerm5804_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_postfixTerm5817  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_postfixTerm5817_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_postfixTerm5817	= { FOLLOW_COMMA_in_postfixTerm5817_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm5819  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm5819_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm5819	= { FOLLOW_formula_in_postfixTerm5819_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_postfixTerm5827  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_postfixTerm5827_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002), ANTLR3_UINT64_LIT(0x04C0000000000010), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_postfixTerm5827	= { FOLLOW_RPAREN_in_postfixTerm5827_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_postfixTerm5859  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_postfixTerm5859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000820000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_postfixTerm5859	= { FOLLOW_DOT_in_postfixTerm5859_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_postfixTerm5869  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_postfixTerm5869_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002), ANTLR3_UINT64_LIT(0x04C0000000000010), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_postfixTerm5869	= { FOLLOW_identifier_in_postfixTerm5869_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_postfixTerm5892  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_postfixTerm5892_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002), ANTLR3_UINT64_LIT(0x04C0000000000010), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_postfixTerm5892	= { FOLLOW_numeral_in_postfixTerm5892_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOOR_TOK_in_postfixTerm5925  */
static	ANTLR3_BITWORD FOLLOW_FLOOR_TOK_in_postfixTerm5925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOOR_TOK_in_postfixTerm5925	= { FOLLOW_FLOOR_TOK_in_postfixTerm5925_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_postfixTerm5927  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_postfixTerm5927_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_postfixTerm5927	= { FOLLOW_LPAREN_in_postfixTerm5927_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm5929  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm5929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm5929	= { FOLLOW_formula_in_postfixTerm5929_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_postfixTerm5932  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_postfixTerm5932_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_postfixTerm5932	= { FOLLOW_RPAREN_in_postfixTerm5932_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IS_INTEGER_TOK_in_postfixTerm5948  */
static	ANTLR3_BITWORD FOLLOW_IS_INTEGER_TOK_in_postfixTerm5948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IS_INTEGER_TOK_in_postfixTerm5948	= { FOLLOW_IS_INTEGER_TOK_in_postfixTerm5948_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_postfixTerm5950  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_postfixTerm5950_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_postfixTerm5950	= { FOLLOW_LPAREN_in_postfixTerm5950_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm5952  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm5952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm5952	= { FOLLOW_formula_in_postfixTerm5952_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_postfixTerm5955  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_postfixTerm5955_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_postfixTerm5955	= { FOLLOW_RPAREN_in_postfixTerm5955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ABS_TOK_in_postfixTerm5971  */
static	ANTLR3_BITWORD FOLLOW_ABS_TOK_in_postfixTerm5971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ABS_TOK_in_postfixTerm5971	= { FOLLOW_ABS_TOK_in_postfixTerm5971_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_postfixTerm5973  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_postfixTerm5973_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_postfixTerm5973	= { FOLLOW_LPAREN_in_postfixTerm5973_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm5975  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm5975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm5975	= { FOLLOW_formula_in_postfixTerm5975_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_postfixTerm5978  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_postfixTerm5978_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_postfixTerm5978	= { FOLLOW_RPAREN_in_postfixTerm5978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIVISIBLE_TOK_in_postfixTerm5994  */
static	ANTLR3_BITWORD FOLLOW_DIVISIBLE_TOK_in_postfixTerm5994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DIVISIBLE_TOK_in_postfixTerm5994	= { FOLLOW_DIVISIBLE_TOK_in_postfixTerm5994_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_postfixTerm5996  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_postfixTerm5996_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_postfixTerm5996	= { FOLLOW_LPAREN_in_postfixTerm5996_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm5998  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm5998_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm5998	= { FOLLOW_formula_in_postfixTerm5998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_postfixTerm6001  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_postfixTerm6001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_postfixTerm6001	= { FOLLOW_COMMA_in_postfixTerm6001_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_postfixTerm6005  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_postfixTerm6005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_postfixTerm6005	= { FOLLOW_numeral_in_postfixTerm6005_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_postfixTerm6007  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_postfixTerm6007_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_postfixTerm6007	= { FOLLOW_RPAREN_in_postfixTerm6007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISTINCT_TOK_in_postfixTerm6023  */
static	ANTLR3_BITWORD FOLLOW_DISTINCT_TOK_in_postfixTerm6023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DISTINCT_TOK_in_postfixTerm6023	= { FOLLOW_DISTINCT_TOK_in_postfixTerm6023_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_postfixTerm6025  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_postfixTerm6025_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_postfixTerm6025	= { FOLLOW_LPAREN_in_postfixTerm6025_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm6033  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm6033_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm6033	= { FOLLOW_formula_in_postfixTerm6033_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_postfixTerm6046  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_postfixTerm6046_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_postfixTerm6046	= { FOLLOW_COMMA_in_postfixTerm6046_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_postfixTerm6048  */
static	ANTLR3_BITWORD FOLLOW_formula_in_postfixTerm6048_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_postfixTerm6048	= { FOLLOW_formula_in_postfixTerm6048_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_postfixTerm6056  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_postfixTerm6056_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_postfixTerm6056	= { FOLLOW_RPAREN_in_postfixTerm6056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeAscription_in_postfixTerm6078  */
static	ANTLR3_BITWORD FOLLOW_typeAscription_in_postfixTerm6078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeAscription_in_postfixTerm6078	= { FOLLOW_typeAscription_in_postfixTerm6078_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVXOR_TOK_in_bvTerm6119  */
static	ANTLR3_BITWORD FOLLOW_BVXOR_TOK_in_bvTerm6119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVXOR_TOK_in_bvTerm6119	= { FOLLOW_BVXOR_TOK_in_bvTerm6119_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6121  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6121_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6121	= { FOLLOW_LPAREN_in_bvTerm6121_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6123  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6123_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6123	= { FOLLOW_formula_in_bvTerm6123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6126  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6126_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6126	= { FOLLOW_COMMA_in_bvTerm6126_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6128  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6128	= { FOLLOW_formula_in_bvTerm6128_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6131  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6131	= { FOLLOW_RPAREN_in_bvTerm6131_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNAND_TOK_in_bvTerm6143  */
static	ANTLR3_BITWORD FOLLOW_BVNAND_TOK_in_bvTerm6143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNAND_TOK_in_bvTerm6143	= { FOLLOW_BVNAND_TOK_in_bvTerm6143_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6145  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6145_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6145	= { FOLLOW_LPAREN_in_bvTerm6145_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6147  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6147_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6147	= { FOLLOW_formula_in_bvTerm6147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6150  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6150_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6150	= { FOLLOW_COMMA_in_bvTerm6150_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6152  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6152	= { FOLLOW_formula_in_bvTerm6152_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6155  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6155	= { FOLLOW_RPAREN_in_bvTerm6155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNOR_TOK_in_bvTerm6167  */
static	ANTLR3_BITWORD FOLLOW_BVNOR_TOK_in_bvTerm6167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNOR_TOK_in_bvTerm6167	= { FOLLOW_BVNOR_TOK_in_bvTerm6167_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6169  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6169_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6169	= { FOLLOW_LPAREN_in_bvTerm6169_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6171  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6171_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6171	= { FOLLOW_formula_in_bvTerm6171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6174  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6174_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6174	= { FOLLOW_COMMA_in_bvTerm6174_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6176  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6176	= { FOLLOW_formula_in_bvTerm6176_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6179  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6179	= { FOLLOW_RPAREN_in_bvTerm6179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVCOMP_TOK_in_bvTerm6191  */
static	ANTLR3_BITWORD FOLLOW_BVCOMP_TOK_in_bvTerm6191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVCOMP_TOK_in_bvTerm6191	= { FOLLOW_BVCOMP_TOK_in_bvTerm6191_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6193  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6193_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6193	= { FOLLOW_LPAREN_in_bvTerm6193_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6195  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6195_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6195	= { FOLLOW_formula_in_bvTerm6195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6198  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6198_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6198	= { FOLLOW_COMMA_in_bvTerm6198_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6200  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6200	= { FOLLOW_formula_in_bvTerm6200_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6203  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6203	= { FOLLOW_RPAREN_in_bvTerm6203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVXNOR_TOK_in_bvTerm6215  */
static	ANTLR3_BITWORD FOLLOW_BVXNOR_TOK_in_bvTerm6215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVXNOR_TOK_in_bvTerm6215	= { FOLLOW_BVXNOR_TOK_in_bvTerm6215_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6217  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6217_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6217	= { FOLLOW_LPAREN_in_bvTerm6217_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6219  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6219_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6219	= { FOLLOW_formula_in_bvTerm6219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6222  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6222_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6222	= { FOLLOW_COMMA_in_bvTerm6222_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6224  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6224	= { FOLLOW_formula_in_bvTerm6224_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6227  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6227	= { FOLLOW_RPAREN_in_bvTerm6227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUMINUS_TOK_in_bvTerm6246  */
static	ANTLR3_BITWORD FOLLOW_BVUMINUS_TOK_in_bvTerm6246_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUMINUS_TOK_in_bvTerm6246	= { FOLLOW_BVUMINUS_TOK_in_bvTerm6246_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6248  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6248_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6248	= { FOLLOW_LPAREN_in_bvTerm6248_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6250  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6250	= { FOLLOW_formula_in_bvTerm6250_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6253  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6253	= { FOLLOW_RPAREN_in_bvTerm6253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVPLUS_TOK_in_bvTerm6271  */
static	ANTLR3_BITWORD FOLLOW_BVPLUS_TOK_in_bvTerm6271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVPLUS_TOK_in_bvTerm6271	= { FOLLOW_BVPLUS_TOK_in_bvTerm6271_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6273  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6273	= { FOLLOW_LPAREN_in_bvTerm6273_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6277  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6277_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6277	= { FOLLOW_numeral_in_bvTerm6277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6279  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6279_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6279	= { FOLLOW_COMMA_in_bvTerm6279_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6281  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6281_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6281	= { FOLLOW_formula_in_bvTerm6281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6292  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6292_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6292	= { FOLLOW_COMMA_in_bvTerm6292_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6294  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6294_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6294	= { FOLLOW_formula_in_bvTerm6294_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6302  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6302	= { FOLLOW_RPAREN_in_bvTerm6302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSUB_TOK_in_bvTerm6320  */
static	ANTLR3_BITWORD FOLLOW_BVSUB_TOK_in_bvTerm6320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSUB_TOK_in_bvTerm6320	= { FOLLOW_BVSUB_TOK_in_bvTerm6320_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6322  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6322	= { FOLLOW_LPAREN_in_bvTerm6322_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6326  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6326_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6326	= { FOLLOW_numeral_in_bvTerm6326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6328  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6328_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6328	= { FOLLOW_COMMA_in_bvTerm6328_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6330  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6330_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6330	= { FOLLOW_formula_in_bvTerm6330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6333  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6333_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6333	= { FOLLOW_COMMA_in_bvTerm6333_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6335  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6335	= { FOLLOW_formula_in_bvTerm6335_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6338  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6338	= { FOLLOW_RPAREN_in_bvTerm6338_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVMULT_TOK_in_bvTerm6356  */
static	ANTLR3_BITWORD FOLLOW_BVMULT_TOK_in_bvTerm6356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVMULT_TOK_in_bvTerm6356	= { FOLLOW_BVMULT_TOK_in_bvTerm6356_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6358  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6358	= { FOLLOW_LPAREN_in_bvTerm6358_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6362  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6362_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6362	= { FOLLOW_numeral_in_bvTerm6362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6364  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6364_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6364	= { FOLLOW_COMMA_in_bvTerm6364_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6366  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6366_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6366	= { FOLLOW_formula_in_bvTerm6366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6369  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6369_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6369	= { FOLLOW_COMMA_in_bvTerm6369_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6371  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6371	= { FOLLOW_formula_in_bvTerm6371_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6374  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6374	= { FOLLOW_RPAREN_in_bvTerm6374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUDIV_TOK_in_bvTerm6392  */
static	ANTLR3_BITWORD FOLLOW_BVUDIV_TOK_in_bvTerm6392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUDIV_TOK_in_bvTerm6392	= { FOLLOW_BVUDIV_TOK_in_bvTerm6392_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6394  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6394_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6394	= { FOLLOW_LPAREN_in_bvTerm6394_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6396  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6396_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6396	= { FOLLOW_formula_in_bvTerm6396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6399  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6399_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6399	= { FOLLOW_COMMA_in_bvTerm6399_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6401  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6401	= { FOLLOW_formula_in_bvTerm6401_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6404  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6404	= { FOLLOW_RPAREN_in_bvTerm6404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSDIV_TOK_in_bvTerm6422  */
static	ANTLR3_BITWORD FOLLOW_BVSDIV_TOK_in_bvTerm6422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSDIV_TOK_in_bvTerm6422	= { FOLLOW_BVSDIV_TOK_in_bvTerm6422_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6424  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6424_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6424	= { FOLLOW_LPAREN_in_bvTerm6424_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6426  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6426_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6426	= { FOLLOW_formula_in_bvTerm6426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6429  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6429_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6429	= { FOLLOW_COMMA_in_bvTerm6429_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6431  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6431	= { FOLLOW_formula_in_bvTerm6431_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6434  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6434	= { FOLLOW_RPAREN_in_bvTerm6434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUREM_TOK_in_bvTerm6452  */
static	ANTLR3_BITWORD FOLLOW_BVUREM_TOK_in_bvTerm6452_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUREM_TOK_in_bvTerm6452	= { FOLLOW_BVUREM_TOK_in_bvTerm6452_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6454  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6454_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6454	= { FOLLOW_LPAREN_in_bvTerm6454_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6456  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6456_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6456	= { FOLLOW_formula_in_bvTerm6456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6459  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6459_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6459	= { FOLLOW_COMMA_in_bvTerm6459_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6461  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6461	= { FOLLOW_formula_in_bvTerm6461_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6464  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6464	= { FOLLOW_RPAREN_in_bvTerm6464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSREM_TOK_in_bvTerm6482  */
static	ANTLR3_BITWORD FOLLOW_BVSREM_TOK_in_bvTerm6482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSREM_TOK_in_bvTerm6482	= { FOLLOW_BVSREM_TOK_in_bvTerm6482_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6484  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6484_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6484	= { FOLLOW_LPAREN_in_bvTerm6484_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6486  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6486_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6486	= { FOLLOW_formula_in_bvTerm6486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6489  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6489_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6489	= { FOLLOW_COMMA_in_bvTerm6489_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6491  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6491	= { FOLLOW_formula_in_bvTerm6491_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6494  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6494	= { FOLLOW_RPAREN_in_bvTerm6494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSMOD_TOK_in_bvTerm6512  */
static	ANTLR3_BITWORD FOLLOW_BVSMOD_TOK_in_bvTerm6512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSMOD_TOK_in_bvTerm6512	= { FOLLOW_BVSMOD_TOK_in_bvTerm6512_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6514  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6514_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6514	= { FOLLOW_LPAREN_in_bvTerm6514_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6516  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6516_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6516	= { FOLLOW_formula_in_bvTerm6516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6519  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6519_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6519	= { FOLLOW_COMMA_in_bvTerm6519_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6521  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6521	= { FOLLOW_formula_in_bvTerm6521_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6524  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6524	= { FOLLOW_RPAREN_in_bvTerm6524_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSHL_TOK_in_bvTerm6542  */
static	ANTLR3_BITWORD FOLLOW_BVSHL_TOK_in_bvTerm6542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSHL_TOK_in_bvTerm6542	= { FOLLOW_BVSHL_TOK_in_bvTerm6542_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6544  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6544_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6544	= { FOLLOW_LPAREN_in_bvTerm6544_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6546  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6546_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6546	= { FOLLOW_formula_in_bvTerm6546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6549  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6549_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6549	= { FOLLOW_COMMA_in_bvTerm6549_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6551  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6551	= { FOLLOW_formula_in_bvTerm6551_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6554  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6554	= { FOLLOW_RPAREN_in_bvTerm6554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVASHR_TOK_in_bvTerm6572  */
static	ANTLR3_BITWORD FOLLOW_BVASHR_TOK_in_bvTerm6572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVASHR_TOK_in_bvTerm6572	= { FOLLOW_BVASHR_TOK_in_bvTerm6572_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6574  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6574_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6574	= { FOLLOW_LPAREN_in_bvTerm6574_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6576  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6576_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6576	= { FOLLOW_formula_in_bvTerm6576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6579  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6579_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6579	= { FOLLOW_COMMA_in_bvTerm6579_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6581  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6581	= { FOLLOW_formula_in_bvTerm6581_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6584  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6584_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6584	= { FOLLOW_RPAREN_in_bvTerm6584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVLSHR_TOK_in_bvTerm6602  */
static	ANTLR3_BITWORD FOLLOW_BVLSHR_TOK_in_bvTerm6602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVLSHR_TOK_in_bvTerm6602	= { FOLLOW_BVLSHR_TOK_in_bvTerm6602_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6604  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6604_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6604	= { FOLLOW_LPAREN_in_bvTerm6604_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6606  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6606_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6606	= { FOLLOW_formula_in_bvTerm6606_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6609  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6609_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6609	= { FOLLOW_COMMA_in_bvTerm6609_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6611  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6611_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6611	= { FOLLOW_formula_in_bvTerm6611_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6614  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6614	= { FOLLOW_RPAREN_in_bvTerm6614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SX_TOK_in_bvTerm6632  */
static	ANTLR3_BITWORD FOLLOW_SX_TOK_in_bvTerm6632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SX_TOK_in_bvTerm6632	= { FOLLOW_SX_TOK_in_bvTerm6632_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6634  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6634_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6634	= { FOLLOW_LPAREN_in_bvTerm6634_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6636  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6636_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6636	= { FOLLOW_formula_in_bvTerm6636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6639  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6639	= { FOLLOW_COMMA_in_bvTerm6639_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6643  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6643	= { FOLLOW_numeral_in_bvTerm6643_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6645  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6645	= { FOLLOW_RPAREN_in_bvTerm6645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVZEROEXTEND_TOK_in_bvTerm6663  */
static	ANTLR3_BITWORD FOLLOW_BVZEROEXTEND_TOK_in_bvTerm6663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVZEROEXTEND_TOK_in_bvTerm6663	= { FOLLOW_BVZEROEXTEND_TOK_in_bvTerm6663_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6665  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6665_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6665	= { FOLLOW_LPAREN_in_bvTerm6665_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6667  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6667_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6667	= { FOLLOW_formula_in_bvTerm6667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6670  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6670	= { FOLLOW_COMMA_in_bvTerm6670_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6674  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6674	= { FOLLOW_numeral_in_bvTerm6674_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6676  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6676	= { FOLLOW_RPAREN_in_bvTerm6676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVREPEAT_TOK_in_bvTerm6694  */
static	ANTLR3_BITWORD FOLLOW_BVREPEAT_TOK_in_bvTerm6694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVREPEAT_TOK_in_bvTerm6694	= { FOLLOW_BVREPEAT_TOK_in_bvTerm6694_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6696  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6696_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6696	= { FOLLOW_LPAREN_in_bvTerm6696_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6698  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6698_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6698	= { FOLLOW_formula_in_bvTerm6698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6701  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6701	= { FOLLOW_COMMA_in_bvTerm6701_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6705  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6705	= { FOLLOW_numeral_in_bvTerm6705_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6707  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6707	= { FOLLOW_RPAREN_in_bvTerm6707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVROTR_TOK_in_bvTerm6725  */
static	ANTLR3_BITWORD FOLLOW_BVROTR_TOK_in_bvTerm6725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVROTR_TOK_in_bvTerm6725	= { FOLLOW_BVROTR_TOK_in_bvTerm6725_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6727  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6727_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6727	= { FOLLOW_LPAREN_in_bvTerm6727_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6729  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6729_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6729	= { FOLLOW_formula_in_bvTerm6729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6732  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6732	= { FOLLOW_COMMA_in_bvTerm6732_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6736  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6736	= { FOLLOW_numeral_in_bvTerm6736_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6738  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6738_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6738	= { FOLLOW_RPAREN_in_bvTerm6738_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVROTL_TOK_in_bvTerm6756  */
static	ANTLR3_BITWORD FOLLOW_BVROTL_TOK_in_bvTerm6756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVROTL_TOK_in_bvTerm6756	= { FOLLOW_BVROTL_TOK_in_bvTerm6756_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6758  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6758_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6758	= { FOLLOW_LPAREN_in_bvTerm6758_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6760  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6760_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6760	= { FOLLOW_formula_in_bvTerm6760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6763  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6763	= { FOLLOW_COMMA_in_bvTerm6763_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeral_in_bvTerm6767  */
static	ANTLR3_BITWORD FOLLOW_numeral_in_bvTerm6767_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_numeral_in_bvTerm6767	= { FOLLOW_numeral_in_bvTerm6767_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6769  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6769	= { FOLLOW_RPAREN_in_bvTerm6769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVLT_TOK_in_bvTerm6788  */
static	ANTLR3_BITWORD FOLLOW_BVLT_TOK_in_bvTerm6788_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVLT_TOK_in_bvTerm6788	= { FOLLOW_BVLT_TOK_in_bvTerm6788_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6790  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6790_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6790	= { FOLLOW_LPAREN_in_bvTerm6790_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6792  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6792_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6792	= { FOLLOW_formula_in_bvTerm6792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6795  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6795_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6795	= { FOLLOW_COMMA_in_bvTerm6795_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6797  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6797	= { FOLLOW_formula_in_bvTerm6797_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6800  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6800	= { FOLLOW_RPAREN_in_bvTerm6800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVLE_TOK_in_bvTerm6812  */
static	ANTLR3_BITWORD FOLLOW_BVLE_TOK_in_bvTerm6812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVLE_TOK_in_bvTerm6812	= { FOLLOW_BVLE_TOK_in_bvTerm6812_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6814  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6814_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6814	= { FOLLOW_LPAREN_in_bvTerm6814_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6816  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6816_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6816	= { FOLLOW_formula_in_bvTerm6816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6819  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6819_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6819	= { FOLLOW_COMMA_in_bvTerm6819_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6821  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6821	= { FOLLOW_formula_in_bvTerm6821_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6824  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6824	= { FOLLOW_RPAREN_in_bvTerm6824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVGT_TOK_in_bvTerm6836  */
static	ANTLR3_BITWORD FOLLOW_BVGT_TOK_in_bvTerm6836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVGT_TOK_in_bvTerm6836	= { FOLLOW_BVGT_TOK_in_bvTerm6836_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6838  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6838_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6838	= { FOLLOW_LPAREN_in_bvTerm6838_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6840  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6840_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6840	= { FOLLOW_formula_in_bvTerm6840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6843  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6843_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6843	= { FOLLOW_COMMA_in_bvTerm6843_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6845  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6845	= { FOLLOW_formula_in_bvTerm6845_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6848  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6848	= { FOLLOW_RPAREN_in_bvTerm6848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVGE_TOK_in_bvTerm6860  */
static	ANTLR3_BITWORD FOLLOW_BVGE_TOK_in_bvTerm6860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVGE_TOK_in_bvTerm6860	= { FOLLOW_BVGE_TOK_in_bvTerm6860_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6862  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6862_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6862	= { FOLLOW_LPAREN_in_bvTerm6862_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6864  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6864_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6864	= { FOLLOW_formula_in_bvTerm6864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6867  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6867_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6867	= { FOLLOW_COMMA_in_bvTerm6867_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6869  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6869	= { FOLLOW_formula_in_bvTerm6869_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6872  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6872	= { FOLLOW_RPAREN_in_bvTerm6872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSLT_TOK_in_bvTerm6884  */
static	ANTLR3_BITWORD FOLLOW_BVSLT_TOK_in_bvTerm6884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSLT_TOK_in_bvTerm6884	= { FOLLOW_BVSLT_TOK_in_bvTerm6884_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6886  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6886_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6886	= { FOLLOW_LPAREN_in_bvTerm6886_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6888  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6888_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6888	= { FOLLOW_formula_in_bvTerm6888_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6891  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6891_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6891	= { FOLLOW_COMMA_in_bvTerm6891_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6893  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6893	= { FOLLOW_formula_in_bvTerm6893_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6896  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6896	= { FOLLOW_RPAREN_in_bvTerm6896_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSLE_TOK_in_bvTerm6908  */
static	ANTLR3_BITWORD FOLLOW_BVSLE_TOK_in_bvTerm6908_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSLE_TOK_in_bvTerm6908	= { FOLLOW_BVSLE_TOK_in_bvTerm6908_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6910  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6910_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6910	= { FOLLOW_LPAREN_in_bvTerm6910_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6912  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6912_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6912	= { FOLLOW_formula_in_bvTerm6912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6915  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6915_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6915	= { FOLLOW_COMMA_in_bvTerm6915_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6917  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6917	= { FOLLOW_formula_in_bvTerm6917_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6920  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6920	= { FOLLOW_RPAREN_in_bvTerm6920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSGT_TOK_in_bvTerm6932  */
static	ANTLR3_BITWORD FOLLOW_BVSGT_TOK_in_bvTerm6932_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSGT_TOK_in_bvTerm6932	= { FOLLOW_BVSGT_TOK_in_bvTerm6932_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6934  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6934_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6934	= { FOLLOW_LPAREN_in_bvTerm6934_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6936  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6936_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6936	= { FOLLOW_formula_in_bvTerm6936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6939  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6939_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6939	= { FOLLOW_COMMA_in_bvTerm6939_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6941  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6941	= { FOLLOW_formula_in_bvTerm6941_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6944  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6944	= { FOLLOW_RPAREN_in_bvTerm6944_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSGE_TOK_in_bvTerm6956  */
static	ANTLR3_BITWORD FOLLOW_BVSGE_TOK_in_bvTerm6956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSGE_TOK_in_bvTerm6956	= { FOLLOW_BVSGE_TOK_in_bvTerm6956_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_bvTerm6958  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_bvTerm6958_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_bvTerm6958	= { FOLLOW_LPAREN_in_bvTerm6958_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6960  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6960_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6960	= { FOLLOW_formula_in_bvTerm6960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_bvTerm6963  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_bvTerm6963_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_bvTerm6963	= { FOLLOW_COMMA_in_bvTerm6963_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_bvTerm6965  */
static	ANTLR3_BITWORD FOLLOW_formula_in_bvTerm6965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_bvTerm6965	= { FOLLOW_formula_in_bvTerm6965_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_bvTerm6968  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_bvTerm6968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_bvTerm6968	= { FOLLOW_RPAREN_in_bvTerm6968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stringTerm_in_bvTerm6980  */
static	ANTLR3_BITWORD FOLLOW_stringTerm_in_bvTerm6980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stringTerm_in_bvTerm6980	= { FOLLOW_stringTerm_in_bvTerm6980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_CONCAT_TOK_in_stringTerm7006  */
static	ANTLR3_BITWORD FOLLOW_STRING_CONCAT_TOK_in_stringTerm7006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_CONCAT_TOK_in_stringTerm7006	= { FOLLOW_STRING_CONCAT_TOK_in_stringTerm7006_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7008  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7008_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7008	= { FOLLOW_LPAREN_in_stringTerm7008_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7010  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7010_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7010	= { FOLLOW_formula_in_stringTerm7010_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7021  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7021_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7021	= { FOLLOW_COMMA_in_stringTerm7021_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7023  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7023_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7023	= { FOLLOW_formula_in_stringTerm7023_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7031  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7031	= { FOLLOW_RPAREN_in_stringTerm7031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LENGTH_TOK_in_stringTerm7043  */
static	ANTLR3_BITWORD FOLLOW_STRING_LENGTH_TOK_in_stringTerm7043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LENGTH_TOK_in_stringTerm7043	= { FOLLOW_STRING_LENGTH_TOK_in_stringTerm7043_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7045  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7045_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7045	= { FOLLOW_LPAREN_in_stringTerm7045_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7047  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7047	= { FOLLOW_formula_in_stringTerm7047_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7050  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7050	= { FOLLOW_RPAREN_in_stringTerm7050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_CONTAINS_TOK_in_stringTerm7062  */
static	ANTLR3_BITWORD FOLLOW_STRING_CONTAINS_TOK_in_stringTerm7062_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_CONTAINS_TOK_in_stringTerm7062	= { FOLLOW_STRING_CONTAINS_TOK_in_stringTerm7062_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7064  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7064_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7064	= { FOLLOW_LPAREN_in_stringTerm7064_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7066  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7066_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7066	= { FOLLOW_formula_in_stringTerm7066_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7069  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7069_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7069	= { FOLLOW_COMMA_in_stringTerm7069_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7071  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7071	= { FOLLOW_formula_in_stringTerm7071_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7074  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7074	= { FOLLOW_RPAREN_in_stringTerm7074_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_SUBSTR_TOK_in_stringTerm7086  */
static	ANTLR3_BITWORD FOLLOW_STRING_SUBSTR_TOK_in_stringTerm7086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_SUBSTR_TOK_in_stringTerm7086	= { FOLLOW_STRING_SUBSTR_TOK_in_stringTerm7086_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7088  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7088_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7088	= { FOLLOW_LPAREN_in_stringTerm7088_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7090  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7090_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7090	= { FOLLOW_formula_in_stringTerm7090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7093  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7093_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7093	= { FOLLOW_COMMA_in_stringTerm7093_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7095  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7095_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7095	= { FOLLOW_formula_in_stringTerm7095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7098  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7098_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7098	= { FOLLOW_COMMA_in_stringTerm7098_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7100  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7100	= { FOLLOW_formula_in_stringTerm7100_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7103  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7103	= { FOLLOW_RPAREN_in_stringTerm7103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_INDEXOF_TOK_in_stringTerm7115  */
static	ANTLR3_BITWORD FOLLOW_STRING_INDEXOF_TOK_in_stringTerm7115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_INDEXOF_TOK_in_stringTerm7115	= { FOLLOW_STRING_INDEXOF_TOK_in_stringTerm7115_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7117  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7117_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7117	= { FOLLOW_LPAREN_in_stringTerm7117_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7119  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7119_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7119	= { FOLLOW_formula_in_stringTerm7119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7122  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7122_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7122	= { FOLLOW_COMMA_in_stringTerm7122_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7124  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7124_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7124	= { FOLLOW_formula_in_stringTerm7124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7127  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7127_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7127	= { FOLLOW_COMMA_in_stringTerm7127_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7129  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7129	= { FOLLOW_formula_in_stringTerm7129_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7132  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7132	= { FOLLOW_RPAREN_in_stringTerm7132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_REPLACE_TOK_in_stringTerm7144  */
static	ANTLR3_BITWORD FOLLOW_STRING_REPLACE_TOK_in_stringTerm7144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_REPLACE_TOK_in_stringTerm7144	= { FOLLOW_STRING_REPLACE_TOK_in_stringTerm7144_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7146  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7146_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7146	= { FOLLOW_LPAREN_in_stringTerm7146_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7148  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7148_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7148	= { FOLLOW_formula_in_stringTerm7148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7151  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7151_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7151	= { FOLLOW_COMMA_in_stringTerm7151_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7153  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7153_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7153	= { FOLLOW_formula_in_stringTerm7153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7156  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7156_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7156	= { FOLLOW_COMMA_in_stringTerm7156_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7158  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7158	= { FOLLOW_formula_in_stringTerm7158_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7161  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7161	= { FOLLOW_RPAREN_in_stringTerm7161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_PREFIXOF_TOK_in_stringTerm7173  */
static	ANTLR3_BITWORD FOLLOW_STRING_PREFIXOF_TOK_in_stringTerm7173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_PREFIXOF_TOK_in_stringTerm7173	= { FOLLOW_STRING_PREFIXOF_TOK_in_stringTerm7173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7175  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7175_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7175	= { FOLLOW_LPAREN_in_stringTerm7175_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7177  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7177_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7177	= { FOLLOW_formula_in_stringTerm7177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7180  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7180_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7180	= { FOLLOW_COMMA_in_stringTerm7180_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7182  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7182	= { FOLLOW_formula_in_stringTerm7182_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7185  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7185	= { FOLLOW_RPAREN_in_stringTerm7185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_SUFFIXOF_TOK_in_stringTerm7197  */
static	ANTLR3_BITWORD FOLLOW_STRING_SUFFIXOF_TOK_in_stringTerm7197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_SUFFIXOF_TOK_in_stringTerm7197	= { FOLLOW_STRING_SUFFIXOF_TOK_in_stringTerm7197_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7199  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7199_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7199	= { FOLLOW_LPAREN_in_stringTerm7199_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7201  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7201_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7201	= { FOLLOW_formula_in_stringTerm7201_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stringTerm7204  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stringTerm7204_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stringTerm7204	= { FOLLOW_COMMA_in_stringTerm7204_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7206  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7206_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7206	= { FOLLOW_formula_in_stringTerm7206_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7209  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7209	= { FOLLOW_RPAREN_in_stringTerm7209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_STOI_TOK_in_stringTerm7221  */
static	ANTLR3_BITWORD FOLLOW_STRING_STOI_TOK_in_stringTerm7221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_STOI_TOK_in_stringTerm7221	= { FOLLOW_STRING_STOI_TOK_in_stringTerm7221_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7223  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7223_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7223	= { FOLLOW_LPAREN_in_stringTerm7223_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7225  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7225	= { FOLLOW_formula_in_stringTerm7225_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7228  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7228	= { FOLLOW_RPAREN_in_stringTerm7228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_ITOS_TOK_in_stringTerm7240  */
static	ANTLR3_BITWORD FOLLOW_STRING_ITOS_TOK_in_stringTerm7240_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_ITOS_TOK_in_stringTerm7240	= { FOLLOW_STRING_ITOS_TOK_in_stringTerm7240_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7242  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7242_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7242	= { FOLLOW_LPAREN_in_stringTerm7242_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7244  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7244_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7244	= { FOLLOW_formula_in_stringTerm7244_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7247  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7247	= { FOLLOW_RPAREN_in_stringTerm7247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_U16TOS_TOK_in_stringTerm7259  */
static	ANTLR3_BITWORD FOLLOW_STRING_U16TOS_TOK_in_stringTerm7259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_U16TOS_TOK_in_stringTerm7259	= { FOLLOW_STRING_U16TOS_TOK_in_stringTerm7259_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7261  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7261_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7261	= { FOLLOW_LPAREN_in_stringTerm7261_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7263  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7263	= { FOLLOW_formula_in_stringTerm7263_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7266  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7266	= { FOLLOW_RPAREN_in_stringTerm7266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_STOU16_TOK_in_stringTerm7278  */
static	ANTLR3_BITWORD FOLLOW_STRING_STOU16_TOK_in_stringTerm7278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_STOU16_TOK_in_stringTerm7278	= { FOLLOW_STRING_STOU16_TOK_in_stringTerm7278_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7280  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7280_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7280	= { FOLLOW_LPAREN_in_stringTerm7280_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7282  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7282	= { FOLLOW_formula_in_stringTerm7282_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7285  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7285	= { FOLLOW_RPAREN_in_stringTerm7285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_U32TOS_TOK_in_stringTerm7297  */
static	ANTLR3_BITWORD FOLLOW_STRING_U32TOS_TOK_in_stringTerm7297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_U32TOS_TOK_in_stringTerm7297	= { FOLLOW_STRING_U32TOS_TOK_in_stringTerm7297_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7299  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7299_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7299	= { FOLLOW_LPAREN_in_stringTerm7299_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7301  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7301	= { FOLLOW_formula_in_stringTerm7301_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7304  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7304	= { FOLLOW_RPAREN_in_stringTerm7304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_STOU32_TOK_in_stringTerm7316  */
static	ANTLR3_BITWORD FOLLOW_STRING_STOU32_TOK_in_stringTerm7316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_STOU32_TOK_in_stringTerm7316	= { FOLLOW_STRING_STOU32_TOK_in_stringTerm7316_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_stringTerm7318  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_stringTerm7318_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_stringTerm7318	= { FOLLOW_LPAREN_in_stringTerm7318_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_stringTerm7320  */
static	ANTLR3_BITWORD FOLLOW_formula_in_stringTerm7320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_stringTerm7320	= { FOLLOW_formula_in_stringTerm7320_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_stringTerm7323  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_stringTerm7323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_stringTerm7323	= { FOLLOW_RPAREN_in_stringTerm7323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_stringTerm7346  */
static	ANTLR3_BITWORD FOLLOW_str_in_stringTerm7346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_stringTerm7346	= { FOLLOW_str_in_stringTerm7346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setsTerm_in_stringTerm7360  */
static	ANTLR3_BITWORD FOLLOW_setsTerm_in_stringTerm7360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setsTerm_in_stringTerm7360	= { FOLLOW_setsTerm_in_stringTerm7360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SETS_CARD_TOK_in_setsTerm7388  */
static	ANTLR3_BITWORD FOLLOW_SETS_CARD_TOK_in_setsTerm7388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SETS_CARD_TOK_in_setsTerm7388	= { FOLLOW_SETS_CARD_TOK_in_setsTerm7388_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_setsTerm7390  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_setsTerm7390_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_setsTerm7390	= { FOLLOW_LPAREN_in_setsTerm7390_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_setsTerm7392  */
static	ANTLR3_BITWORD FOLLOW_formula_in_setsTerm7392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_setsTerm7392	= { FOLLOW_formula_in_setsTerm7392_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_setsTerm7395  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_setsTerm7395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_setsTerm7395	= { FOLLOW_RPAREN_in_setsTerm7395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleTerm_in_setsTerm7407  */
static	ANTLR3_BITWORD FOLLOW_simpleTerm_in_setsTerm7407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleTerm_in_setsTerm7407	= { FOLLOW_simpleTerm_in_setsTerm7407_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_iteTerm_in_simpleTerm7438  */
static	ANTLR3_BITWORD FOLLOW_iteTerm_in_simpleTerm7438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_iteTerm_in_simpleTerm7438	= { FOLLOW_iteTerm_in_simpleTerm7438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_simpleTerm7461  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_simpleTerm7461_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_simpleTerm7461	= { FOLLOW_LPAREN_in_simpleTerm7461_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_simpleTerm7463  */
static	ANTLR3_BITWORD FOLLOW_formula_in_simpleTerm7463_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_simpleTerm7463	= { FOLLOW_formula_in_simpleTerm7463_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_simpleTerm7474  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_simpleTerm7474_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_simpleTerm7474	= { FOLLOW_COMMA_in_simpleTerm7474_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_simpleTerm7476  */
static	ANTLR3_BITWORD FOLLOW_formula_in_simpleTerm7476_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_simpleTerm7476	= { FOLLOW_formula_in_simpleTerm7476_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_simpleTerm7484  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_simpleTerm7484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_simpleTerm7484	= { FOLLOW_RPAREN_in_simpleTerm7484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_simpleTerm7507  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_simpleTerm7507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_simpleTerm7507	= { FOLLOW_LPAREN_in_simpleTerm7507_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_simpleTerm7509  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_simpleTerm7509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_simpleTerm7509	= { FOLLOW_RPAREN_in_simpleTerm7509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARENHASH_in_simpleTerm7553  */
static	ANTLR3_BITWORD FOLLOW_PARENHASH_in_simpleTerm7553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PARENHASH_in_simpleTerm7553	= { FOLLOW_PARENHASH_in_simpleTerm7553_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HASHPAREN_in_simpleTerm7555  */
static	ANTLR3_BITWORD FOLLOW_HASHPAREN_in_simpleTerm7555_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HASHPAREN_in_simpleTerm7555	= { FOLLOW_HASHPAREN_in_simpleTerm7555_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACE_in_simpleTerm7573  */
static	ANTLR3_BITWORD FOLLOW_LBRACE_in_simpleTerm7573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACE_in_simpleTerm7573	= { FOLLOW_LBRACE_in_simpleTerm7573_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACE_in_simpleTerm7575  */
static	ANTLR3_BITWORD FOLLOW_RBRACE_in_simpleTerm7575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACE_in_simpleTerm7575	= { FOLLOW_RBRACE_in_simpleTerm7575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNIVSET_TOK_in_simpleTerm7587  */
static	ANTLR3_BITWORD FOLLOW_UNIVSET_TOK_in_simpleTerm7587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNIVSET_TOK_in_simpleTerm7587	= { FOLLOW_UNIVSET_TOK_in_simpleTerm7587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACE_in_simpleTerm7606  */
static	ANTLR3_BITWORD FOLLOW_LBRACE_in_simpleTerm7606_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACE_in_simpleTerm7606	= { FOLLOW_LBRACE_in_simpleTerm7606_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_simpleTerm7608  */
static	ANTLR3_BITWORD FOLLOW_formula_in_simpleTerm7608_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_simpleTerm7608	= { FOLLOW_formula_in_simpleTerm7608_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_simpleTerm7619  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_simpleTerm7619_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_simpleTerm7619	= { FOLLOW_COMMA_in_simpleTerm7619_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_simpleTerm7621  */
static	ANTLR3_BITWORD FOLLOW_formula_in_simpleTerm7621_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_simpleTerm7621	= { FOLLOW_formula_in_simpleTerm7621_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACE_in_simpleTerm7629  */
static	ANTLR3_BITWORD FOLLOW_RBRACE_in_simpleTerm7629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACE_in_simpleTerm7629	= { FOLLOW_RBRACE_in_simpleTerm7629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BAR_in_simpleTerm7648  */
static	ANTLR3_BITWORD FOLLOW_BAR_in_simpleTerm7648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_BAR_in_simpleTerm7648	= { FOLLOW_BAR_in_simpleTerm7648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BAR_in_simpleTerm7650  */
static	ANTLR3_BITWORD FOLLOW_BAR_in_simpleTerm7650_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_BAR_in_simpleTerm7650	= { FOLLOW_BAR_in_simpleTerm7650_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_simpleTerm7652  */
static	ANTLR3_BITWORD FOLLOW_formula_in_simpleTerm7652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_simpleTerm7652	= { FOLLOW_formula_in_simpleTerm7652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BAR_in_simpleTerm7657  */
static	ANTLR3_BITWORD FOLLOW_BAR_in_simpleTerm7657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_BAR_in_simpleTerm7657	= { FOLLOW_BAR_in_simpleTerm7657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BAR_in_simpleTerm7659  */
static	ANTLR3_BITWORD FOLLOW_BAR_in_simpleTerm7659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BAR_in_simpleTerm7659	= { FOLLOW_BAR_in_simpleTerm7659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARRAY_TOK_in_simpleTerm7678  */
static	ANTLR3_BITWORD FOLLOW_ARRAY_TOK_in_simpleTerm7678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ARRAY_TOK_in_simpleTerm7678	= { FOLLOW_ARRAY_TOK_in_simpleTerm7678_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_simpleTerm7682  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_simpleTerm7682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_simpleTerm7682	= { FOLLOW_LPAREN_in_simpleTerm7682_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_simpleTerm7688  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_simpleTerm7688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_simpleTerm7688	= { FOLLOW_restrictedType_in_simpleTerm7688_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OF_TOK_in_simpleTerm7691  */
static	ANTLR3_BITWORD FOLLOW_OF_TOK_in_simpleTerm7691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0441020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_OF_TOK_in_simpleTerm7691	= { FOLLOW_OF_TOK_in_simpleTerm7691_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_restrictedType_in_simpleTerm7693  */
static	ANTLR3_BITWORD FOLLOW_restrictedType_in_simpleTerm7693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_restrictedType_in_simpleTerm7693	= { FOLLOW_restrictedType_in_simpleTerm7693_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_simpleTerm7700  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_simpleTerm7700_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_simpleTerm7700	= { FOLLOW_RPAREN_in_simpleTerm7700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_simpleTerm7702  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_simpleTerm7702_bits[]	= { ANTLR3_UINT64_LIT(0x400000000000C100), ANTLR3_UINT64_LIT(0x04208B0002000000), ANTLR3_UINT64_LIT(0x0440000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_simpleTerm7702	= { FOLLOW_COLON_in_simpleTerm7702_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleTerm_in_simpleTerm7704  */
static	ANTLR3_BITWORD FOLLOW_simpleTerm_in_simpleTerm7704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleTerm_in_simpleTerm7704	= { FOLLOW_simpleTerm_in_simpleTerm7704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_TOK_in_simpleTerm7724  */
static	ANTLR3_BITWORD FOLLOW_TRUE_TOK_in_simpleTerm7724_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_TOK_in_simpleTerm7724	= { FOLLOW_TRUE_TOK_in_simpleTerm7724_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_TOK_in_simpleTerm7733  */
static	ANTLR3_BITWORD FOLLOW_FALSE_TOK_in_simpleTerm7733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_TOK_in_simpleTerm7733	= { FOLLOW_FALSE_TOK_in_simpleTerm7733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_simpleTerm7753  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_simpleTerm7753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_simpleTerm7753	= { FOLLOW_DECIMAL_LITERAL_in_simpleTerm7753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_simpleTerm7761  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_simpleTerm7761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_simpleTerm7761	= { FOLLOW_INTEGER_LITERAL_in_simpleTerm7761_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_simpleTerm7775  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_simpleTerm7775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_simpleTerm7775	= { FOLLOW_HEX_LITERAL_in_simpleTerm7775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINARY_LITERAL_in_simpleTerm7787  */
static	ANTLR3_BITWORD FOLLOW_BINARY_LITERAL_in_simpleTerm7787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BINARY_LITERAL_in_simpleTerm7787	= { FOLLOW_BINARY_LITERAL_in_simpleTerm7787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARENHASH_in_simpleTerm7805  */
static	ANTLR3_BITWORD FOLLOW_PARENHASH_in_simpleTerm7805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PARENHASH_in_simpleTerm7805	= { FOLLOW_PARENHASH_in_simpleTerm7805_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_recordEntry_in_simpleTerm7807  */
static	ANTLR3_BITWORD FOLLOW_recordEntry_in_simpleTerm7807_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_recordEntry_in_simpleTerm7807	= { FOLLOW_recordEntry_in_simpleTerm7807_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_simpleTerm7818  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_simpleTerm7818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_simpleTerm7818	= { FOLLOW_COMMA_in_simpleTerm7818_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_recordEntry_in_simpleTerm7820  */
static	ANTLR3_BITWORD FOLLOW_recordEntry_in_simpleTerm7820_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_recordEntry_in_simpleTerm7820	= { FOLLOW_recordEntry_in_simpleTerm7820_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HASHPAREN_in_simpleTerm7828  */
static	ANTLR3_BITWORD FOLLOW_HASHPAREN_in_simpleTerm7828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HASHPAREN_in_simpleTerm7828	= { FOLLOW_HASHPAREN_in_simpleTerm7828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_simpleTerm7847  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_simpleTerm7847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_simpleTerm7847	= { FOLLOW_identifier_in_simpleTerm7847_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_typeAscription7887  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_typeAscription7887_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_typeAscription7887	= { FOLLOW_COLON_in_typeAscription7887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_typeAscription7889  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_typeAscription7889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_typeAscription7889	= { FOLLOW_COLON_in_typeAscription7889_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_typeAscription7891  */
static	ANTLR3_BITWORD FOLLOW_type_in_typeAscription7891_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_typeAscription7891	= { FOLLOW_type_in_typeAscription7891_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_recordEntry7908  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_recordEntry7908_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_recordEntry7908	= { FOLLOW_identifier_in_recordEntry7908_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_TOK_in_recordEntry7911  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_TOK_in_recordEntry7911_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_TOK_in_recordEntry7911	= { FOLLOW_ASSIGN_TOK_in_recordEntry7911_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_recordEntry7913  */
static	ANTLR3_BITWORD FOLLOW_formula_in_recordEntry7913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_recordEntry7913	= { FOLLOW_formula_in_recordEntry7913_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_TOK_in_iteTerm7935  */
static	ANTLR3_BITWORD FOLLOW_IF_TOK_in_iteTerm7935_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_TOK_in_iteTerm7935	= { FOLLOW_IF_TOK_in_iteTerm7935_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_iteTerm7937  */
static	ANTLR3_BITWORD FOLLOW_formula_in_iteTerm7937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_iteTerm7937	= { FOLLOW_formula_in_iteTerm7937_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THEN_TOK_in_iteTerm7946  */
static	ANTLR3_BITWORD FOLLOW_THEN_TOK_in_iteTerm7946_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_THEN_TOK_in_iteTerm7946	= { FOLLOW_THEN_TOK_in_iteTerm7946_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_iteTerm7948  */
static	ANTLR3_BITWORD FOLLOW_formula_in_iteTerm7948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000030000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_iteTerm7948	= { FOLLOW_formula_in_iteTerm7948_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_iteElseTerm_in_iteTerm7957  */
static	ANTLR3_BITWORD FOLLOW_iteElseTerm_in_iteTerm7957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_iteElseTerm_in_iteTerm7957	= { FOLLOW_iteElseTerm_in_iteTerm7957_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENDIF_TOK_in_iteTerm7966  */
static	ANTLR3_BITWORD FOLLOW_ENDIF_TOK_in_iteTerm7966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ENDIF_TOK_in_iteTerm7966	= { FOLLOW_ENDIF_TOK_in_iteTerm7966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELSE_TOK_in_iteElseTerm7993  */
static	ANTLR3_BITWORD FOLLOW_ELSE_TOK_in_iteElseTerm7993_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ELSE_TOK_in_iteElseTerm7993	= { FOLLOW_ELSE_TOK_in_iteElseTerm7993_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_iteElseTerm7995  */
static	ANTLR3_BITWORD FOLLOW_formula_in_iteElseTerm7995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_iteElseTerm7995	= { FOLLOW_formula_in_iteElseTerm7995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELSEIF_TOK_in_iteElseTerm8002  */
static	ANTLR3_BITWORD FOLLOW_ELSEIF_TOK_in_iteElseTerm8002_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ELSEIF_TOK_in_iteElseTerm8002	= { FOLLOW_ELSEIF_TOK_in_iteElseTerm8002_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_iteElseTerm8008  */
static	ANTLR3_BITWORD FOLLOW_formula_in_iteElseTerm8008_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_iteElseTerm8008	= { FOLLOW_formula_in_iteElseTerm8008_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THEN_TOK_in_iteElseTerm8017  */
static	ANTLR3_BITWORD FOLLOW_THEN_TOK_in_iteElseTerm8017_bits[]	= { ANTLR3_UINT64_LIT(0x4001FFFFFFF8C110), ANTLR3_UINT64_LIT(0xA6348B0016400006), ANTLR3_UINT64_LIT(0x04E937FFC2000010) };
static  ANTLR3_BITSET_LIST FOLLOW_THEN_TOK_in_iteElseTerm8017	= { FOLLOW_THEN_TOK_in_iteElseTerm8017_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formula_in_iteElseTerm8023  */
static	ANTLR3_BITWORD FOLLOW_formula_in_iteElseTerm8023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000030000) };
static  ANTLR3_BITSET_LIST FOLLOW_formula_in_iteElseTerm8023	= { FOLLOW_formula_in_iteElseTerm8023_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_iteElseTerm_in_iteElseTerm8036  */
static	ANTLR3_BITWORD FOLLOW_iteElseTerm_in_iteElseTerm8036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_iteElseTerm_in_iteElseTerm8036	= { FOLLOW_iteElseTerm_in_iteElseTerm8036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_datatypeDef8072  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_datatypeDef8072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0040000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_datatypeDef8072	= { FOLLOW_identifier_in_datatypeDef8072_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_datatypeDef8083  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_datatypeDef8083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_datatypeDef8083	= { FOLLOW_LBRACKET_in_datatypeDef8083_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_datatypeDef8085  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_datatypeDef8085_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_datatypeDef8085	= { FOLLOW_identifier_in_datatypeDef8085_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_datatypeDef8098  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_datatypeDef8098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_datatypeDef8098	= { FOLLOW_COMMA_in_datatypeDef8098_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_datatypeDef8100  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_datatypeDef8100_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_datatypeDef8100	= { FOLLOW_identifier_in_datatypeDef8100_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACKET_in_datatypeDef8114  */
static	ANTLR3_BITWORD FOLLOW_RBRACKET_in_datatypeDef8114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACKET_in_datatypeDef8114	= { FOLLOW_RBRACKET_in_datatypeDef8114_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_datatypeDef8133  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_datatypeDef8133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_datatypeDef8133	= { FOLLOW_EQUAL_TOK_in_datatypeDef8133_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorDef_in_datatypeDef8135  */
static	ANTLR3_BITWORD FOLLOW_constructorDef_in_datatypeDef8135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorDef_in_datatypeDef8135	= { FOLLOW_constructorDef_in_datatypeDef8135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BAR_in_datatypeDef8144  */
static	ANTLR3_BITWORD FOLLOW_BAR_in_datatypeDef8144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BAR_in_datatypeDef8144	= { FOLLOW_BAR_in_datatypeDef8144_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorDef_in_datatypeDef8146  */
static	ANTLR3_BITWORD FOLLOW_constructorDef_in_datatypeDef8146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorDef_in_datatypeDef8146	= { FOLLOW_constructorDef_in_datatypeDef8146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_constructorDef8177  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_constructorDef8177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_constructorDef8177	= { FOLLOW_identifier_in_constructorDef8177_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_constructorDef8192  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_constructorDef8192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_constructorDef8192	= { FOLLOW_LPAREN_in_constructorDef8192_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selector_in_constructorDef8200  */
static	ANTLR3_BITWORD FOLLOW_selector_in_constructorDef8200_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_selector_in_constructorDef8200	= { FOLLOW_selector_in_constructorDef8200_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_constructorDef8211  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_constructorDef8211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_constructorDef8211	= { FOLLOW_COMMA_in_constructorDef8211_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selector_in_constructorDef8213  */
static	ANTLR3_BITWORD FOLLOW_selector_in_constructorDef8213_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_selector_in_constructorDef8213	= { FOLLOW_selector_in_constructorDef8213_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_constructorDef8225  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_constructorDef8225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_constructorDef8225	= { FOLLOW_RPAREN_in_constructorDef8225_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_selector8257  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_selector8257_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_selector8257	= { FOLLOW_identifier_in_selector8257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_selector8260  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_selector8260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030100), ANTLR3_UINT64_LIT(0x0641020000000000), ANTLR3_UINT64_LIT(0x000088000C080000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_selector8260	= { FOLLOW_COLON_in_selector8260_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_selector8262  */
static	ANTLR3_BITWORD FOLLOW_type_in_selector8262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_selector8262	= { FOLLOW_type_in_selector8262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_numeral8337  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_numeral8337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_numeral8337	= { FOLLOW_INTEGER_LITERAL_in_numeral8337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_integer8362  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_integer8362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_integer8362	= { FOLLOW_INTEGER_LITERAL_in_integer8362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_TOK_in_integer8374  */
static	ANTLR3_BITWORD FOLLOW_MINUS_TOK_in_integer8374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_TOK_in_integer8374	= { FOLLOW_MINUS_TOK_in_integer8374_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_integer8376  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_integer8376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_integer8376	= { FOLLOW_INTEGER_LITERAL_in_integer8376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_str8398  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_str8398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_str8398	= { FOLLOW_STRING_LITERAL_in_str8398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_letDecl_in_synpred1_Cvc1998  */
static	ANTLR3_BITWORD FOLLOW_letDecl_in_synpred1_Cvc1998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_letDecl_in_synpred1_Cvc1998	= { FOLLOW_letDecl_in_synpred1_Cvc1998_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parseExpr
 * ../../../../../../src/parser/cvc/Cvc.g:646:1: parseExpr returns [CVC4::Expr expr = CVC4::Expr()] : ( formula[expr] | EOF );
 */
static CVC4::Expr
parseExpr(pCvcParser ctx)
{
    CVC4::Expr expr;


    /* Initialize rule variables
     */
    expr =  CVC4::Expr();


    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:647:3: ( formula[expr] | EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case ABS_TOK:
            case ARRAY_TOK:
            case BAR:
            case BINARY_LITERAL:
            case BVASHR_TOK:
            case BVCOMP_TOK:
            case BVGE_TOK:
            case BVGT_TOK:
            case BVLE_TOK:
            case BVLSHR_TOK:
            case BVLT_TOK:
            case BVMULT_TOK:
            case BVNAND_TOK:
            case BVNEG_TOK:
            case BVNOR_TOK:
            case BVPLUS_TOK:
            case BVREPEAT_TOK:
            case BVROTL_TOK:
            case BVROTR_TOK:
            case BVSDIV_TOK:
            case BVSGE_TOK:
            case BVSGT_TOK:
            case BVSHL_TOK:
            case BVSLE_TOK:
            case BVSLT_TOK:
            case BVSMOD_TOK:
            case BVSREM_TOK:
            case BVSUB_TOK:
            case BVUDIV_TOK:
            case BVUMINUS_TOK:
            case BVUREM_TOK:
            case BVXNOR_TOK:
            case BVXOR_TOK:
            case BVZEROEXTEND_TOK:
            case DECIMAL_LITERAL:
            case DISTINCT_TOK:
            case DIVISIBLE_TOK:
            case EXISTS_TOK:
            case FALSE_TOK:
            case FLOOR_TOK:
            case FORALL_TOK:
            case HEX_LITERAL:
            case IDENTIFIER:
            case IF_TOK:
            case INTEGER_LITERAL:
            case IS_INTEGER_TOK:
            case LAMBDA:
            case LBRACE:
            case LET_TOK:
            case LPAREN:
            case MINUS_TOK:
            case NOT_TOK:
            case PARENHASH:
            case SETS_CARD_TOK:
            case STRING_CONCAT_TOK:
            case STRING_CONTAINS_TOK:
            case STRING_INDEXOF_TOK:
            case STRING_ITOS_TOK:
            case STRING_LENGTH_TOK:
            case STRING_LITERAL:
            case STRING_PREFIXOF_TOK:
            case STRING_REPLACE_TOK:
            case STRING_STOI_TOK:
            case STRING_STOU16_TOK:
            case STRING_STOU32_TOK:
            case STRING_SUBSTR_TOK:
            case STRING_SUFFIXOF_TOK:
            case STRING_U16TOS_TOK:
            case STRING_U32TOS_TOK:
            case SX_TOK:
            case TRANSCLOSURE_TOK:
            case TRANSPOSE_TOK:
            case TRUE_TOK:
            case TUPLE_TOK:
            case UNIVSET_TOK:
            	{
            		alt1=1;
            	}
                break;
            case EOF:
            	{
            		alt1=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return expr;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleparseExprEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:647:5: formula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_formula_in_parseExpr1800);
        	        formula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return expr;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:648:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseExpr1807);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return expr;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseExprEx; /* Prevent compiler warnings */
    ruleparseExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return expr;
}
/* $ANTLR end parseExpr */

/**
 * $ANTLR start parseCommand
 * ../../../../../../src/parser/cvc/Cvc.g:655:1: parseCommand returns [CVC4::Command* cmd_return = NULL] : (c= command[&cmd] | LPAREN IDENTIFIER | EOF );
 */
static CVC4::Command*
parseCommand(pCvcParser ctx)
{
    CVC4::Command* cmd_return;



        CVC4::PtrCloser<CVC4::Command> cmd;

    pANTLR3_COMMON_TOKEN    IDENTIFIER1;

    /* Initialize rule variables
     */
    cmd_return =  NULL;


    IDENTIFIER1       = NULL;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:662:3: (c= command[&cmd] | LPAREN IDENTIFIER | EOF )

            ANTLR3_UINT32 alt2;

            alt2=3;

            switch ( LA(1) )
            {
            case ARITH_VAR_ORDER_TOK:
            case ASSERTIONS_TOK:
            case ASSERT_TOK:
            case ASSUMPTIONS_TOK:
            case CALL_TOK:
            case CHECKSAT_TOK:
            case CHECK_TYPE_TOK:
            case CONTEXT_TOK:
            case CONTINUE_TOK:
            case COUNTEREXAMPLE_TOK:
            case COUNTERMODEL_TOK:
            case DATATYPE_TOK:
            case DBG_TOK:
            case DUMP_ASSUMPTIONS_TOK:
            case DUMP_CLOSURE_PROOF_TOK:
            case DUMP_CLOSURE_TOK:
            case DUMP_PROOF_TOK:
            case DUMP_SIG_TOK:
            case DUMP_TCC_ASSUMPTIONS_TOK:
            case DUMP_TCC_PROOF_TOK:
            case DUMP_TCC_TOK:
            case DUMP_UNSAT_CORE_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case FORGET_TOK:
            case GET_CHILD_TOK:
            case GET_OP_TOK:
            case GET_TYPE_TOK:
            case GET_VALUE_TOK:
            case HELP_TOK:
            case IDENTIFIER:
            case INCLUDE_TOK:
            case LET_TOK:
            case OPTION_TOK:
            case POPTO_SCOPE_TOK:
            case POPTO_TOK:
            case POP_SCOPE_TOK:
            case POP_TOK:
            case PRINT_TOK:
            case PRINT_TYPE_TOK:
            case PUSH_SCOPE_TOK:
            case PUSH_TOK:
            case QUERY_TOK:
            case RESET_TOK:
            case RESTART_TOK:
            case SEMICOLON:
            case SUBSTITUTE_TOK:
            case TRACE_TOK:
            case TRANSFORM_TOK:
            case UNTRACE_TOK:
            case WHERE_TOK:
            	{
            		alt2=1;
            	}
                break;
            case LPAREN:
            	{
            		alt2=2;
            	}
                break;
            case EOF:
            	{
            		alt2=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return cmd_return;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleparseCommandEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:662:5: c= command[&cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_command_in_parseCommand1838);
        	        command(ctx, &cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return cmd_return;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:663:5: LPAREN IDENTIFIER
        	    {
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_parseCommand1845);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return cmd_return;
        	        }


        	        IDENTIFIER1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_parseCommand1847);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return cmd_return;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             std::string s = AntlrInput::tokenText(IDENTIFIER1);
        	                if(s == "benchmark") {
        	                    PARSER_STATE->parseError(
        	                        "In CVC4 presentation language mode, but SMT-LIBv1 format "
        	                        "detected.  Use --lang smt1 for SMT-LIBv1 support.");
        	                  } else if(s == "set" || s == "get" || s == "declare" ||
        	                            s == "define" || s == "assert") {
        	                    PARSER_STATE->parseError(
        	                        "In CVC4 presentation language mode, but SMT-LIB format detected. "
        	                        "Use --lang smt for SMT-LIB support.");
        	                  } else {
        	                    PARSER_STATE->parseError(
        	                        "A CVC4 presentation language command cannot begin with a "
        	                        "parenthesis; expected command name.");
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:680:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseCommand1859);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return cmd_return;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseCommandEx; /* Prevent compiler warnings */
    ruleparseCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                        cmd_return = cmd.release();

                }
            }


    return cmd_return;
}
/* $ANTLR end parseCommand */

/**
 * $ANTLR start command
 * ../../../../../../src/parser/cvc/Cvc.g:687:1: command[CVC4::PtrCloser<CVC4::Command>* cmd] : ( ( mainCommand[cmd] SEMICOLON | SEMICOLON | LET_TOK typeOrVarLetDecl[CHECK_DECLARED] ( COMMA typeOrVarLetDecl[CHECK_DECLARED] )* IN_TOK command[cmd] ) | IDENTIFIER SEMICOLON );
 */
static void
command(pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{
    pANTLR3_COMMON_TOKEN    IDENTIFIER2;

    /* Initialize rule variables
     */

    IDENTIFIER2       = NULL;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:688:3: ( ( mainCommand[cmd] SEMICOLON | SEMICOLON | LET_TOK typeOrVarLetDecl[CHECK_DECLARED] ( COMMA typeOrVarLetDecl[CHECK_DECLARED] )* IN_TOK command[cmd] ) | IDENTIFIER SEMICOLON )

            ANTLR3_UINT32 alt5;

            alt5=2;

            switch ( LA(1) )
            {
            case ARITH_VAR_ORDER_TOK:
            case ASSERTIONS_TOK:
            case ASSERT_TOK:
            case ASSUMPTIONS_TOK:
            case CALL_TOK:
            case CHECKSAT_TOK:
            case CHECK_TYPE_TOK:
            case CONTEXT_TOK:
            case CONTINUE_TOK:
            case COUNTEREXAMPLE_TOK:
            case COUNTERMODEL_TOK:
            case DATATYPE_TOK:
            case DBG_TOK:
            case DUMP_ASSUMPTIONS_TOK:
            case DUMP_CLOSURE_PROOF_TOK:
            case DUMP_CLOSURE_TOK:
            case DUMP_PROOF_TOK:
            case DUMP_SIG_TOK:
            case DUMP_TCC_ASSUMPTIONS_TOK:
            case DUMP_TCC_PROOF_TOK:
            case DUMP_TCC_TOK:
            case DUMP_UNSAT_CORE_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case FORGET_TOK:
            case GET_CHILD_TOK:
            case GET_OP_TOK:
            case GET_TYPE_TOK:
            case GET_VALUE_TOK:
            case HELP_TOK:
            case INCLUDE_TOK:
            case LET_TOK:
            case OPTION_TOK:
            case POPTO_SCOPE_TOK:
            case POPTO_TOK:
            case POP_SCOPE_TOK:
            case POP_TOK:
            case PRINT_TOK:
            case PRINT_TYPE_TOK:
            case PUSH_SCOPE_TOK:
            case PUSH_TOK:
            case QUERY_TOK:
            case RESET_TOK:
            case RESTART_TOK:
            case SEMICOLON:
            case SUBSTITUTE_TOK:
            case TRACE_TOK:
            case TRANSFORM_TOK:
            case UNTRACE_TOK:
            case WHERE_TOK:
            	{
            		alt5=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		switch ( LA(2) )
            		{
            		case SEMICOLON:
            			{
            				alt5=2;
            			}
            		    break;
            		case COLON:
            		case COMMA:
            			{
            				alt5=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 5;
            		    EXCEPTION->state        = 41;


            		    goto rulecommandEx;

            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulecommandEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:688:5: ( mainCommand[cmd] SEMICOLON | SEMICOLON | LET_TOK typeOrVarLetDecl[CHECK_DECLARED] ( COMMA typeOrVarLetDecl[CHECK_DECLARED] )* IN_TOK command[cmd] )
        	    {
        	        // ../../../../../../src/parser/cvc/Cvc.g:688:5: ( mainCommand[cmd] SEMICOLON | SEMICOLON | LET_TOK typeOrVarLetDecl[CHECK_DECLARED] ( COMMA typeOrVarLetDecl[CHECK_DECLARED] )* IN_TOK command[cmd] )
        	        {
        	            int alt4=3;
        	            switch ( LA(1) )
        	            {
        	            case ARITH_VAR_ORDER_TOK:
        	            case ASSERTIONS_TOK:
        	            case ASSERT_TOK:
        	            case ASSUMPTIONS_TOK:
        	            case CALL_TOK:
        	            case CHECKSAT_TOK:
        	            case CHECK_TYPE_TOK:
        	            case CONTEXT_TOK:
        	            case CONTINUE_TOK:
        	            case COUNTEREXAMPLE_TOK:
        	            case COUNTERMODEL_TOK:
        	            case DATATYPE_TOK:
        	            case DBG_TOK:
        	            case DUMP_ASSUMPTIONS_TOK:
        	            case DUMP_CLOSURE_PROOF_TOK:
        	            case DUMP_CLOSURE_TOK:
        	            case DUMP_PROOF_TOK:
        	            case DUMP_SIG_TOK:
        	            case DUMP_TCC_ASSUMPTIONS_TOK:
        	            case DUMP_TCC_PROOF_TOK:
        	            case DUMP_TCC_TOK:
        	            case DUMP_UNSAT_CORE_TOK:
        	            case ECHO_TOK:
        	            case EXIT_TOK:
        	            case FORGET_TOK:
        	            case GET_CHILD_TOK:
        	            case GET_OP_TOK:
        	            case GET_TYPE_TOK:
        	            case GET_VALUE_TOK:
        	            case HELP_TOK:
        	            case IDENTIFIER:
        	            case INCLUDE_TOK:
        	            case OPTION_TOK:
        	            case POPTO_SCOPE_TOK:
        	            case POPTO_TOK:
        	            case POP_SCOPE_TOK:
        	            case POP_TOK:
        	            case PRINT_TOK:
        	            case PRINT_TYPE_TOK:
        	            case PUSH_SCOPE_TOK:
        	            case PUSH_TOK:
        	            case QUERY_TOK:
        	            case RESET_TOK:
        	            case RESTART_TOK:
        	            case SUBSTITUTE_TOK:
        	            case TRACE_TOK:
        	            case TRANSFORM_TOK:
        	            case UNTRACE_TOK:
        	            case WHERE_TOK:
        	            	{
        	            		alt4=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt4=2;
        	            	}
        	                break;
        	            case LET_TOK:
        	            	{
        	            		alt4=3;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 4;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:688:7: mainCommand[cmd] SEMICOLON
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_mainCommand_in_command1878);
        	        	        mainCommand(ctx, cmd);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_command1881);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:689:7: SEMICOLON
        	        	    {
        	        	         MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_command1889);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:690:7: LET_TOK typeOrVarLetDecl[CHECK_DECLARED] ( COMMA typeOrVarLetDecl[CHECK_DECLARED] )* IN_TOK command[cmd]
        	        	    {
        	        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_command1897);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             PARSER_STATE->pushScope(); 
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_typeOrVarLetDecl_in_command1907);
        	        	        typeOrVarLetDecl(ctx, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // ../../../../../../src/parser/cvc/Cvc.g:691:40: ( COMMA typeOrVarLetDecl[CHECK_DECLARED] )*

        	        	        for (;;)
        	        	        {
        	        	            int alt3=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case COMMA:
        	        	            	{
        	        	            		alt3=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt3)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:692:11: COMMA typeOrVarLetDecl[CHECK_DECLARED]
        	        	        	    {
        	        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_command1922);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulecommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_typeOrVarLetDecl_in_command1924);
        	        	        	        typeOrVarLetDecl(ctx, CHECK_DECLARED);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulecommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop3;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop3: ; /* Jump out to here if this rule does not match */


        	        	         MATCHT(IN_TOK, &FOLLOW_IN_TOK_in_command1936);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_command_in_command1938);
        	        	        command(ctx, cmd);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             PARSER_STATE->popScope(); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             if(!(*cmd)) {
        	                    cmd->reset(new EmptyCommand());
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:700:5: IDENTIFIER SEMICOLON
        	    {
        	        IDENTIFIER2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_command1965);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_command1967);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             std::stringstream ss;
        	                  ss << "Unrecognized command `"
        	                     << AntlrInput::tokenText(IDENTIFIER2)
        	                     << "'";
        	                  PARSER_STATE->parseError(ss.str());
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecommandEx; /* Prevent compiler warnings */
    rulecommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end command */

/**
 * $ANTLR start typeOrVarLetDecl
 * ../../../../../../src/parser/cvc/Cvc.g:709:1: typeOrVarLetDecl[CVC4::parser::DeclarationCheck check] options {backtrack=true; } : ( letDecl | typeLetDecl[check] );
 */
static void
typeOrVarLetDecl(pCvcParser ctx, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:711:3: ( letDecl | typeLetDecl[check] )

            ANTLR3_UINT32 alt6;

            alt6=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		switch ( LA(2) )
            		{
            		case EQUAL_TOK:
            			{
            				switch ( LA(3) )
            				{
            				case ABS_TOK:
            				case BAR:
            				case BINARY_LITERAL:
            				case BVASHR_TOK:
            				case BVCOMP_TOK:
            				case BVGE_TOK:
            				case BVGT_TOK:
            				case BVLE_TOK:
            				case BVLSHR_TOK:
            				case BVLT_TOK:
            				case BVMULT_TOK:
            				case BVNAND_TOK:
            				case BVNEG_TOK:
            				case BVNOR_TOK:
            				case BVPLUS_TOK:
            				case BVREPEAT_TOK:
            				case BVROTL_TOK:
            				case BVROTR_TOK:
            				case BVSDIV_TOK:
            				case BVSGE_TOK:
            				case BVSGT_TOK:
            				case BVSHL_TOK:
            				case BVSLE_TOK:
            				case BVSLT_TOK:
            				case BVSMOD_TOK:
            				case BVSREM_TOK:
            				case BVSUB_TOK:
            				case BVUDIV_TOK:
            				case BVUMINUS_TOK:
            				case BVUREM_TOK:
            				case BVXNOR_TOK:
            				case BVXOR_TOK:
            				case BVZEROEXTEND_TOK:
            				case DECIMAL_LITERAL:
            				case DISTINCT_TOK:
            				case DIVISIBLE_TOK:
            				case EXISTS_TOK:
            				case FALSE_TOK:
            				case FLOOR_TOK:
            				case FORALL_TOK:
            				case HEX_LITERAL:
            				case IF_TOK:
            				case INTEGER_LITERAL:
            				case IS_INTEGER_TOK:
            				case LAMBDA:
            				case LBRACE:
            				case LET_TOK:
            				case MINUS_TOK:
            				case NOT_TOK:
            				case PARENHASH:
            				case SETS_CARD_TOK:
            				case STRING_CONCAT_TOK:
            				case STRING_CONTAINS_TOK:
            				case STRING_INDEXOF_TOK:
            				case STRING_ITOS_TOK:
            				case STRING_LENGTH_TOK:
            				case STRING_LITERAL:
            				case STRING_PREFIXOF_TOK:
            				case STRING_REPLACE_TOK:
            				case STRING_STOI_TOK:
            				case STRING_STOU16_TOK:
            				case STRING_STOU32_TOK:
            				case STRING_SUBSTR_TOK:
            				case STRING_SUFFIXOF_TOK:
            				case STRING_U16TOS_TOK:
            				case STRING_U32TOS_TOK:
            				case SX_TOK:
            				case TRANSCLOSURE_TOK:
            				case TRANSPOSE_TOK:
            				case TRUE_TOK:
            				case TUPLE_TOK:
            				case UNIVSET_TOK:
            					{
            						alt6=1;
            					}
            				    break;
            				case LPAREN:
            					{
            						{
            						    int LA6_61 = LA(4);
            						    if ( (synpred1_Cvc(ctx)))
            						    {
            						        alt6=1;
            						    }
            						    else if ( (ANTLR3_TRUE))
            						    {
            						        alt6=2;
            						    }
            						    else
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return ;
            						        }


            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 6;
            						        EXCEPTION->state        = 61;


            						        goto ruletypeOrVarLetDeclEx;

            						    }
            						}
            					}
            				    break;
            				case ARRAY_TOK:
            					{
            						{
            						    int LA6_66 = LA(4);
            						    if ( (synpred1_Cvc(ctx)))
            						    {
            						        alt6=1;
            						    }
            						    else if ( (ANTLR3_TRUE))
            						    {
            						        alt6=2;
            						    }
            						    else
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return ;
            						        }


            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 6;
            						        EXCEPTION->state        = 66;


            						        goto ruletypeOrVarLetDeclEx;

            						    }
            						}
            					}
            				    break;
            				case IDENTIFIER:
            					{
            						{
            						    int LA6_73 = LA(4);
            						    if ( (synpred1_Cvc(ctx)))
            						    {
            						        alt6=1;
            						    }
            						    else if ( (ANTLR3_TRUE))
            						    {
            						        alt6=2;
            						    }
            						    else
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return ;
            						        }


            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 6;
            						        EXCEPTION->state        = 73;


            						        goto ruletypeOrVarLetDeclEx;

            						    }
            						}
            					}
            				    break;
            				case BITVECTOR_TOK:
            				case BOOLEAN_TOK:
            				case INT_TOK:
            				case LBRACKET:
            				case REAL_TOK:
            				case SET_TOK:
            				case SQHASH:
            				case STRING_TOK:
            				case SUBTYPE_TOK:
            					{
            						alt6=2;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }

            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 6;
            				    EXCEPTION->state        = 2;


            				    goto ruletypeOrVarLetDeclEx;

            				}

            			}
            		    break;
            		case COLON:
            			{
            				alt6=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 6;
            		    EXCEPTION->state        = 1;


            		    goto ruletypeOrVarLetDeclEx;

            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto ruletypeOrVarLetDeclEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:711:5: letDecl
        	    {
        	        FOLLOWPUSH(FOLLOW_letDecl_in_typeOrVarLetDecl1998);
        	        letDecl(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeOrVarLetDeclEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:711:15: typeLetDecl[check]
        	    {
        	        FOLLOWPUSH(FOLLOW_typeLetDecl_in_typeOrVarLetDecl2002);
        	        typeLetDecl(ctx, check);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeOrVarLetDeclEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletypeOrVarLetDeclEx; /* Prevent compiler warnings */
    ruletypeOrVarLetDeclEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end typeOrVarLetDecl */

/**
 * $ANTLR start mainCommand
 * ../../../../../../src/parser/cvc/Cvc.g:714:1: mainCommand[CVC4::PtrCloser<CVC4::Command>* cmd] : ( ASSERT_TOK formula[f] | QUERY_TOK formula[f] | CHECKSAT_TOK ( formula[f] )? | OPTION_TOK ( str[s] | IDENTIFIER ) ( symbolicExpr[sexpr] | TRUE_TOK | FALSE_TOK |) | PUSH_TOK (k= numeral |) | POP_TOK (k= numeral |) | POPTO_TOK (k= numeral )? | PUSH_SCOPE_TOK (k= numeral )? | POP_SCOPE_TOK (k= numeral )? | POPTO_SCOPE_TOK (k= numeral )? | RESET_TOK | RESET_TOK ASSERTIONS_TOK | DATATYPE_TOK datatypeDef[dts] ( COMMA datatypeDef[dts] )* END_TOK | CONTEXT_TOK ( ( str[s] | IDENTIFIER ) |) | FORGET_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] | GET_TYPE_TOK formula[f] | CHECK_TYPE_TOK formula[f] COLON type[t,CHECK_DECLARED] | GET_CHILD_TOK formula[f] k= numeral | GET_OP_TOK formula[f] | GET_VALUE_TOK formula[f] | SUBSTITUTE_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] COLON type[t,CHECK_DECLARED] EQUAL_TOK formula[f] LBRACKET identifier[id,CHECK_NONE,SYM_VARIABLE] ASSIGN_TOK formula[f] RBRACKET | DBG_TOK ( ( str[s] | IDENTIFIER ) |) | TRACE_TOK ( ( str[s] | IDENTIFIER ) |) | UNTRACE_TOK ( ( str[s] | IDENTIFIER ) |) | HELP_TOK ( ( str[s] | IDENTIFIER ) |) | TRANSFORM_TOK formula[f] | PRINT_TOK formula[f] | PRINT_TYPE_TOK type[t,CHECK_DECLARED] | CALL_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] formula[f] | ECHO_TOK ( simpleSymbolicExpr[sexpr] |) | EXIT_TOK | INCLUDE_TOK ( ( str[s] | IDENTIFIER ) |) | DUMP_PROOF_TOK | DUMP_UNSAT_CORE_TOK | ( DUMP_ASSUMPTIONS_TOK | DUMP_SIG_TOK | DUMP_TCC_TOK | DUMP_TCC_ASSUMPTIONS_TOK | DUMP_TCC_PROOF_TOK | DUMP_CLOSURE_TOK | DUMP_CLOSURE_PROOF_TOK ) | ( WHERE_TOK | ASSERTIONS_TOK | ASSUMPTIONS_TOK ) | COUNTEREXAMPLE_TOK | COUNTERMODEL_TOK | ARITH_VAR_ORDER_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN | CONTINUE_TOK | RESTART_TOK formula[f] | toplevelDeclaration[cmd] );
 */
static void
mainCommand(pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{
    pANTLR3_COMMON_TOKEN    IDENTIFIER3;
    pANTLR3_COMMON_TOKEN    IDENTIFIER4;
    pANTLR3_COMMON_TOKEN    IDENTIFIER5;
    pANTLR3_COMMON_TOKEN    IDENTIFIER6;
    pANTLR3_COMMON_TOKEN    IDENTIFIER7;
    pANTLR3_COMMON_TOKEN    IDENTIFIER8;
    pANTLR3_COMMON_TOKEN    IDENTIFIER9;
    unsigned k;
    #undef	RETURN_TYPE_k
    #define	RETURN_TYPE_k unsigned

    /* Initialize rule variables
     */


      Expr f;
      SExpr sexpr;
      std::string id;
      Type t;
      std::vector<CVC4::Datatype> dts;
      Debug("parser-extra") << "command: " << AntlrInput::tokenText(LT(1)) << std::endl;
      std::string s;

    IDENTIFIER3       = NULL;
    IDENTIFIER4       = NULL;
    IDENTIFIER5       = NULL;
    IDENTIFIER6       = NULL;
    IDENTIFIER7       = NULL;
    IDENTIFIER8       = NULL;
    IDENTIFIER9       = NULL;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:725:3: ( ASSERT_TOK formula[f] | QUERY_TOK formula[f] | CHECKSAT_TOK ( formula[f] )? | OPTION_TOK ( str[s] | IDENTIFIER ) ( symbolicExpr[sexpr] | TRUE_TOK | FALSE_TOK |) | PUSH_TOK (k= numeral |) | POP_TOK (k= numeral |) | POPTO_TOK (k= numeral )? | PUSH_SCOPE_TOK (k= numeral )? | POP_SCOPE_TOK (k= numeral )? | POPTO_SCOPE_TOK (k= numeral )? | RESET_TOK | RESET_TOK ASSERTIONS_TOK | DATATYPE_TOK datatypeDef[dts] ( COMMA datatypeDef[dts] )* END_TOK | CONTEXT_TOK ( ( str[s] | IDENTIFIER ) |) | FORGET_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] | GET_TYPE_TOK formula[f] | CHECK_TYPE_TOK formula[f] COLON type[t,CHECK_DECLARED] | GET_CHILD_TOK formula[f] k= numeral | GET_OP_TOK formula[f] | GET_VALUE_TOK formula[f] | SUBSTITUTE_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] COLON type[t,CHECK_DECLARED] EQUAL_TOK formula[f] LBRACKET identifier[id,CHECK_NONE,SYM_VARIABLE] ASSIGN_TOK formula[f] RBRACKET | DBG_TOK ( ( str[s] | IDENTIFIER ) |) | TRACE_TOK ( ( str[s] | IDENTIFIER ) |) | UNTRACE_TOK ( ( str[s] | IDENTIFIER ) |) | HELP_TOK ( ( str[s] | IDENTIFIER ) |) | TRANSFORM_TOK formula[f] | PRINT_TOK formula[f] | PRINT_TYPE_TOK type[t,CHECK_DECLARED] | CALL_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] formula[f] | ECHO_TOK ( simpleSymbolicExpr[sexpr] |) | EXIT_TOK | INCLUDE_TOK ( ( str[s] | IDENTIFIER ) |) | DUMP_PROOF_TOK | DUMP_UNSAT_CORE_TOK | ( DUMP_ASSUMPTIONS_TOK | DUMP_SIG_TOK | DUMP_TCC_TOK | DUMP_TCC_ASSUMPTIONS_TOK | DUMP_TCC_PROOF_TOK | DUMP_CLOSURE_TOK | DUMP_CLOSURE_PROOF_TOK ) | ( WHERE_TOK | ASSERTIONS_TOK | ASSUMPTIONS_TOK ) | COUNTEREXAMPLE_TOK | COUNTERMODEL_TOK | ARITH_VAR_ORDER_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN | CONTINUE_TOK | RESTART_TOK formula[f] | toplevelDeclaration[cmd] )

            ANTLR3_UINT32 alt31;

            alt31=42;

            switch ( LA(1) )
            {
            case ASSERT_TOK:
            	{
            		alt31=1;
            	}
                break;
            case QUERY_TOK:
            	{
            		alt31=2;
            	}
                break;
            case CHECKSAT_TOK:
            	{
            		alt31=3;
            	}
                break;
            case OPTION_TOK:
            	{
            		alt31=4;
            	}
                break;
            case PUSH_TOK:
            	{
            		alt31=5;
            	}
                break;
            case POP_TOK:
            	{
            		alt31=6;
            	}
                break;
            case POPTO_TOK:
            	{
            		alt31=7;
            	}
                break;
            case PUSH_SCOPE_TOK:
            	{
            		alt31=8;
            	}
                break;
            case POP_SCOPE_TOK:
            	{
            		alt31=9;
            	}
                break;
            case POPTO_SCOPE_TOK:
            	{
            		alt31=10;
            	}
                break;
            case RESET_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case ASSERTIONS_TOK:
            			{
            				alt31=12;
            			}
            		    break;
            		case SEMICOLON:
            			{
            				alt31=11;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 31;
            		    EXCEPTION->state        = 11;


            		    goto rulemainCommandEx;

            		}

            	}
                break;
            case DATATYPE_TOK:
            	{
            		alt31=13;
            	}
                break;
            case CONTEXT_TOK:
            	{
            		alt31=14;
            	}
                break;
            case FORGET_TOK:
            	{
            		alt31=15;
            	}
                break;
            case GET_TYPE_TOK:
            	{
            		alt31=16;
            	}
                break;
            case CHECK_TYPE_TOK:
            	{
            		alt31=17;
            	}
                break;
            case GET_CHILD_TOK:
            	{
            		alt31=18;
            	}
                break;
            case GET_OP_TOK:
            	{
            		alt31=19;
            	}
                break;
            case GET_VALUE_TOK:
            	{
            		alt31=20;
            	}
                break;
            case SUBSTITUTE_TOK:
            	{
            		alt31=21;
            	}
                break;
            case DBG_TOK:
            	{
            		alt31=22;
            	}
                break;
            case TRACE_TOK:
            	{
            		alt31=23;
            	}
                break;
            case UNTRACE_TOK:
            	{
            		alt31=24;
            	}
                break;
            case HELP_TOK:
            	{
            		alt31=25;
            	}
                break;
            case TRANSFORM_TOK:
            	{
            		alt31=26;
            	}
                break;
            case PRINT_TOK:
            	{
            		alt31=27;
            	}
                break;
            case PRINT_TYPE_TOK:
            	{
            		alt31=28;
            	}
                break;
            case CALL_TOK:
            	{
            		alt31=29;
            	}
                break;
            case ECHO_TOK:
            	{
            		alt31=30;
            	}
                break;
            case EXIT_TOK:
            	{
            		alt31=31;
            	}
                break;
            case INCLUDE_TOK:
            	{
            		alt31=32;
            	}
                break;
            case DUMP_PROOF_TOK:
            	{
            		alt31=33;
            	}
                break;
            case DUMP_UNSAT_CORE_TOK:
            	{
            		alt31=34;
            	}
                break;
            case DUMP_ASSUMPTIONS_TOK:
            case DUMP_CLOSURE_PROOF_TOK:
            case DUMP_CLOSURE_TOK:
            case DUMP_SIG_TOK:
            case DUMP_TCC_ASSUMPTIONS_TOK:
            case DUMP_TCC_PROOF_TOK:
            case DUMP_TCC_TOK:
            	{
            		alt31=35;
            	}
                break;
            case ASSERTIONS_TOK:
            case ASSUMPTIONS_TOK:
            case WHERE_TOK:
            	{
            		alt31=36;
            	}
                break;
            case COUNTEREXAMPLE_TOK:
            	{
            		alt31=37;
            	}
                break;
            case COUNTERMODEL_TOK:
            	{
            		alt31=38;
            	}
                break;
            case ARITH_VAR_ORDER_TOK:
            	{
            		alt31=39;
            	}
                break;
            case CONTINUE_TOK:
            	{
            		alt31=40;
            	}
                break;
            case RESTART_TOK:
            	{
            		alt31=41;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt31=42;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 31;
                EXCEPTION->state        = 0;


                goto rulemainCommandEx;

            }

            switch (alt31)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:725:5: ASSERT_TOK formula[f]
        	    {
        	         MATCHT(ASSERT_TOK, &FOLLOW_ASSERT_TOK_in_mainCommand2028);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2030);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new AssertCommand(f)); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:727:5: QUERY_TOK formula[f]
        	    {
        	         MATCHT(QUERY_TOK, &FOLLOW_QUERY_TOK_in_mainCommand2040);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2042);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new QueryCommand(f)); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:728:5: CHECKSAT_TOK ( formula[f] )?
        	    {
        	         MATCHT(CHECKSAT_TOK, &FOLLOW_CHECKSAT_TOK_in_mainCommand2051);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:728:18: ( formula[f] )?
        	        {
        	            int alt7=2;
        	            switch ( LA(1) )
        	            {
        	                case ABS_TOK:
        	                case ARRAY_TOK:
        	                case BAR:
        	                case BINARY_LITERAL:
        	                case BVASHR_TOK:
        	                case BVCOMP_TOK:
        	                case BVGE_TOK:
        	                case BVGT_TOK:
        	                case BVLE_TOK:
        	                case BVLSHR_TOK:
        	                case BVLT_TOK:
        	                case BVMULT_TOK:
        	                case BVNAND_TOK:
        	                case BVNEG_TOK:
        	                case BVNOR_TOK:
        	                case BVPLUS_TOK:
        	                case BVREPEAT_TOK:
        	                case BVROTL_TOK:
        	                case BVROTR_TOK:
        	                case BVSDIV_TOK:
        	                case BVSGE_TOK:
        	                case BVSGT_TOK:
        	                case BVSHL_TOK:
        	                case BVSLE_TOK:
        	                case BVSLT_TOK:
        	                case BVSMOD_TOK:
        	                case BVSREM_TOK:
        	                case BVSUB_TOK:
        	                case BVUDIV_TOK:
        	                case BVUMINUS_TOK:
        	                case BVUREM_TOK:
        	                case BVXNOR_TOK:
        	                case BVXOR_TOK:
        	                case BVZEROEXTEND_TOK:
        	                case DECIMAL_LITERAL:
        	                case DISTINCT_TOK:
        	                case DIVISIBLE_TOK:
        	                case EXISTS_TOK:
        	                case FALSE_TOK:
        	                case FLOOR_TOK:
        	                case FORALL_TOK:
        	                case HEX_LITERAL:
        	                case IDENTIFIER:
        	                case IF_TOK:
        	                case INTEGER_LITERAL:
        	                case IS_INTEGER_TOK:
        	                case LAMBDA:
        	                case LBRACE:
        	                case LET_TOK:
        	                case LPAREN:
        	                case MINUS_TOK:
        	                case NOT_TOK:
        	                case PARENHASH:
        	                case SETS_CARD_TOK:
        	                case STRING_CONCAT_TOK:
        	                case STRING_CONTAINS_TOK:
        	                case STRING_INDEXOF_TOK:
        	                case STRING_ITOS_TOK:
        	                case STRING_LENGTH_TOK:
        	                case STRING_LITERAL:
        	                case STRING_PREFIXOF_TOK:
        	                case STRING_REPLACE_TOK:
        	                case STRING_STOI_TOK:
        	                case STRING_STOU16_TOK:
        	                case STRING_STOU32_TOK:
        	                case STRING_SUBSTR_TOK:
        	                case STRING_SUFFIXOF_TOK:
        	                case STRING_U16TOS_TOK:
        	                case STRING_U32TOS_TOK:
        	                case SX_TOK:
        	                case TRANSCLOSURE_TOK:
        	                case TRANSPOSE_TOK:
        	                case TRUE_TOK:
        	                case TUPLE_TOK:
        	                case UNIVSET_TOK:
        	                	{
        	                		alt7=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt7)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:728:18: formula[f]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2053);
        	        	        formula(ctx, f);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(f.isNull() ? new CheckSatCommand() : new CheckSatCommand(f)); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/cvc/Cvc.g:731:5: OPTION_TOK ( str[s] | IDENTIFIER ) ( symbolicExpr[sexpr] | TRUE_TOK | FALSE_TOK |)
        	    {
        	         MATCHT(OPTION_TOK, &FOLLOW_OPTION_TOK_in_mainCommand2073);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:732:5: ( str[s] | IDENTIFIER )
        	        {
        	            int alt8=2;
        	            switch ( LA(1) )
        	            {
        	            case STRING_LITERAL:
        	            	{
        	            		alt8=1;
        	            	}
        	                break;
        	            case IDENTIFIER:
        	            	{
        	            		alt8=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 8;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:732:7: str[s]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_str_in_mainCommand2081);
        	        	        str(ctx, s);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:732:16: IDENTIFIER
        	        	    {
        	        	        IDENTIFIER3 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_mainCommand2086);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             s = AntlrInput::tokenText(IDENTIFIER3); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // ../../../../../../src/parser/cvc/Cvc.g:733:5: ( symbolicExpr[sexpr] | TRUE_TOK | FALSE_TOK |)
        	        {
        	            int alt9=4;
        	            switch ( LA(1) )
        	            {
        	            case BINARY_LITERAL:
        	            case DECIMAL_LITERAL:
        	            case HEX_LITERAL:
        	            case IDENTIFIER:
        	            case INTEGER_LITERAL:
        	            case LPAREN:
        	            case MINUS_TOK:
        	            case STRING_LITERAL:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;
        	            case TRUE_TOK:
        	            	{
        	            		alt9=2;
        	            	}
        	                break;
        	            case FALSE_TOK:
        	            	{
        	            		alt9=3;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt9=4;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 9;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:733:7: symbolicExpr[sexpr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_symbolicExpr_in_mainCommand2098);
        	        	        symbolicExpr(ctx, sexpr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             if(s == "logic") {
        	        	                      cmd->reset(new SetBenchmarkLogicCommand(sexpr.getValue()));
        	        	                    } else {
        	        	                      cmd->reset(new SetOptionCommand(s, sexpr));
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:740:7: TRUE_TOK
        	        	    {
        	        	         MATCHT(TRUE_TOK, &FOLLOW_TRUE_TOK_in_mainCommand2115);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(new SetOptionCommand(s, SExpr("true"))); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:741:7: FALSE_TOK
        	        	    {
        	        	         MATCHT(FALSE_TOK, &FOLLOW_FALSE_TOK_in_mainCommand2125);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(new SetOptionCommand(s, SExpr("false"))); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:742:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(new SetOptionCommand(s, SExpr("true"))); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/cvc/Cvc.g:746:5: PUSH_TOK (k= numeral |)
        	    {
        	         MATCHT(PUSH_TOK, &FOLLOW_PUSH_TOK_in_mainCommand2154);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:746:14: (k= numeral |)
        	        {
        	            int alt10=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt10=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt10=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 10;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:746:16: k= numeral
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_numeral_in_mainCommand2160);
        	        	        k=numeral(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(REPEAT_COMMAND(k, PushCommand())); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:747:18: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(new PushCommand()); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/cvc/Cvc.g:748:5: POP_TOK (k= numeral |)
        	    {
        	         MATCHT(POP_TOK, &FOLLOW_POP_TOK_in_mainCommand2189);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:748:13: (k= numeral |)
        	        {
        	            int alt11=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt11=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt11=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 11;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:748:15: k= numeral
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_numeral_in_mainCommand2195);
        	        	        k=numeral(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(REPEAT_COMMAND(k, PopCommand())); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:749:17: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(new PopCommand()); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/cvc/Cvc.g:750:5: POPTO_TOK (k= numeral )?
        	    {
        	         MATCHT(POPTO_TOK, &FOLLOW_POPTO_TOK_in_mainCommand2223);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:750:16: (k= numeral )?
        	        {
        	            int alt12=2;
        	            switch ( LA(1) )
        	            {
        	                case INTEGER_LITERAL:
        	                	{
        	                		alt12=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:750:16: k= numeral
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_numeral_in_mainCommand2227);
        	        	        k=numeral(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("POPTO command"); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/cvc/Cvc.g:754:5: PUSH_SCOPE_TOK (k= numeral )?
        	    {
        	         MATCHT(PUSH_SCOPE_TOK, &FOLLOW_PUSH_SCOPE_TOK_in_mainCommand2247);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:754:21: (k= numeral )?
        	        {
        	            int alt13=2;
        	            switch ( LA(1) )
        	            {
        	                case INTEGER_LITERAL:
        	                	{
        	                		alt13=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:754:21: k= numeral
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_numeral_in_mainCommand2251);
        	        	        k=numeral(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("PUSH_SCOPE command"); 
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/cvc/Cvc.g:756:5: POP_SCOPE_TOK (k= numeral )?
        	    {
        	         MATCHT(POP_SCOPE_TOK, &FOLLOW_POP_SCOPE_TOK_in_mainCommand2264);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:756:20: (k= numeral )?
        	        {
        	            int alt14=2;
        	            switch ( LA(1) )
        	            {
        	                case INTEGER_LITERAL:
        	                	{
        	                		alt14=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt14)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:756:20: k= numeral
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_numeral_in_mainCommand2268);
        	        	        k=numeral(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("POP_SCOPE command"); 
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/cvc/Cvc.g:758:5: POPTO_SCOPE_TOK (k= numeral )?
        	    {
        	         MATCHT(POPTO_SCOPE_TOK, &FOLLOW_POPTO_SCOPE_TOK_in_mainCommand2281);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:758:22: (k= numeral )?
        	        {
        	            int alt15=2;
        	            switch ( LA(1) )
        	            {
        	                case INTEGER_LITERAL:
        	                	{
        	                		alt15=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt15)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:758:22: k= numeral
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_numeral_in_mainCommand2285);
        	        	        k=numeral(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("POPTO_SCOPE command"); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/cvc/Cvc.g:761:5: RESET_TOK
        	    {
        	         MATCHT(RESET_TOK, &FOLLOW_RESET_TOK_in_mainCommand2299);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new ResetCommand());
        	                  PARSER_STATE->reset();
        	                
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/cvc/Cvc.g:766:5: RESET_TOK ASSERTIONS_TOK
        	    {
        	         MATCHT(RESET_TOK, &FOLLOW_RESET_TOK_in_mainCommand2312);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(ASSERTIONS_TOK, &FOLLOW_ASSERTIONS_TOK_in_mainCommand2314);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new ResetAssertionsCommand());
        	                  PARSER_STATE->reset();
        	                
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/cvc/Cvc.g:774:5: DATATYPE_TOK datatypeDef[dts] ( COMMA datatypeDef[dts] )* END_TOK
        	    {
        	         MATCHT(DATATYPE_TOK, &FOLLOW_DATATYPE_TOK_in_mainCommand2342);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             /* open a scope to keep the UnresolvedTypes contained */
        	                  PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_datatypeDef_in_mainCommand2354);
        	        datatypeDef(ctx, dts);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:778:5: ( COMMA datatypeDef[dts] )*

        	        for (;;)
        	        {
        	            int alt16=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt16=1;
        	            	}
        	                break;

        	            }

        	            switch (alt16)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:778:7: COMMA datatypeDef[dts]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_mainCommand2363);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_datatypeDef_in_mainCommand2365);
        	        	        datatypeDef(ctx, dts);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop16;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop16: ; /* Jump out to here if this rule does not match */


        	         MATCHT(END_TOK, &FOLLOW_END_TOK_in_mainCommand2375);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->popScope();
        	                  cmd->reset(new DatatypeDeclarationCommand(
        	                      PARSER_STATE->mkMutualDatatypeTypes(dts)));
        	                
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../../../src/parser/cvc/Cvc.g:785:5: CONTEXT_TOK ( ( str[s] | IDENTIFIER ) |)
        	    {
        	         MATCHT(CONTEXT_TOK, &FOLLOW_CONTEXT_TOK_in_mainCommand2388);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:786:5: ( ( str[s] | IDENTIFIER ) |)
        	        {
        	            int alt18=2;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            case STRING_LITERAL:
        	            	{
        	            		alt18=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt18=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 18;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt18)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:786:7: ( str[s] | IDENTIFIER )
        	        	    {
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:786:7: ( str[s] | IDENTIFIER )
        	        	        {
        	        	            int alt17=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case STRING_LITERAL:
        	        	            	{
        	        	            		alt17=1;
        	        	            	}
        	        	                break;
        	        	            case IDENTIFIER:
        	        	            	{
        	        	            		alt17=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return ;
        	        	                }

        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 17;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulemainCommandEx;

        	        	            }

        	        	            switch (alt17)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:786:9: str[s]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_str_in_mainCommand2398);
        	        	        	        str(ctx, s);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:786:18: IDENTIFIER
        	        	        	    {
        	        	        	        IDENTIFIER4 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_mainCommand2403);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             s = AntlrInput::tokenText(IDENTIFIER4); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             UNSUPPORTED("CONTEXT command"); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:788:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             UNSUPPORTED("CONTEXT command"); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 15:
        	    // ../../../../../../src/parser/cvc/Cvc.g:791:5: FORGET_TOK identifier[id,CHECK_NONE,SYM_VARIABLE]
        	    {
        	         MATCHT(FORGET_TOK, &FOLLOW_FORGET_TOK_in_mainCommand2436);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_identifier_in_mainCommand2438);
        	        identifier(ctx, id, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("FORGET command"); 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../../../src/parser/cvc/Cvc.g:794:5: GET_TYPE_TOK formula[f]
        	    {
        	         MATCHT(GET_TYPE_TOK, &FOLLOW_GET_TYPE_TOK_in_mainCommand2452);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2454);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("GET_TYPE command"); 
        	        }


        	    }
        	    break;
        	case 17:
        	    // ../../../../../../src/parser/cvc/Cvc.g:797:5: CHECK_TYPE_TOK formula[f] COLON type[t,CHECK_DECLARED]
        	    {
        	         MATCHT(CHECK_TYPE_TOK, &FOLLOW_CHECK_TYPE_TOK_in_mainCommand2468);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2470);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COLON, &FOLLOW_COLON_in_mainCommand2473);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_type_in_mainCommand2475);
        	        type(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("CHECK_TYPE command"); 
        	        }


        	    }
        	    break;
        	case 18:
        	    // ../../../../../../src/parser/cvc/Cvc.g:800:5: GET_CHILD_TOK formula[f] k= numeral
        	    {
        	         MATCHT(GET_CHILD_TOK, &FOLLOW_GET_CHILD_TOK_in_mainCommand2489);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2491);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_mainCommand2496);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("GET_CHILD command"); 
        	        }


        	    }
        	    break;
        	case 19:
        	    // ../../../../../../src/parser/cvc/Cvc.g:803:5: GET_OP_TOK formula[f]
        	    {
        	         MATCHT(GET_OP_TOK, &FOLLOW_GET_OP_TOK_in_mainCommand2509);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2511);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("GET_OP command"); 
        	        }


        	    }
        	    break;
        	case 20:
        	    // ../../../../../../src/parser/cvc/Cvc.g:806:5: GET_VALUE_TOK formula[f]
        	    {
        	         MATCHT(GET_VALUE_TOK, &FOLLOW_GET_VALUE_TOK_in_mainCommand2525);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2527);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new GetValueCommand(f)); 
        	        }


        	    }
        	    break;
        	case 21:
        	    // ../../../../../../src/parser/cvc/Cvc.g:809:5: SUBSTITUTE_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] COLON type[t,CHECK_DECLARED] EQUAL_TOK formula[f] LBRACKET identifier[id,CHECK_NONE,SYM_VARIABLE] ASSIGN_TOK formula[f] RBRACKET
        	    {
        	         MATCHT(SUBSTITUTE_TOK, &FOLLOW_SUBSTITUTE_TOK_in_mainCommand2541);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_identifier_in_mainCommand2543);
        	        identifier(ctx, id, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COLON, &FOLLOW_COLON_in_mainCommand2546);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_type_in_mainCommand2552);
        	        type(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_mainCommand2555);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2557);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_mainCommand2560);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_identifier_in_mainCommand2566);
        	        identifier(ctx, id, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(ASSIGN_TOK, &FOLLOW_ASSIGN_TOK_in_mainCommand2569);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2571);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RBRACKET, &FOLLOW_RBRACKET_in_mainCommand2574);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("SUBSTITUTE command"); 
        	        }


        	    }
        	    break;
        	case 22:
        	    // ../../../../../../src/parser/cvc/Cvc.g:816:5: DBG_TOK ( ( str[s] | IDENTIFIER ) |)
        	    {
        	         MATCHT(DBG_TOK, &FOLLOW_DBG_TOK_in_mainCommand2593);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:817:5: ( ( str[s] | IDENTIFIER ) |)
        	        {
        	            int alt20=2;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            case STRING_LITERAL:
        	            	{
        	            		alt20=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt20=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 20;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt20)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:817:7: ( str[s] | IDENTIFIER )
        	        	    {
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:817:7: ( str[s] | IDENTIFIER )
        	        	        {
        	        	            int alt19=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case STRING_LITERAL:
        	        	            	{
        	        	            		alt19=1;
        	        	            	}
        	        	                break;
        	        	            case IDENTIFIER:
        	        	            	{
        	        	            		alt19=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return ;
        	        	                }

        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 19;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulemainCommandEx;

        	        	            }

        	        	            switch (alt19)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:817:9: str[s]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_str_in_mainCommand2603);
        	        	        	        str(ctx, s);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:817:18: IDENTIFIER
        	        	        	    {
        	        	        	        IDENTIFIER5 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_mainCommand2608);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             s = AntlrInput::tokenText(IDENTIFIER5); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Debug.on(s); Trace.on(s); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:819:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Message() << "Please specify what to debug." << std::endl; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 23:
        	    // ../../../../../../src/parser/cvc/Cvc.g:822:5: TRACE_TOK ( ( str[s] | IDENTIFIER ) |)
        	    {
        	         MATCHT(TRACE_TOK, &FOLLOW_TRACE_TOK_in_mainCommand2641);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:823:5: ( ( str[s] | IDENTIFIER ) |)
        	        {
        	            int alt22=2;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            case STRING_LITERAL:
        	            	{
        	            		alt22=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt22=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 22;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt22)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:823:7: ( str[s] | IDENTIFIER )
        	        	    {
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:823:7: ( str[s] | IDENTIFIER )
        	        	        {
        	        	            int alt21=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case STRING_LITERAL:
        	        	            	{
        	        	            		alt21=1;
        	        	            	}
        	        	                break;
        	        	            case IDENTIFIER:
        	        	            	{
        	        	            		alt21=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return ;
        	        	                }

        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 21;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulemainCommandEx;

        	        	            }

        	        	            switch (alt21)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:823:9: str[s]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_str_in_mainCommand2651);
        	        	        	        str(ctx, s);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:823:18: IDENTIFIER
        	        	        	    {
        	        	        	        IDENTIFIER6 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_mainCommand2656);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             s = AntlrInput::tokenText(IDENTIFIER6); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Trace.on(s); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:825:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Message() << "Please specify something to trace." << std::endl; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // ../../../../../../src/parser/cvc/Cvc.g:827:5: UNTRACE_TOK ( ( str[s] | IDENTIFIER ) |)
        	    {
        	         MATCHT(UNTRACE_TOK, &FOLLOW_UNTRACE_TOK_in_mainCommand2688);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:828:5: ( ( str[s] | IDENTIFIER ) |)
        	        {
        	            int alt24=2;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            case STRING_LITERAL:
        	            	{
        	            		alt24=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt24=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 24;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt24)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:828:7: ( str[s] | IDENTIFIER )
        	        	    {
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:828:7: ( str[s] | IDENTIFIER )
        	        	        {
        	        	            int alt23=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case STRING_LITERAL:
        	        	            	{
        	        	            		alt23=1;
        	        	            	}
        	        	                break;
        	        	            case IDENTIFIER:
        	        	            	{
        	        	            		alt23=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return ;
        	        	                }

        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 23;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulemainCommandEx;

        	        	            }

        	        	            switch (alt23)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:828:9: str[s]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_str_in_mainCommand2698);
        	        	        	        str(ctx, s);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:828:18: IDENTIFIER
        	        	        	    {
        	        	        	        IDENTIFIER7 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_mainCommand2703);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             s = AntlrInput::tokenText(IDENTIFIER7); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Trace.off(s); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:830:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Message() << "Please specify something to untrace." << std::endl; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 25:
        	    // ../../../../../../src/parser/cvc/Cvc.g:833:5: HELP_TOK ( ( str[s] | IDENTIFIER ) |)
        	    {
        	         MATCHT(HELP_TOK, &FOLLOW_HELP_TOK_in_mainCommand2736);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:834:5: ( ( str[s] | IDENTIFIER ) |)
        	        {
        	            int alt26=2;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            case STRING_LITERAL:
        	            	{
        	            		alt26=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt26=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 26;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:834:7: ( str[s] | IDENTIFIER )
        	        	    {
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:834:7: ( str[s] | IDENTIFIER )
        	        	        {
        	        	            int alt25=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case STRING_LITERAL:
        	        	            	{
        	        	            		alt25=1;
        	        	            	}
        	        	                break;
        	        	            case IDENTIFIER:
        	        	            	{
        	        	            		alt25=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return ;
        	        	                }

        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 25;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulemainCommandEx;

        	        	            }

        	        	            switch (alt25)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:834:9: str[s]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_str_in_mainCommand2746);
        	        	        	        str(ctx, s);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:834:18: IDENTIFIER
        	        	        	    {
        	        	        	        IDENTIFIER8 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_mainCommand2751);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             s = AntlrInput::tokenText(IDENTIFIER8); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Message() << "No help available for `" << s << "'." << std::endl; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:836:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             Message() << "Please use --help at the command line for help."
        	        	                            << std::endl; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 26:
        	    // ../../../../../../src/parser/cvc/Cvc.g:840:5: TRANSFORM_TOK formula[f]
        	    {
        	         MATCHT(TRANSFORM_TOK, &FOLLOW_TRANSFORM_TOK_in_mainCommand2792);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2794);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new SimplifyCommand(f)); 
        	        }


        	    }
        	    break;
        	case 27:
        	    // ../../../../../../src/parser/cvc/Cvc.g:843:5: PRINT_TOK formula[f]
        	    {
        	         MATCHT(PRINT_TOK, &FOLLOW_PRINT_TOK_in_mainCommand2808);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2810);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("PRINT command"); 
        	        }


        	    }
        	    break;
        	case 28:
        	    // ../../../../../../src/parser/cvc/Cvc.g:845:5: PRINT_TYPE_TOK type[t,CHECK_DECLARED]
        	    {
        	         MATCHT(PRINT_TYPE_TOK, &FOLLOW_PRINT_TYPE_TOK_in_mainCommand2823);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_type_in_mainCommand2825);
        	        type(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("PRINT_TYPE command"); 
        	        }


        	    }
        	    break;
        	case 29:
        	    // ../../../../../../src/parser/cvc/Cvc.g:848:5: CALL_TOK identifier[id,CHECK_NONE,SYM_VARIABLE] formula[f]
        	    {
        	         MATCHT(CALL_TOK, &FOLLOW_CALL_TOK_in_mainCommand2839);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_identifier_in_mainCommand2841);
        	        identifier(ctx, id, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand2844);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("CALL command"); 
        	        }


        	    }
        	    break;
        	case 30:
        	    // ../../../../../../src/parser/cvc/Cvc.g:851:5: ECHO_TOK ( simpleSymbolicExpr[sexpr] |)
        	    {
        	         MATCHT(ECHO_TOK, &FOLLOW_ECHO_TOK_in_mainCommand2858);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:852:5: ( simpleSymbolicExpr[sexpr] |)
        	        {
        	            int alt27=2;
        	            switch ( LA(1) )
        	            {
        	            case BINARY_LITERAL:
        	            case DECIMAL_LITERAL:
        	            case HEX_LITERAL:
        	            case IDENTIFIER:
        	            case INTEGER_LITERAL:
        	            case MINUS_TOK:
        	            case STRING_LITERAL:
        	            	{
        	            		alt27=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt27=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 27;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt27)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:852:7: simpleSymbolicExpr[sexpr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExpr_in_mainCommand2866);
        	        	        simpleSymbolicExpr(ctx, sexpr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(new EchoCommand(sexpr.getValue())); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:854:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             cmd->reset(new EchoCommand()); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 31:
        	    // ../../../../../../src/parser/cvc/Cvc.g:857:5: EXIT_TOK
        	    {
        	         MATCHT(EXIT_TOK, &FOLLOW_EXIT_TOK_in_mainCommand2896);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new QuitCommand()); 
        	        }


        	    }
        	    break;
        	case 32:
        	    // ../../../../../../src/parser/cvc/Cvc.g:860:5: INCLUDE_TOK ( ( str[s] | IDENTIFIER ) |)
        	    {
        	         MATCHT(INCLUDE_TOK, &FOLLOW_INCLUDE_TOK_in_mainCommand2909);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:861:5: ( ( str[s] | IDENTIFIER ) |)
        	        {
        	            int alt29=2;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            case STRING_LITERAL:
        	            	{
        	            		alt29=1;
        	            	}
        	                break;
        	            case SEMICOLON:
        	            	{
        	            		alt29=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 29;
        	                EXCEPTION->state        = 0;


        	                goto rulemainCommandEx;

        	            }

        	            switch (alt29)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:861:7: ( str[s] | IDENTIFIER )
        	        	    {
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:861:7: ( str[s] | IDENTIFIER )
        	        	        {
        	        	            int alt28=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case STRING_LITERAL:
        	        	            	{
        	        	            		alt28=1;
        	        	            	}
        	        	                break;
        	        	            case IDENTIFIER:
        	        	            	{
        	        	            		alt28=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return ;
        	        	                }

        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 28;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulemainCommandEx;

        	        	            }

        	        	            switch (alt28)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:861:9: str[s]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_str_in_mainCommand2919);
        	        	        	        str(ctx, s);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:861:18: IDENTIFIER
        	        	        	    {
        	        	        	        IDENTIFIER9 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_mainCommand2924);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulemainCommandEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             s = AntlrInput::tokenText(IDENTIFIER9); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             UNSUPPORTED("INCLUDE command"); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:863:7: 
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             PARSER_STATE->parseError("No filename given to INCLUDE command"); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 33:
        	    // ../../../../../../src/parser/cvc/Cvc.g:866:5: DUMP_PROOF_TOK
        	    {
        	         MATCHT(DUMP_PROOF_TOK, &FOLLOW_DUMP_PROOF_TOK_in_mainCommand2957);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new GetProofCommand()); 
        	        }


        	    }
        	    break;
        	case 34:
        	    // ../../../../../../src/parser/cvc/Cvc.g:869:5: DUMP_UNSAT_CORE_TOK
        	    {
        	         MATCHT(DUMP_UNSAT_CORE_TOK, &FOLLOW_DUMP_UNSAT_CORE_TOK_in_mainCommand2970);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new GetUnsatCoreCommand()); 
        	        }


        	    }
        	    break;
        	case 35:
        	    // ../../../../../../src/parser/cvc/Cvc.g:872:5: ( DUMP_ASSUMPTIONS_TOK | DUMP_SIG_TOK | DUMP_TCC_TOK | DUMP_TCC_ASSUMPTIONS_TOK | DUMP_TCC_PROOF_TOK | DUMP_CLOSURE_TOK | DUMP_CLOSURE_PROOF_TOK )
        	    {
        	        if ( ((LA(1) >= DUMP_ASSUMPTIONS_TOK) && (LA(1) <= DUMP_CLOSURE_TOK)) || ((LA(1) >= DUMP_SIG_TOK) && (LA(1) <= DUMP_TCC_TOK)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto rulemainCommandEx;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("DUMP* command"); 
        	        }


        	    }
        	    break;
        	case 36:
        	    // ../../../../../../src/parser/cvc/Cvc.g:882:5: ( WHERE_TOK | ASSERTIONS_TOK | ASSUMPTIONS_TOK )
        	    {
        	        if ( LA(1) == ASSERTIONS_TOK || LA(1) == ASSUMPTIONS_TOK || LA(1) == WHERE_TOK )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto rulemainCommandEx;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new GetAssertionsCommand()); 
        	        }


        	    }
        	    break;
        	case 37:
        	    // ../../../../../../src/parser/cvc/Cvc.g:885:5: COUNTEREXAMPLE_TOK
        	    {
        	         MATCHT(COUNTEREXAMPLE_TOK, &FOLLOW_COUNTEREXAMPLE_TOK_in_mainCommand3079);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new GetModelCommand); 
        	        }


        	    }
        	    break;
        	case 38:
        	    // ../../../../../../src/parser/cvc/Cvc.g:887:5: COUNTERMODEL_TOK
        	    {
        	         MATCHT(COUNTERMODEL_TOK, &FOLLOW_COUNTERMODEL_TOK_in_mainCommand3091);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             cmd->reset(new GetModelCommand); 
        	        }


        	    }
        	    break;
        	case 39:
        	    // ../../../../../../src/parser/cvc/Cvc.g:890:5: ARITH_VAR_ORDER_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN
        	    {
        	         MATCHT(ARITH_VAR_ORDER_TOK, &FOLLOW_ARITH_VAR_ORDER_TOK_in_mainCommand3104);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_mainCommand3106);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand3108);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:890:43: ( COMMA formula[f] )*

        	        for (;;)
        	        {
        	            int alt30=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt30=1;
        	            	}
        	                break;

        	            }

        	            switch (alt30)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:890:45: COMMA formula[f]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_mainCommand3113);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand3115);
        	        	        formula(ctx, f);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemainCommandEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop30;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop30: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_mainCommand3121);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("ARITH_VAR_ORDER command"); 
        	        }


        	    }
        	    break;
        	case 40:
        	    // ../../../../../../src/parser/cvc/Cvc.g:893:5: CONTINUE_TOK
        	    {
        	         MATCHT(CONTINUE_TOK, &FOLLOW_CONTINUE_TOK_in_mainCommand3134);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("CONTINUE command"); 
        	        }


        	    }
        	    break;
        	case 41:
        	    // ../../../../../../src/parser/cvc/Cvc.g:895:5: RESTART_TOK formula[f]
        	    {
        	         MATCHT(RESTART_TOK, &FOLLOW_RESTART_TOK_in_mainCommand3146);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_mainCommand3148);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             UNSUPPORTED("RESTART command"); 
        	        }


        	    }
        	    break;
        	case 42:
        	    // ../../../../../../src/parser/cvc/Cvc.g:896:5: toplevelDeclaration[cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_toplevelDeclaration_in_mainCommand3157);
        	        toplevelDeclaration(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemainCommandEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemainCommandEx; /* Prevent compiler warnings */
    rulemainCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end mainCommand */

/**
 * $ANTLR start simpleSymbolicExpr
 * ../../../../../../src/parser/cvc/Cvc.g:899:1: simpleSymbolicExpr[CVC4::SExpr& sexpr] : ( INTEGER_LITERAL | MINUS_TOK INTEGER_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | BINARY_LITERAL | str[s] | IDENTIFIER );
 */
static void
simpleSymbolicExpr(pCvcParser ctx, CVC4::SExpr& sexpr)
{

      std::string s;
      CVC4::Rational r;

    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL10;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL11;
    pANTLR3_COMMON_TOKEN    DECIMAL_LITERAL12;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL13;
    pANTLR3_COMMON_TOKEN    BINARY_LITERAL14;
    pANTLR3_COMMON_TOKEN    IDENTIFIER15;

    /* Initialize rule variables
     */

    INTEGER_LITERAL10       = NULL;
    INTEGER_LITERAL11       = NULL;
    DECIMAL_LITERAL12       = NULL;
    HEX_LITERAL13       = NULL;
    BINARY_LITERAL14       = NULL;
    IDENTIFIER15       = NULL;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:904:3: ( INTEGER_LITERAL | MINUS_TOK INTEGER_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | BINARY_LITERAL | str[s] | IDENTIFIER )

            ANTLR3_UINT32 alt32;

            alt32=7;

            switch ( LA(1) )
            {
            case INTEGER_LITERAL:
            	{
            		alt32=1;
            	}
                break;
            case MINUS_TOK:
            	{
            		alt32=2;
            	}
                break;
            case DECIMAL_LITERAL:
            	{
            		alt32=3;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt32=4;
            	}
                break;
            case BINARY_LITERAL:
            	{
            		alt32=5;
            	}
                break;
            case STRING_LITERAL:
            	{
            		alt32=6;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt32=7;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 32;
                EXCEPTION->state        = 0;


                goto rulesimpleSymbolicExprEx;

            }

            switch (alt32)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:904:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL10 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3177);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(Integer(AntlrInput::tokenText(INTEGER_LITERAL10))); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:906:5: MINUS_TOK INTEGER_LITERAL
        	    {
        	         MATCHT(MINUS_TOK, &FOLLOW_MINUS_TOK_in_simpleSymbolicExpr3189);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        INTEGER_LITERAL11 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExpr3191);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(-Integer(AntlrInput::tokenText(INTEGER_LITERAL11))); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:908:5: DECIMAL_LITERAL
        	    {
        	        DECIMAL_LITERAL12 = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExpr3203);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(AntlrInput::tokenToRational(DECIMAL_LITERAL12)); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/cvc/Cvc.g:910:5: HEX_LITERAL
        	    {
        	        HEX_LITERAL13 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_simpleSymbolicExpr3215);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(AntlrInput::tokenText(HEX_LITERAL13)); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/cvc/Cvc.g:912:5: BINARY_LITERAL
        	    {
        	        BINARY_LITERAL14 = (pANTLR3_COMMON_TOKEN) MATCHT(BINARY_LITERAL, &FOLLOW_BINARY_LITERAL_in_simpleSymbolicExpr3227);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(AntlrInput::tokenText(BINARY_LITERAL14)); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/cvc/Cvc.g:914:5: str[s]
        	    {
        	        FOLLOWPUSH(FOLLOW_str_in_simpleSymbolicExpr3239);
        	        str(ctx, s);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(s); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/cvc/Cvc.g:916:5: IDENTIFIER
        	    {
        	        IDENTIFIER15 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simpleSymbolicExpr3252);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(AntlrInput::tokenText(IDENTIFIER15)); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleSymbolicExprEx; /* Prevent compiler warnings */
    rulesimpleSymbolicExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleSymbolicExpr */

/**
 * $ANTLR start symbolicExpr
 * ../../../../../../src/parser/cvc/Cvc.g:920:1: symbolicExpr[CVC4::SExpr& sexpr] : ( simpleSymbolicExpr[sexpr] | LPAREN ( symbolicExpr[sexpr] )* RPAREN );
 */
static void
symbolicExpr(pCvcParser ctx, CVC4::SExpr& sexpr)
{

      std::vector<SExpr> children;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:924:3: ( simpleSymbolicExpr[sexpr] | LPAREN ( symbolicExpr[sexpr] )* RPAREN )

            ANTLR3_UINT32 alt34;

            alt34=2;

            switch ( LA(1) )
            {
            case BINARY_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case IDENTIFIER:
            case INTEGER_LITERAL:
            case MINUS_TOK:
            case STRING_LITERAL:
            	{
            		alt34=1;
            	}
                break;
            case LPAREN:
            	{
            		alt34=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 34;
                EXCEPTION->state        = 0;


                goto rulesymbolicExprEx;

            }

            switch (alt34)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:924:5: simpleSymbolicExpr[sexpr]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExpr_in_symbolicExpr3277);
        	        simpleSymbolicExpr(ctx, sexpr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:925:5: LPAREN ( symbolicExpr[sexpr] )* RPAREN
        	    {
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_symbolicExpr3284);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:925:12: ( symbolicExpr[sexpr] )*

        	        for (;;)
        	        {
        	            int alt33=2;
        	            switch ( LA(1) )
        	            {
        	            case BINARY_LITERAL:
        	            case DECIMAL_LITERAL:
        	            case HEX_LITERAL:
        	            case IDENTIFIER:
        	            case INTEGER_LITERAL:
        	            case LPAREN:
        	            case MINUS_TOK:
        	            case STRING_LITERAL:
        	            	{
        	            		alt33=1;
        	            	}
        	                break;

        	            }

        	            switch (alt33)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:925:13: symbolicExpr[sexpr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_symbolicExpr_in_symbolicExpr3287);
        	        	        symbolicExpr(ctx, sexpr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolicExprEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             children.push_back(sexpr); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop33;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop33: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_symbolicExpr3295);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             sexpr = SExpr(children); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesymbolicExprEx; /* Prevent compiler warnings */
    rulesymbolicExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end symbolicExpr */

/**
 * $ANTLR start toplevelDeclaration
 * ../../../../../../src/parser/cvc/Cvc.g:932:1: toplevelDeclaration[CVC4::PtrCloser<CVC4::Command>* cmd] : identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON ( declareVariables[cmd,t,ids,true] | declareTypes[cmd,ids] ) ;
 */
static void
toplevelDeclaration(pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{
    /* Initialize rule variables
     */


      std::vector<std::string> ids;
      Type t;
      Debug("parser-extra") << "declaration: " << AntlrInput::tokenText(LT(1))
                            << std::endl;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:939:3: ( identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON ( declareVariables[cmd,t,ids,true] | declareTypes[cmd,ids] ) )
        // ../../../../../../src/parser/cvc/Cvc.g:939:5: identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON ( declareVariables[cmd,t,ids,true] | declareTypes[cmd,ids] )
        {
            FOLLOWPUSH(FOLLOW_identifierList_in_toplevelDeclaration3322);
            identifierList(ctx, ids, CHECK_NONE, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletoplevelDeclarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COLON, &FOLLOW_COLON_in_toplevelDeclaration3325);
            if  (HASEXCEPTION())
            {
                goto ruletoplevelDeclarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:940:5: ( declareVariables[cmd,t,ids,true] | declareTypes[cmd,ids] )
            {
                int alt35=2;
                switch ( LA(1) )
                {
                case ARRAY_TOK:
                case BITVECTOR_TOK:
                case BOOLEAN_TOK:
                case IDENTIFIER:
                case INT_TOK:
                case LBRACKET:
                case LET_TOK:
                case LPAREN:
                case REAL_TOK:
                case SET_TOK:
                case SQHASH:
                case STRING_TOK:
                case SUBTYPE_TOK:
                	{
                		alt35=1;
                	}
                    break;
                case TYPE_TOK:
                	{
                		alt35=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 35;
                    EXCEPTION->state        = 0;


                    goto ruletoplevelDeclarationEx;

                }

                switch (alt35)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:940:7: declareVariables[cmd,t,ids,true]
            	    {
            	        FOLLOWPUSH(FOLLOW_declareVariables_in_toplevelDeclaration3333);
            	        declareVariables(ctx, cmd, t, ids, true);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletoplevelDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:941:7: declareTypes[cmd,ids]
            	    {
            	        FOLLOWPUSH(FOLLOW_declareTypes_in_toplevelDeclaration3342);
            	        declareTypes(ctx, cmd, ids);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletoplevelDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletoplevelDeclarationEx; /* Prevent compiler warnings */
    ruletoplevelDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end toplevelDeclaration */

/**
 * $ANTLR start boundVarDecl
 * ../../../../../../src/parser/cvc/Cvc.g:947:1: boundVarDecl[std::vector<std::string>& ids, CVC4::Type& t] : identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON declareVariables[&local_cmd,t,ids,false] ;
 */
static void
boundVarDecl(pCvcParser ctx, std::vector<std::string>& ids, CVC4::Type& t)
{
    /* Initialize rule variables
     */


      CVC4::PtrCloser<Command> local_cmd;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:951:3: ( identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON declareVariables[&local_cmd,t,ids,false] )
        // ../../../../../../src/parser/cvc/Cvc.g:951:5: identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON declareVariables[&local_cmd,t,ids,false]
        {
            FOLLOWPUSH(FOLLOW_identifierList_in_boundVarDecl3366);
            identifierList(ctx, ids, CHECK_NONE, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COLON, &FOLLOW_COLON_in_boundVarDecl3369);
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_declareVariables_in_boundVarDecl3375);
            declareVariables(ctx, &local_cmd, t, ids, false);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleboundVarDeclEx; /* Prevent compiler warnings */
    ruleboundVarDeclEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end boundVarDecl */

/**
 * $ANTLR start boundVarDecls
 * ../../../../../../src/parser/cvc/Cvc.g:958:1: boundVarDecls : boundVarDecl[ids,t] ( COMMA boundVarDecl[ids,t] )* ;
 */
static void
boundVarDecls(pCvcParser ctx)
{
    /* Initialize rule variables
     */


      std::vector<std::string> ids;
      Type t;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:963:3: ( boundVarDecl[ids,t] ( COMMA boundVarDecl[ids,t] )* )
        // ../../../../../../src/parser/cvc/Cvc.g:963:5: boundVarDecl[ids,t] ( COMMA boundVarDecl[ids,t] )*
        {
            FOLLOWPUSH(FOLLOW_boundVarDecl_in_boundVarDecls3396);
            boundVarDecl(ctx, ids, t);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclsEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:963:25: ( COMMA boundVarDecl[ids,t] )*

            for (;;)
            {
                int alt36=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt36=1;
                	}
                    break;

                }

                switch (alt36)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:963:27: COMMA boundVarDecl[ids,t]
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_boundVarDecls3401);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleboundVarDeclsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_boundVarDecl_in_boundVarDecls3403);
            	        boundVarDecl(ctx, ids, t);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleboundVarDeclsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleboundVarDeclsEx; /* Prevent compiler warnings */
    ruleboundVarDeclsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end boundVarDecls */

/**
 * $ANTLR start boundVarDeclsReturn
 * ../../../../../../src/parser/cvc/Cvc.g:966:1: boundVarDeclsReturn[std::vector<CVC4::Expr>& terms,\n std::vector<CVC4::Type>& types] : boundVarDeclReturn[terms,types] ( COMMA boundVarDeclReturn[terms,types] )* ;
 */
static void
boundVarDeclsReturn(pCvcParser ctx, std::vector<CVC4::Expr>& terms, std::vector<CVC4::Type>& types)
{
    /* Initialize rule variables
     */


      std::vector<std::string> ids;
      Type t;
      terms.clear();
      types.clear();

    {
        // ../../../../../../src/parser/cvc/Cvc.g:974:3: ( boundVarDeclReturn[terms,types] ( COMMA boundVarDeclReturn[terms,types] )* )
        // ../../../../../../src/parser/cvc/Cvc.g:974:5: boundVarDeclReturn[terms,types] ( COMMA boundVarDeclReturn[terms,types] )*
        {
            FOLLOWPUSH(FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3426);
            boundVarDeclReturn(ctx, terms, types);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclsReturnEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:974:37: ( COMMA boundVarDeclReturn[terms,types] )*

            for (;;)
            {
                int alt37=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt37=1;
                	}
                    break;

                }

                switch (alt37)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:974:39: COMMA boundVarDeclReturn[terms,types]
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_boundVarDeclsReturn3431);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleboundVarDeclsReturnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_boundVarDeclReturn_in_boundVarDeclsReturn3433);
            	        boundVarDeclReturn(ctx, terms, types);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleboundVarDeclsReturnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleboundVarDeclsReturnEx; /* Prevent compiler warnings */
    ruleboundVarDeclsReturnEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end boundVarDeclsReturn */

/**
 * $ANTLR start boundVarDeclReturn
 * ../../../../../../src/parser/cvc/Cvc.g:977:1: boundVarDeclReturn[std::vector<CVC4::Expr>& terms,\n std::vector<CVC4::Type>& types] : identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON type[t,CHECK_DECLARED] ;
 */
static void
boundVarDeclReturn(pCvcParser ctx, std::vector<CVC4::Expr>& terms, std::vector<CVC4::Type>& types)
{
    /* Initialize rule variables
     */


      std::vector<std::string> ids;
      Type t;
      // NOTE: do not clear the vectors here!

    {
        // ../../../../../../src/parser/cvc/Cvc.g:984:3: ( identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON type[t,CHECK_DECLARED] )
        // ../../../../../../src/parser/cvc/Cvc.g:984:5: identifierList[ids,CHECK_NONE,SYM_VARIABLE] COLON type[t,CHECK_DECLARED]
        {
            FOLLOWPUSH(FOLLOW_identifierList_in_boundVarDeclReturn3456);
            identifierList(ctx, ids, CHECK_NONE, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclReturnEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COLON, &FOLLOW_COLON_in_boundVarDeclReturn3459);
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclReturnEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_type_in_boundVarDeclReturn3461);
            type(ctx, t, CHECK_DECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboundVarDeclReturnEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 const std::vector<Expr>& vars = PARSER_STATE->mkBoundVars(ids, t);
                      terms.insert(terms.end(), vars.begin(), vars.end());
                      for(unsigned i = 0; i < vars.size(); ++i) {
                        types.push_back(t);
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleboundVarDeclReturnEx; /* Prevent compiler warnings */
    ruleboundVarDeclReturnEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end boundVarDeclReturn */

/**
 * $ANTLR start declareTypes
 * ../../../../../../src/parser/cvc/Cvc.g:1000:1: declareTypes[CVC4::PtrCloser<CVC4::Command>* cmd,\n const std::vector<std::string>& idList] : ( TYPE_TOK | TYPE_TOK EQUAL_TOK type[t,CHECK_DECLARED] );
 */
static void
declareTypes(pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd, const std::vector<std::string>& idList)
{
    /* Initialize rule variables
     */


      Type t;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1006:3: ( TYPE_TOK | TYPE_TOK EQUAL_TOK type[t,CHECK_DECLARED] )

            ANTLR3_UINT32 alt38;

            alt38=2;

            switch ( LA(1) )
            {
            case TYPE_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case EQUAL_TOK:
            			{
            				alt38=2;
            			}
            		    break;
            		case SEMICOLON:
            			{
            				alt38=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 38;
            		    EXCEPTION->state        = 1;


            		    goto ruledeclareTypesEx;

            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 38;
                EXCEPTION->state        = 0;


                goto ruledeclareTypesEx;

            }

            switch (alt38)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1006:5: TYPE_TOK
        	    {
        	         MATCHT(TYPE_TOK, &FOLLOW_TYPE_TOK_in_declareTypes3495);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclareTypesEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             CVC4::PtrCloser<DeclarationSequence> seq(new DeclarationSequence());
        	                  for(std::vector<std::string>::const_iterator i = idList.begin();
        	                      i != idList.end(); ++i) {
        	                    // Don't allow a type variable to clash with a previously
        	                    // declared type variable, however a type variable and a
        	                    // non-type variable can clash unambiguously.  Break from CVC3
        	                    // behavior here.
        	                    PARSER_STATE->checkDeclaration(*i, CHECK_UNDECLARED, SYM_SORT);
        	                    Type sort = PARSER_STATE->mkSort(*i);
        	                    Command* decl = new DeclareTypeCommand(*i, 0, sort);
        	                    seq->addCommand(decl);
        	                  }
        	                  cmd->reset(seq.release());
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1023:5: TYPE_TOK EQUAL_TOK type[t,CHECK_DECLARED]
        	    {
        	         MATCHT(TYPE_TOK, &FOLLOW_TYPE_TOK_in_declareTypes3514);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclareTypesEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_declareTypes3516);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclareTypesEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_type_in_declareTypes3518);
        	        type(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclareTypesEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             for(std::vector<std::string>::const_iterator i = idList.begin();
        	                      i != idList.end();
        	                      ++i) {
        	                    PARSER_STATE->checkDeclaration(*i, CHECK_UNDECLARED, SYM_SORT);
        	                    PARSER_STATE->defineType(*i, t);
        	                  }
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclareTypesEx; /* Prevent compiler warnings */
    ruledeclareTypesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declareTypes */

/**
 * $ANTLR start declareVariables
 * ../../../../../../src/parser/cvc/Cvc.g:1042:1: declareVariables[CVC4::PtrCloser<CVC4::Command>* cmd, CVC4::Type& t,\n const std::vector<std::string>& idList, bool topLevel] : type[t,CHECK_DECLARED] ( EQUAL_TOK formula[f] )? ;
 */
static void
declareVariables(pCvcParser ctx, CVC4::PtrCloser<CVC4::Command>* cmd, CVC4::Type& t, const std::vector<std::string>& idList, bool topLevel)
{
    /* Initialize rule variables
     */


      Expr f;
      Debug("parser-extra") << "declType: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1049:3: ( type[t,CHECK_DECLARED] ( EQUAL_TOK formula[f] )? )
        // ../../../../../../src/parser/cvc/Cvc.g:1049:5: type[t,CHECK_DECLARED] ( EQUAL_TOK formula[f] )?
        {
            FOLLOWPUSH(FOLLOW_type_in_declareVariables3552);
            type(ctx, t, CHECK_DECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclareVariablesEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1049:28: ( EQUAL_TOK formula[f] )?
            {
                int alt39=2;
                switch ( LA(1) )
                {
                    case EQUAL_TOK:
                    	{
                    		alt39=1;
                    	}
                        break;
                }

                switch (alt39)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1049:30: EQUAL_TOK formula[f]
            	    {
            	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_declareVariables3557);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclareVariablesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_formula_in_declareVariables3559);
            	        formula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclareVariablesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                 CVC4::PtrCloser<DeclarationSequence> seq;
                      if(topLevel) {
                        seq.reset(new DeclarationSequence());
                      }
                      if(f.isNull()) {
                        Debug("parser") << "working on " << idList.front() << " : " << t
                                        << std::endl;
                        // CVC language allows redeclaration of variables if types are the same
                        for(std::vector<std::string>::const_iterator i = idList.begin(),
                              i_end = idList.end();
                            i != i_end;
                            ++i) {
                          if(PARSER_STATE->isDeclared(*i, SYM_VARIABLE)) {
                            Type oldType = PARSER_STATE->getType(*i);
                            Debug("parser") << "  " << *i << " was declared previously "
                                            << "with type " << oldType << std::endl;
                            if(oldType != t) {
                              std::stringstream ss;
                              ss << language::SetLanguage(language::output::LANG_CVC4)
                                 << "incompatible type for `" << *i << "':" << std::endl
                                 << "  old type: " << oldType << std::endl
                                 << "  new type: " << t << std::endl;
                              PARSER_STATE->parseError(ss.str());
                            } else {
                              Debug("parser") << "  types " << t << " and " << oldType
                                              << " are compatible" << std::endl;
                            }
                          } else {
                            Debug("parser") << "  " << *i << " not declared" << std::endl;
                            if(topLevel) {
                              Expr func = PARSER_STATE->mkVar(*i, t, ExprManager::VAR_FLAG_GLOBAL);
                              Command* decl = new DeclareFunctionCommand(*i, func, t);
                              seq->addCommand(decl);
                            } else {
                              PARSER_STATE->mkBoundVar(*i, t);
                            }
                          }
                        }
                      } else {
                        // f is not null-- meaning this is a definition not a declaration
                        if(!topLevel) {
                          // must be top-level; doesn't make sense to write something
                          // like e.g. FORALL(x:INT = 4): [...]
                          PARSER_STATE->parseError("cannot construct a definition here; maybe you want a LET");
                        }
                        assert(!idList.empty());
                        for(std::vector<std::string>::const_iterator i = idList.begin(),
                              i_end = idList.end();
                            i != i_end;
                            ++i) {
                          Debug("parser") << "making " << *i << " : " << t << " = " << f << std::endl;
                          PARSER_STATE->checkDeclaration(*i, CHECK_UNDECLARED, SYM_VARIABLE);
                          Expr func = EXPR_MANAGER->mkVar(*i, t, ExprManager::VAR_FLAG_GLOBAL | ExprManager::VAR_FLAG_DEFINED);
                          PARSER_STATE->defineFunction(*i, f);
                          Command* decl = new DefineFunctionCommand(*i, func, f);
                          seq->addCommand(decl);
                        }
                      }
                      if(topLevel) {
                        cmd->reset(new DeclarationSequence());
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclareVariablesEx; /* Prevent compiler warnings */
    ruledeclareVariablesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declareVariables */

/**
 * $ANTLR start identifierList
 * ../../../../../../src/parser/cvc/Cvc.g:1120:1: identifierList[std::vector<std::string>& idList,\n CVC4::parser::DeclarationCheck check,\n CVC4::parser::SymbolType type] : identifier[id,check,type] ( COMMA identifier[id,check,type] )* ;
 */
static void
identifierList(pCvcParser ctx, std::vector<std::string>& idList, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type)
{
    /* Initialize rule variables
     */


      std::string id;
      idList.clear();

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1127:3: ( identifier[id,check,type] ( COMMA identifier[id,check,type] )* )
        // ../../../../../../src/parser/cvc/Cvc.g:1127:5: identifier[id,check,type] ( COMMA identifier[id,check,type] )*
        {
            FOLLOWPUSH(FOLLOW_identifier_in_identifierList3590);
            identifier(ctx, id, check, type);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleidentifierListEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 idList.push_back(id); 
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1128:5: ( COMMA identifier[id,check,type] )*

            for (;;)
            {
                int alt40=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt40=1;
                	}
                    break;

                }

                switch (alt40)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1128:7: COMMA identifier[id,check,type]
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_identifierList3601);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifierListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_identifier_in_identifierList3603);
            	        identifier(ctx, id, check, type);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifierListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             idList.push_back(id); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop40;	/* break out of the loop */
            	    break;
                }
            }
            loop40: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierListEx; /* Prevent compiler warnings */
    ruleidentifierListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end identifierList */

/**
 * $ANTLR start identifier
 * ../../../../../../src/parser/cvc/Cvc.g:1134:1: identifier[std::string& id,\n CVC4::parser::DeclarationCheck check,\n CVC4::parser::SymbolType type] : IDENTIFIER ;
 */
static void
identifier(pCvcParser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type)
{
    pANTLR3_COMMON_TOKEN    IDENTIFIER16;

    /* Initialize rule variables
     */

    IDENTIFIER16       = NULL;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1137:3: ( IDENTIFIER )
        // ../../../../../../src/parser/cvc/Cvc.g:1137:5: IDENTIFIER
        {
            IDENTIFIER16 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_identifier3625);
            if  (HASEXCEPTION())
            {
                goto ruleidentifierEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 id = AntlrInput::tokenText(IDENTIFIER16);
                      PARSER_STATE->checkDeclaration(id, check, type); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end identifier */

/**
 * $ANTLR start type
 * ../../../../../../src/parser/cvc/Cvc.g:1154:1: type[CVC4::Type& t,\n CVC4::parser::DeclarationCheck check] : ( restrictedTypePossiblyFunctionLHS[t,check,lhs] ( ARROW_TOK type[t2,check] )? | LET_TOK typeLetDecl[check] ( COMMA typeLetDecl[check] )* IN_TOK type[t,check] );
 */
static void
type(pCvcParser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */


      Type t2;
      bool lhs;
      std::vector<Type> args;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1162:3: ( restrictedTypePossiblyFunctionLHS[t,check,lhs] ( ARROW_TOK type[t2,check] )? | LET_TOK typeLetDecl[check] ( COMMA typeLetDecl[check] )* IN_TOK type[t,check] )

            ANTLR3_UINT32 alt43;

            alt43=2;

            switch ( LA(1) )
            {
            case ARRAY_TOK:
            case BITVECTOR_TOK:
            case BOOLEAN_TOK:
            case IDENTIFIER:
            case INT_TOK:
            case LBRACKET:
            case LPAREN:
            case REAL_TOK:
            case SET_TOK:
            case SQHASH:
            case STRING_TOK:
            case SUBTYPE_TOK:
            	{
            		alt43=1;
            	}
                break;
            case LET_TOK:
            	{
            		alt43=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 43;
                EXCEPTION->state        = 0;


                goto ruletypeEx;

            }

            switch (alt43)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1162:5: restrictedTypePossiblyFunctionLHS[t,check,lhs] ( ARROW_TOK type[t2,check] )?
        	    {
        	        FOLLOWPUSH(FOLLOW_restrictedTypePossiblyFunctionLHS_in_type3658);
        	        restrictedTypePossiblyFunctionLHS(ctx, t, check, lhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             if(lhs) {
        	                    assert(t.isTuple());
        	                    args = ((DatatypeType)t).getTupleTypes();
        	                  } else {
        	                    args.push_back(t);
        	                  }
        	                
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1170:5: ( ARROW_TOK type[t2,check] )?
        	        {
        	            int alt41=2;
        	            switch ( LA(1) )
        	            {
        	                case ARROW_TOK:
        	                	{
        	                		alt41=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt41)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1170:7: ARROW_TOK type[t2,check]
        	        	    {
        	        	         MATCHT(ARROW_TOK, &FOLLOW_ARROW_TOK_in_type3673);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletypeEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_type_in_type3675);
        	        	        type(ctx, t2, check);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletypeEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             args.push_back(t2); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             if(t2.isNull()) {
        	                    if(lhs) {
        	                      PARSER_STATE->parseError("improperly-placed type list; expected `->' after to define a function; or else maybe these parentheses were meant to be square brackets, to define a tuple type?");
        	                    }
        	                  } else {
        	                    t = EXPR_MANAGER->mkFunctionType(args);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1183:5: LET_TOK typeLetDecl[check] ( COMMA typeLetDecl[check] )* IN_TOK type[t,check]
        	    {
        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_type3700);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_typeLetDecl_in_type3708);
        	        typeLetDecl(ctx, check);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1184:24: ( COMMA typeLetDecl[check] )*

        	        for (;;)
        	        {
        	            int alt42=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt42=1;
        	            	}
        	                break;

        	            }

        	            switch (alt42)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1184:26: COMMA typeLetDecl[check]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_type3713);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletypeEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_typeLetDecl_in_type3715);
        	        	        typeLetDecl(ctx, check);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletypeEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop42;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop42: ; /* Jump out to here if this rule does not match */


        	         MATCHT(IN_TOK, &FOLLOW_IN_TOK_in_type3721);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_type_in_type3723);
        	        type(ctx, t, check);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end type */

/**
 * $ANTLR start restrictedType
 * ../../../../../../src/parser/cvc/Cvc.g:1198:1: restrictedType[CVC4::Type& t,\n CVC4::parser::DeclarationCheck check] : restrictedTypePossiblyFunctionLHS[t,check,lhs] ;
 */
static void
restrictedType(pCvcParser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */


      bool lhs;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1203:3: ( restrictedTypePossiblyFunctionLHS[t,check,lhs] )
        // ../../../../../../src/parser/cvc/Cvc.g:1203:5: restrictedTypePossiblyFunctionLHS[t,check,lhs]
        {
            FOLLOWPUSH(FOLLOW_restrictedTypePossiblyFunctionLHS_in_restrictedType3759);
            restrictedTypePossiblyFunctionLHS(ctx, t, check, lhs);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerestrictedTypeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 if(lhs) { PARSER_STATE->parseError("improperly-placed type list; maybe these parentheses were meant to be square brackets, to define a tuple type?"); } 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulerestrictedTypeEx; /* Prevent compiler warnings */
    rulerestrictedTypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end restrictedType */

/**
 * $ANTLR start restrictedTypePossiblyFunctionLHS
 * ../../../../../../src/parser/cvc/Cvc.g:1211:1: restrictedTypePossiblyFunctionLHS[CVC4::Type& t,\n CVC4::parser::DeclarationCheck check,\n bool& lhs] : ( identifier[id,check,SYM_SORT] ( parameterization[check,types] )? | ARRAY_TOK restrictedType[t,check] OF_TOK restrictedType[t2,check] | SET_TOK OF_TOK restrictedType[t,check] | SUBTYPE_TOK LPAREN formula[f] ( COMMA formula[f2] )? RPAREN | LBRACKET k1= bound DOTDOT k2= bound RBRACKET | LBRACKET ( type[t,check] ( COMMA type[t,check] )* )? RBRACKET | SQHASH ( identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] ( COMMA identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] )* )? HASHSQ | BITVECTOR_TOK LPAREN k= numeral RPAREN | STRING_TOK | BOOLEAN_TOK | REAL_TOK | INT_TOK | LPAREN type[t,check] ( COMMA type[t,check] )* RPAREN );
 */
static void
restrictedTypePossiblyFunctionLHS(pCvcParser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check, bool& lhs)
{
    CVC4::parser::cvc::mySubrangeBound k1;
    #undef	RETURN_TYPE_k1
    #define	RETURN_TYPE_k1 CVC4::parser::cvc::mySubrangeBound

    CVC4::parser::cvc::mySubrangeBound k2;
    #undef	RETURN_TYPE_k2
    #define	RETURN_TYPE_k2 CVC4::parser::cvc::mySubrangeBound

    unsigned k;
    #undef	RETURN_TYPE_k
    #define	RETURN_TYPE_k unsigned

    /* Initialize rule variables
     */


      Type t2;
      Expr f, f2;
      std::string id;
      std::vector<Type> types;
      std::vector< std::pair<std::string, Type> > typeIds;
      //SymbolTable* symtab;
      Parser* parser;
      lhs = false;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1225:3: ( identifier[id,check,SYM_SORT] ( parameterization[check,types] )? | ARRAY_TOK restrictedType[t,check] OF_TOK restrictedType[t2,check] | SET_TOK OF_TOK restrictedType[t,check] | SUBTYPE_TOK LPAREN formula[f] ( COMMA formula[f2] )? RPAREN | LBRACKET k1= bound DOTDOT k2= bound RBRACKET | LBRACKET ( type[t,check] ( COMMA type[t,check] )* )? RBRACKET | SQHASH ( identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] ( COMMA identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] )* )? HASHSQ | BITVECTOR_TOK LPAREN k= numeral RPAREN | STRING_TOK | BOOLEAN_TOK | REAL_TOK | INT_TOK | LPAREN type[t,check] ( COMMA type[t,check] )* RPAREN )

            ANTLR3_UINT32 alt51;

            alt51=13;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt51=1;
            	}
                break;
            case ARRAY_TOK:
            	{
            		alt51=2;
            	}
                break;
            case SET_TOK:
            	{
            		alt51=3;
            	}
                break;
            case SUBTYPE_TOK:
            	{
            		alt51=4;
            	}
                break;
            case LBRACKET:
            	{
            		switch ( LA(2) )
            		{
            		case INTEGER_LITERAL:
            		case MINUS_TOK:
            		case UNDERSCORE:
            			{
            				alt51=5;
            			}
            		    break;
            		case ARRAY_TOK:
            		case BITVECTOR_TOK:
            		case BOOLEAN_TOK:
            		case IDENTIFIER:
            		case INT_TOK:
            		case LBRACKET:
            		case LET_TOK:
            		case LPAREN:
            		case RBRACKET:
            		case REAL_TOK:
            		case SET_TOK:
            		case SQHASH:
            		case STRING_TOK:
            		case SUBTYPE_TOK:
            			{
            				alt51=6;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 51;
            		    EXCEPTION->state        = 5;


            		    goto rulerestrictedTypePossiblyFunctionLHSEx;

            		}

            	}
                break;
            case SQHASH:
            	{
            		alt51=7;
            	}
                break;
            case BITVECTOR_TOK:
            	{
            		alt51=8;
            	}
                break;
            case STRING_TOK:
            	{
            		alt51=9;
            	}
                break;
            case BOOLEAN_TOK:
            	{
            		alt51=10;
            	}
                break;
            case REAL_TOK:
            	{
            		alt51=11;
            	}
                break;
            case INT_TOK:
            	{
            		alt51=12;
            	}
                break;
            case LPAREN:
            	{
            		alt51=13;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 51;
                EXCEPTION->state        = 0;


                goto rulerestrictedTypePossiblyFunctionLHSEx;

            }

            switch (alt51)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1225:5: identifier[id,check,SYM_SORT] ( parameterization[check,types] )?
        	    {
        	        FOLLOWPUSH(FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS3793);
        	        identifier(ctx, id, check, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1226:5: ( parameterization[check,types] )?
        	        {
        	            int alt44=2;
        	            switch ( LA(1) )
        	            {
        	                case LBRACKET:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case IDENTIFIER:
        	                		    	{
        	                		    		switch ( LA(3) )
        	                		    		{
        	                		    		    case COMMA:
        	                		    		    case LBRACKET:
        	                		    		    case RBRACKET:
        	                		    		    	{
        	                		    		    		alt44=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		    case ARRAY_TOK:
        	                		    case BITVECTOR_TOK:
        	                		    case BOOLEAN_TOK:
        	                		    case INT_TOK:
        	                		    case LBRACKET:
        	                		    case LPAREN:
        	                		    case REAL_TOK:
        	                		    case SET_TOK:
        	                		    case SQHASH:
        	                		    case STRING_TOK:
        	                		    case SUBTYPE_TOK:
        	                		    	{
        	                		    		alt44=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt44)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1226:5: parameterization[check,types]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_parameterization_in_restrictedTypePossiblyFunctionLHS3800);
        	        	        parameterization(ctx, check, types);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {

        	                  if(check == CHECK_DECLARED ||
        	                     PARSER_STATE->isDeclared(id, SYM_SORT)) {
        	                    Debug("parser-param") << "param: getSort " << id << " " << types.size() << " " << PARSER_STATE->getArity( id )
        	                                          << " " << PARSER_STATE->isDeclared(id, SYM_SORT) << std::endl;
        	                    if(types.size() != PARSER_STATE->getArity(id)) {
        	                      std::stringstream ss;
        	                      ss << "incorrect arity for symbol `" << id << "': expected "
        	                         << PARSER_STATE->getArity( id ) << " type arguments, got "
        	                         << types.size();
        	                      PARSER_STATE->parseError(ss.str());
        	                    }
        	                    if(types.size() > 0) {
        	                      t = PARSER_STATE->getSort(id, types);
        	                    }else{
        	                      t = PARSER_STATE->getSort(id);
        	                    }
        	                  } else {
        	                    if(types.empty()) {
        	                      t = PARSER_STATE->mkUnresolvedType(id);
        	                      Debug("parser-param") << "param: make unres type " << id << std::endl;
        	                    }else{
        	                      t = PARSER_STATE->mkUnresolvedTypeConstructor(id,types);
        	                      t = SortConstructorType(t).instantiate( types );
        	                      Debug("parser-param") << "param: make unres param type " << id << " " << types.size() << " "
        	                                            << PARSER_STATE->getArity( id ) << std::endl;
        	                    }
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1258:5: ARRAY_TOK restrictedType[t,check] OF_TOK restrictedType[t2,check]
        	    {
        	         MATCHT(ARRAY_TOK, &FOLLOW_ARRAY_TOK_in_restrictedTypePossiblyFunctionLHS3821);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3823);
        	        restrictedType(ctx, t, check);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(OF_TOK, &FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3826);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3828);
        	        restrictedType(ctx, t2, check);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             t = EXPR_MANAGER->mkArrayType(t, t2); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1260:5: SET_TOK OF_TOK restrictedType[t,check]
        	    {
        	         MATCHT(SET_TOK, &FOLLOW_SET_TOK_in_restrictedTypePossiblyFunctionLHS3841);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(OF_TOK, &FOLLOW_OF_TOK_in_restrictedTypePossiblyFunctionLHS3843);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_restrictedType_in_restrictedTypePossiblyFunctionLHS3845);
        	        restrictedType(ctx, t, check);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             t = EXPR_MANAGER->mkSetType(t); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1264:5: SUBTYPE_TOK LPAREN formula[f] ( COMMA formula[f2] )? RPAREN
        	    {
        	         MATCHT(SUBTYPE_TOK, &FOLLOW_SUBTYPE_TOK_in_restrictedTypePossiblyFunctionLHS3868);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS3870);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             /*symtab = PARSER_STATE->getSymbolTable();
        	                  PARSER_STATE->useDeclarationsFrom(new SymbolTable());*/ 
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3888);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1271:16: ( COMMA formula[f2] )?
        	        {
        	            int alt45=2;
        	            switch ( LA(1) )
        	            {
        	                case COMMA:
        	                	{
        	                		alt45=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt45)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1271:18: COMMA formula[f2]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3893);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_formula_in_restrictedTypePossiblyFunctionLHS3895);
        	        	        formula(ctx, f2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS3901);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             /*SymbolTable* old = PARSER_STATE->getSymbolTable();
        	                  PARSER_STATE->useDeclarationsFrom(symtab);
        	                  delete old;*/
        	                  PARSER_STATE->unimplementedFeature("predicate subtyping not supported in this release");
        	                  /*t = f2.isNull() ?
        	                    EXPR_MANAGER->mkPredicateSubtype(f) :
        	                    EXPR_MANAGER->mkPredicateSubtype(f, f2);
        	                  */
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1283:5: LBRACKET k1= bound DOTDOT k2= bound RBRACKET
        	    {
        	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3920);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3924);
        	        k1=bound(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(DOTDOT, &FOLLOW_DOTDOT_in_restrictedTypePossiblyFunctionLHS3926);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_bound_in_restrictedTypePossiblyFunctionLHS3930);
        	        k2=bound(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RBRACKET, &FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3932);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             if(k1.hasBound() && k2.hasBound() &&
        	                     k1.getBound() > k2.getBound()) {
        	                    std::stringstream ss;
        	                    ss << "Subrange [" << k1.getBound() << ".." << k2.getBound()
        	                       << "] inappropriate: range must be nonempty!";
        	                    PARSER_STATE->parseError(ss.str());
        	                  }
        	                  t = EXPR_MANAGER->mkSubrangeType(SubrangeBounds(k1, k2));
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1295:5: LBRACKET ( type[t,check] ( COMMA type[t,check] )* )? RBRACKET
        	    {
        	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_restrictedTypePossiblyFunctionLHS3951);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1295:14: ( type[t,check] ( COMMA type[t,check] )* )?
        	        {
        	            int alt47=2;
        	            switch ( LA(1) )
        	            {
        	                case ARRAY_TOK:
        	                case BITVECTOR_TOK:
        	                case BOOLEAN_TOK:
        	                case IDENTIFIER:
        	                case INT_TOK:
        	                case LBRACKET:
        	                case LET_TOK:
        	                case LPAREN:
        	                case REAL_TOK:
        	                case SET_TOK:
        	                case SQHASH:
        	                case STRING_TOK:
        	                case SUBTYPE_TOK:
        	                	{
        	                		alt47=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt47)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1295:16: type[t,check] ( COMMA type[t,check] )*
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3955);
        	        	        type(ctx, t, check);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             types.push_back(t); 
        	        	        }


        	        	        // ../../../../../../src/parser/cvc/Cvc.g:1296:5: ( COMMA type[t,check] )*

        	        	        for (;;)
        	        	        {
        	        	            int alt46=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case COMMA:
        	        	            	{
        	        	            		alt46=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt46)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1296:7: COMMA type[t,check]
        	        	        	    {
        	        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS3966);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_type_in_restrictedTypePossiblyFunctionLHS3968);
        	        	        	        type(ctx, t, check);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             types.push_back(t); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop46;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop46: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RBRACKET, &FOLLOW_RBRACKET_in_restrictedTypePossiblyFunctionLHS3979);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             if(types.size() == 1 && types.front().isFunction()) {
        	                    // old style function syntax [ T -> U ]
        	                    PARSER_STATE->parseError("old-style function type syntax not supported anymore; please use the new syntax");
        	                  } else {
        	                    // tuple type [ T, U, V... ]
        	                    t = EXPR_MANAGER->mkTupleType(types);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1307:5: SQHASH ( identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] ( COMMA identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] )* )? HASHSQ
        	    {
        	         MATCHT(SQHASH, &FOLLOW_SQHASH_in_restrictedTypePossiblyFunctionLHS3998);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1307:12: ( identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] ( COMMA identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] )* )?
        	        {
        	            int alt49=2;
        	            switch ( LA(1) )
        	            {
        	                case IDENTIFIER:
        	                	{
        	                		alt49=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt49)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1307:14: identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] ( COMMA identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] )*
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4002);
        	        	        identifier(ctx, id, CHECK_NONE, SYM_SORT);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         MATCHT(COLON, &FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4005);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4007);
        	        	        type(ctx, t, check);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             typeIds.push_back(std::make_pair(id, t)); 
        	        	        }


        	        	        // ../../../../../../src/parser/cvc/Cvc.g:1308:5: ( COMMA identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check] )*

        	        	        for (;;)
        	        	        {
        	        	            int alt48=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case COMMA:
        	        	            	{
        	        	            		alt48=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt48)
        	        	            {
        	        	        	case 1:
        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1308:7: COMMA identifier[id,CHECK_NONE,SYM_SORT] COLON type[t,check]
        	        	        	    {
        	        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4018);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_identifier_in_restrictedTypePossiblyFunctionLHS4020);
        	        	        	        identifier(ctx, id, CHECK_NONE, SYM_SORT);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	         MATCHT(COLON, &FOLLOW_COLON_in_restrictedTypePossiblyFunctionLHS4023);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4025);
        	        	        	        type(ctx, t, check);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        if ( BACKTRACKING==0 )
        	        	        	        {
        	        	        	             typeIds.push_back(std::make_pair(id, t)); 
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop48;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop48: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(HASHSQ, &FOLLOW_HASHSQ_in_restrictedTypePossiblyFunctionLHS4036);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             t = EXPR_MANAGER->mkRecordType(typeIds); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1312:5: BITVECTOR_TOK LPAREN k= numeral RPAREN
        	    {
        	         MATCHT(BITVECTOR_TOK, &FOLLOW_BITVECTOR_TOK_in_restrictedTypePossiblyFunctionLHS4055);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4057);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_restrictedTypePossiblyFunctionLHS4061);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4063);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             if(k == 0) {
        	                    PARSER_STATE->parseError("Illegal bitvector size: 0");
        	                  }
        	                  t = EXPR_MANAGER->mkBitVectorType(k);
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1320:5: STRING_TOK
        	    {
        	         MATCHT(STRING_TOK, &FOLLOW_STRING_TOK_in_restrictedTypePossiblyFunctionLHS4082);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             t = EXPR_MANAGER->stringType(); 
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1323:5: BOOLEAN_TOK
        	    {
        	         MATCHT(BOOLEAN_TOK, &FOLLOW_BOOLEAN_TOK_in_restrictedTypePossiblyFunctionLHS4097);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             t = EXPR_MANAGER->booleanType(); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1324:5: REAL_TOK
        	    {
        	         MATCHT(REAL_TOK, &FOLLOW_REAL_TOK_in_restrictedTypePossiblyFunctionLHS4105);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             t = EXPR_MANAGER->realType(); 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1325:5: INT_TOK
        	    {
        	         MATCHT(INT_TOK, &FOLLOW_INT_TOK_in_restrictedTypePossiblyFunctionLHS4113);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             t = EXPR_MANAGER->integerType(); 
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1330:5: LPAREN type[t,check] ( COMMA type[t,check] )* RPAREN
        	    {
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_restrictedTypePossiblyFunctionLHS4128);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4130);
        	        type(ctx, t, check);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             types.push_back(t); 
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1331:5: ( COMMA type[t,check] )*

        	        for (;;)
        	        {
        	            int alt50=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt50=1;
        	            	}
        	                break;

        	            }

        	            switch (alt50)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1331:7: COMMA type[t,check]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_restrictedTypePossiblyFunctionLHS4141);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_type_in_restrictedTypePossiblyFunctionLHS4143);
        	        	        type(ctx, t, check);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             lhs = true; types.push_back(t); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop50;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop50: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_restrictedTypePossiblyFunctionLHS4151);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerestrictedTypePossiblyFunctionLHSEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             if(lhs) { t = EXPR_MANAGER->mkTupleType(types); }
        	                  // if !lhs, t is already set up correctly, nothing to do..
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulerestrictedTypePossiblyFunctionLHSEx; /* Prevent compiler warnings */
    rulerestrictedTypePossiblyFunctionLHSEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end restrictedTypePossiblyFunctionLHS */

/**
 * $ANTLR start parameterization
 * ../../../../../../src/parser/cvc/Cvc.g:1337:1: parameterization[CVC4::parser::DeclarationCheck check,\n std::vector<CVC4::Type>& params] : LBRACKET restrictedType[t,check] ( COMMA restrictedType[t,check] )* RBRACKET ;
 */
static void
parameterization(pCvcParser ctx, CVC4::parser::DeclarationCheck check, std::vector<CVC4::Type>& params)
{
    /* Initialize rule variables
     */


      Type t;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1342:3: ( LBRACKET restrictedType[t,check] ( COMMA restrictedType[t,check] )* RBRACKET )
        // ../../../../../../src/parser/cvc/Cvc.g:1342:5: LBRACKET restrictedType[t,check] ( COMMA restrictedType[t,check] )* RBRACKET
        {
             MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_parameterization4176);
            if  (HASEXCEPTION())
            {
                goto ruleparameterizationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_restrictedType_in_parameterization4178);
            restrictedType(ctx, t, check);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameterizationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 Debug("parser-param") << "t = " << t << std::endl; params.push_back( t ); 
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1343:5: ( COMMA restrictedType[t,check] )*

            for (;;)
            {
                int alt52=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt52=1;
                	}
                    break;

                }

                switch (alt52)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1343:7: COMMA restrictedType[t,check]
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_parameterization4189);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameterizationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_restrictedType_in_parameterization4191);
            	        restrictedType(ctx, t, check);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameterizationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             Debug("parser-param") << "t = " << t << std::endl; params.push_back( t ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop52;	/* break out of the loop */
            	    break;
                }
            }
            loop52: ; /* Jump out to here if this rule does not match */


             MATCHT(RBRACKET, &FOLLOW_RBRACKET_in_parameterization4199);
            if  (HASEXCEPTION())
            {
                goto ruleparameterizationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparameterizationEx; /* Prevent compiler warnings */
    ruleparameterizationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parameterization */

/**
 * $ANTLR start bound
 * ../../../../../../src/parser/cvc/Cvc.g:1346:1: bound returns [CVC4::parser::cvc::mySubrangeBound bound] : ( UNDERSCORE |k= integer );
 */
static CVC4::parser::cvc::mySubrangeBound
bound(pCvcParser ctx)
{
    CVC4::parser::cvc::mySubrangeBound bound;


    CVC4::Rational k;
    #undef	RETURN_TYPE_k
    #define	RETURN_TYPE_k CVC4::Rational

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1347:3: ( UNDERSCORE |k= integer )

            ANTLR3_UINT32 alt53;

            alt53=2;

            switch ( LA(1) )
            {
            case UNDERSCORE:
            	{
            		alt53=1;
            	}
                break;
            case INTEGER_LITERAL:
            case MINUS_TOK:
            	{
            		alt53=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return bound;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 53;
                EXCEPTION->state        = 0;


                goto ruleboundEx;

            }

            switch (alt53)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1347:5: UNDERSCORE
        	    {
        	         MATCHT(UNDERSCORE, &FOLLOW_UNDERSCORE_in_bound4216);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboundEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return bound;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             bound= SubrangeBound();
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1348:5: k= integer
        	    {
        	        FOLLOWPUSH(FOLLOW_integer_in_bound4226);
        	        k=integer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleboundEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return bound;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             bound= SubrangeBound(k.getNumerator());
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleboundEx; /* Prevent compiler warnings */
    ruleboundEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return bound;
}
/* $ANTLR end bound */

/**
 * $ANTLR start typeLetDecl
 * ../../../../../../src/parser/cvc/Cvc.g:1351:1: typeLetDecl[CVC4::parser::DeclarationCheck check] : identifier[id,CHECK_NONE,SYM_SORT] ( COLON TYPE_TOK )? EQUAL_TOK restrictedType[t,check] ;
 */
static void
typeLetDecl(pCvcParser ctx, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */


      Type t;
      std::string id;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1356:3: ( identifier[id,CHECK_NONE,SYM_SORT] ( COLON TYPE_TOK )? EQUAL_TOK restrictedType[t,check] )
        // ../../../../../../src/parser/cvc/Cvc.g:1356:5: identifier[id,CHECK_NONE,SYM_SORT] ( COLON TYPE_TOK )? EQUAL_TOK restrictedType[t,check]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_typeLetDecl4245);
            identifier(ctx, id, CHECK_NONE, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeLetDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1356:40: ( COLON TYPE_TOK )?
            {
                int alt54=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt54=1;
                    	}
                        break;
                }

                switch (alt54)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1356:41: COLON TYPE_TOK
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_typeLetDecl4249);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeLetDeclEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(TYPE_TOK, &FOLLOW_TYPE_TOK_in_typeLetDecl4251);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeLetDeclEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_typeLetDecl4255);
            if  (HASEXCEPTION())
            {
                goto ruletypeLetDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_restrictedType_in_typeLetDecl4257);
            restrictedType(ctx, t, check);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeLetDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 PARSER_STATE->defineType(id, t); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletypeLetDeclEx; /* Prevent compiler warnings */
    ruletypeLetDeclEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end typeLetDecl */

/**
 * $ANTLR start formula
 * ../../../../../../src/parser/cvc/Cvc.g:1367:1: formula[CVC4::Expr& f] : n= nots ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? ) ;
 */
static void
formula(pCvcParser ctx, CVC4::Expr& f)
{
    size_t n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n size_t

    /* Initialize rule variables
     */


      Debug("parser-extra") << "formula: " << AntlrInput::tokenText(LT(1)) << std::endl;
      Expr f2;
      std::vector<CVC4::Expr> expressions;
      std::vector<unsigned> operators;
      unsigned op;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1375:3: (n= nots ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? ) )
        // ../../../../../../src/parser/cvc/Cvc.g:1375:5: n= nots ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? )
        {
            FOLLOWPUSH(FOLLOW_nots_in_formula4287);
            n=nots(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleformulaEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1376:5: ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? )
            {
                int alt56=2;
                switch ( LA(1) )
                {
                case EXISTS_TOK:
                case FORALL_TOK:
                case LAMBDA:
                case LET_TOK:
                	{
                		alt56=1;
                	}
                    break;
                case ABS_TOK:
                case ARRAY_TOK:
                case BAR:
                case BINARY_LITERAL:
                case BVASHR_TOK:
                case BVCOMP_TOK:
                case BVGE_TOK:
                case BVGT_TOK:
                case BVLE_TOK:
                case BVLSHR_TOK:
                case BVLT_TOK:
                case BVMULT_TOK:
                case BVNAND_TOK:
                case BVNEG_TOK:
                case BVNOR_TOK:
                case BVPLUS_TOK:
                case BVREPEAT_TOK:
                case BVROTL_TOK:
                case BVROTR_TOK:
                case BVSDIV_TOK:
                case BVSGE_TOK:
                case BVSGT_TOK:
                case BVSHL_TOK:
                case BVSLE_TOK:
                case BVSLT_TOK:
                case BVSMOD_TOK:
                case BVSREM_TOK:
                case BVSUB_TOK:
                case BVUDIV_TOK:
                case BVUMINUS_TOK:
                case BVUREM_TOK:
                case BVXNOR_TOK:
                case BVXOR_TOK:
                case BVZEROEXTEND_TOK:
                case DECIMAL_LITERAL:
                case DISTINCT_TOK:
                case DIVISIBLE_TOK:
                case FALSE_TOK:
                case FLOOR_TOK:
                case HEX_LITERAL:
                case IDENTIFIER:
                case IF_TOK:
                case INTEGER_LITERAL:
                case IS_INTEGER_TOK:
                case LBRACE:
                case LPAREN:
                case MINUS_TOK:
                case NOT_TOK:
                case PARENHASH:
                case SETS_CARD_TOK:
                case STRING_CONCAT_TOK:
                case STRING_CONTAINS_TOK:
                case STRING_INDEXOF_TOK:
                case STRING_ITOS_TOK:
                case STRING_LENGTH_TOK:
                case STRING_LITERAL:
                case STRING_PREFIXOF_TOK:
                case STRING_REPLACE_TOK:
                case STRING_STOI_TOK:
                case STRING_STOU16_TOK:
                case STRING_STOU32_TOK:
                case STRING_SUBSTR_TOK:
                case STRING_SUFFIXOF_TOK:
                case STRING_U16TOS_TOK:
                case STRING_U32TOS_TOK:
                case SX_TOK:
                case TRANSCLOSURE_TOK:
                case TRANSPOSE_TOK:
                case TRUE_TOK:
                case TUPLE_TOK:
                case UNIVSET_TOK:
                	{
                		alt56=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 56;
                    EXCEPTION->state        = 0;


                    goto ruleformulaEx;

                }

                switch (alt56)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1376:7: prefixFormula[f]
            	    {
            	        FOLLOWPUSH(FOLLOW_prefixFormula_in_formula4295);
            	        prefixFormula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleformulaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = addNots(EXPR_MANAGER, n, f); 
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1378:7: comparison[f] ( morecomparisons[expressions,operators] )?
            	    {
            	        FOLLOWPUSH(FOLLOW_comparison_in_formula4312);
            	        comparison(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleformulaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = addNots(EXPR_MANAGER, n, f);
            	                    expressions.push_back(f);
            	                  
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:1382:7: ( morecomparisons[expressions,operators] )?
            	        {
            	            int alt55=2;
            	            switch ( LA(1) )
            	            {
            	                case AND_TOK:
            	                case IFF_TOK:
            	                case IMPLIES_TOK:
            	                case JOIN_TOK:
            	                case OR_TOK:
            	                case PRODUCT_TOK:
            	                case XOR_TOK:
            	                	{
            	                		alt55=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt55)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1382:7: morecomparisons[expressions,operators]
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_morecomparisons_in_formula4329);
            	        	        morecomparisons(ctx, expressions, operators);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleformulaEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        if ( BACKTRACKING==0 )
            	        {
            	             f = createPrecedenceTree(PARSER_STATE, EXPR_MANAGER, expressions, operators); 
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleformulaEx; /* Prevent compiler warnings */
    ruleformulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end formula */

/**
 * $ANTLR start morecomparisons
 * ../../../../../../src/parser/cvc/Cvc.g:1387:1: morecomparisons[std::vector<CVC4::Expr>& expressions,\n std::vector<unsigned>& operators] returns [size_t i = 0] : booleanBinop[op] n= nots ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? ) ;
 */
static size_t
morecomparisons(pCvcParser ctx, std::vector<CVC4::Expr>& expressions, std::vector<unsigned>& operators)
{
    size_t i;


    size_t n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n size_t

    /* Initialize rule variables
     */
    i =  0;



      unsigned op;
      Expr f;
      i= expressions.size();


    {
        // ../../../../../../src/parser/cvc/Cvc.g:1394:3: ( booleanBinop[op] n= nots ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? ) )
        // ../../../../../../src/parser/cvc/Cvc.g:1394:5: booleanBinop[op] n= nots ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? )
        {
            FOLLOWPUSH(FOLLOW_booleanBinop_in_morecomparisons4368);
            booleanBinop(ctx, op);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemorecomparisonsEx;
            }
            if (HASFAILED())
            {
                return i;
            }


            if ( BACKTRACKING==0 )
            {
                 operators.push_back(op); 
            }


            FOLLOWPUSH(FOLLOW_nots_in_morecomparisons4379);
            n=nots(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemorecomparisonsEx;
            }
            if (HASFAILED())
            {
                return i;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1396:5: ( prefixFormula[f] | comparison[f] ( morecomparisons[expressions,operators] )? )
            {
                int alt58=2;
                switch ( LA(1) )
                {
                case EXISTS_TOK:
                case FORALL_TOK:
                case LAMBDA:
                case LET_TOK:
                	{
                		alt58=1;
                	}
                    break;
                case ABS_TOK:
                case ARRAY_TOK:
                case BAR:
                case BINARY_LITERAL:
                case BVASHR_TOK:
                case BVCOMP_TOK:
                case BVGE_TOK:
                case BVGT_TOK:
                case BVLE_TOK:
                case BVLSHR_TOK:
                case BVLT_TOK:
                case BVMULT_TOK:
                case BVNAND_TOK:
                case BVNEG_TOK:
                case BVNOR_TOK:
                case BVPLUS_TOK:
                case BVREPEAT_TOK:
                case BVROTL_TOK:
                case BVROTR_TOK:
                case BVSDIV_TOK:
                case BVSGE_TOK:
                case BVSGT_TOK:
                case BVSHL_TOK:
                case BVSLE_TOK:
                case BVSLT_TOK:
                case BVSMOD_TOK:
                case BVSREM_TOK:
                case BVSUB_TOK:
                case BVUDIV_TOK:
                case BVUMINUS_TOK:
                case BVUREM_TOK:
                case BVXNOR_TOK:
                case BVXOR_TOK:
                case BVZEROEXTEND_TOK:
                case DECIMAL_LITERAL:
                case DISTINCT_TOK:
                case DIVISIBLE_TOK:
                case FALSE_TOK:
                case FLOOR_TOK:
                case HEX_LITERAL:
                case IDENTIFIER:
                case IF_TOK:
                case INTEGER_LITERAL:
                case IS_INTEGER_TOK:
                case LBRACE:
                case LPAREN:
                case MINUS_TOK:
                case NOT_TOK:
                case PARENHASH:
                case SETS_CARD_TOK:
                case STRING_CONCAT_TOK:
                case STRING_CONTAINS_TOK:
                case STRING_INDEXOF_TOK:
                case STRING_ITOS_TOK:
                case STRING_LENGTH_TOK:
                case STRING_LITERAL:
                case STRING_PREFIXOF_TOK:
                case STRING_REPLACE_TOK:
                case STRING_STOI_TOK:
                case STRING_STOU16_TOK:
                case STRING_STOU32_TOK:
                case STRING_SUBSTR_TOK:
                case STRING_SUFFIXOF_TOK:
                case STRING_U16TOS_TOK:
                case STRING_U32TOS_TOK:
                case SX_TOK:
                case TRANSCLOSURE_TOK:
                case TRANSPOSE_TOK:
                case TRUE_TOK:
                case TUPLE_TOK:
                case UNIVSET_TOK:
                	{
                		alt58=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return i;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 58;
                    EXCEPTION->state        = 0;


                    goto rulemorecomparisonsEx;

                }

                switch (alt58)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1396:7: prefixFormula[f]
            	    {
            	        FOLLOWPUSH(FOLLOW_prefixFormula_in_morecomparisons4387);
            	        prefixFormula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemorecomparisonsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return i;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             expressions.push_back(addNots(EXPR_MANAGER, n, f)); 
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1398:7: comparison[f] ( morecomparisons[expressions,operators] )?
            	    {
            	        FOLLOWPUSH(FOLLOW_comparison_in_morecomparisons4404);
            	        comparison(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemorecomparisonsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return i;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = addNots(EXPR_MANAGER, n, f);
            	                    expressions.push_back(f);
            	                  
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:1402:7: ( morecomparisons[expressions,operators] )?
            	        {
            	            int alt57=2;
            	            switch ( LA(1) )
            	            {
            	                case AND_TOK:
            	                case IFF_TOK:
            	                case IMPLIES_TOK:
            	                case JOIN_TOK:
            	                case OR_TOK:
            	                case PRODUCT_TOK:
            	                case XOR_TOK:
            	                	{
            	                		alt57=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt57)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1402:7: morecomparisons[expressions,operators]
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_morecomparisons_in_morecomparisons4421);
            	        	        morecomparisons(ctx, expressions, operators);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemorecomparisonsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return i;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulemorecomparisonsEx; /* Prevent compiler warnings */
    rulemorecomparisonsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return i;
}
/* $ANTLR end morecomparisons */

/**
 * $ANTLR start nots
 * ../../../../../../src/parser/cvc/Cvc.g:1407:1: nots returns [size_t n = 0] : ( NOT_TOK )* ;
 */
static size_t
nots(pCvcParser ctx)
{
    size_t n;


    /* Initialize rule variables
     */
    n =  0;


    {
        // ../../../../../../src/parser/cvc/Cvc.g:1408:3: ( ( NOT_TOK )* )
        // ../../../../../../src/parser/cvc/Cvc.g:1408:5: ( NOT_TOK )*
        {
            // ../../../../../../src/parser/cvc/Cvc.g:1408:5: ( NOT_TOK )*

            for (;;)
            {
                int alt59=2;
                switch ( LA(1) )
                {
                case NOT_TOK:
                	{
                		switch ( LA(2) )
                		{
                		case BVNEG_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case BVNEG_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case NOT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSPOSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSCLOSURE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TUPLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNAND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVCOMP_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUMINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVPLUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSUB_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVMULT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSMOD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSHL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVASHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLSHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case SX_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVZEROEXTEND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVREPEAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONCAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LENGTH_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONTAINS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUBSTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_INDEXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_REPLACE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_PREFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUFFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOI_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_ITOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U16TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU16_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U32TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU32_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case SETS_CARD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case PARENHASH:
                					{
                						alt59=1;
                					}
                				    break;
                				case LBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case UNIVSET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;
                				case ARRAY_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRUE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FALSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DECIMAL_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case INTEGER_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case HEX_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case BINARY_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case IDENTIFIER:
                					{
                						alt59=1;
                					}
                				    break;
                				case FLOOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IS_INTEGER_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case ABS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DIVISIBLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DISTINCT_TOK:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case NOT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case BVNEG_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case NOT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSPOSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSCLOSURE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TUPLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNAND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVCOMP_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUMINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVPLUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSUB_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVMULT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSMOD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSHL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVASHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLSHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case SX_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVZEROEXTEND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVREPEAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONCAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LENGTH_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONTAINS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUBSTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_INDEXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_REPLACE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_PREFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUFFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOI_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_ITOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U16TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU16_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U32TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU32_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case SETS_CARD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case PARENHASH:
                					{
                						alt59=1;
                					}
                				    break;
                				case LBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case UNIVSET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;
                				case ARRAY_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRUE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FALSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DECIMAL_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case INTEGER_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case HEX_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case BINARY_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case EXISTS_TOK:
                				case FORALL_TOK:
                				case IDENTIFIER:
                				case LAMBDA:
                				case LET_TOK:
                				case MINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FLOOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IS_INTEGER_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case ABS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DIVISIBLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DISTINCT_TOK:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case TRANSPOSE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case BVNEG_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case NOT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSPOSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSCLOSURE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TUPLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNAND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVCOMP_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUMINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVPLUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSUB_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVMULT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSMOD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSHL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVASHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLSHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case SX_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVZEROEXTEND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVREPEAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONCAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LENGTH_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONTAINS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUBSTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_INDEXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_REPLACE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_PREFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUFFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOI_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_ITOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U16TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU16_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U32TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU32_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case SETS_CARD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case PARENHASH:
                					{
                						alt59=1;
                					}
                				    break;
                				case LBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case UNIVSET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;
                				case ARRAY_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRUE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FALSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DECIMAL_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case INTEGER_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case HEX_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case BINARY_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case IDENTIFIER:
                					{
                						alt59=1;
                					}
                				    break;
                				case FLOOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IS_INTEGER_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case ABS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DIVISIBLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DISTINCT_TOK:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case TRANSCLOSURE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case BVNEG_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case NOT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSPOSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSCLOSURE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TUPLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNAND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVCOMP_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUMINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVPLUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSUB_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVMULT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSMOD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSHL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVASHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLSHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case SX_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVZEROEXTEND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVREPEAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONCAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LENGTH_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONTAINS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUBSTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_INDEXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_REPLACE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_PREFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUFFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOI_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_ITOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U16TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU16_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U32TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU32_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case SETS_CARD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case PARENHASH:
                					{
                						alt59=1;
                					}
                				    break;
                				case LBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case UNIVSET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;
                				case ARRAY_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRUE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FALSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DECIMAL_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case INTEGER_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case HEX_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case BINARY_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case IDENTIFIER:
                					{
                						alt59=1;
                					}
                				    break;
                				case FLOOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IS_INTEGER_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case ABS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DIVISIBLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DISTINCT_TOK:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case TUPLE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVXOR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVNAND_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVNOR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVCOMP_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVXNOR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVUMINUS_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVPLUS_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSUB_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVMULT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVUDIV_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSDIV_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVUREM_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSREM_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSMOD_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSHL_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVASHR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVLSHR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case SX_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVZEROEXTEND_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVREPEAT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVROTR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVROTL_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVLT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVLE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVGT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVGE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSLT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSLE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSGT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case BVSGE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_CONCAT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_LENGTH_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_CONTAINS_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_SUBSTR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_INDEXOF_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_REPLACE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_PREFIXOF_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_SUFFIXOF_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_STOI_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_ITOS_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_U16TOS_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_STOU16_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_U32TOS_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_STOU32_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case STRING_LITERAL:
                			{
                				alt59=1;
                			}
                		    break;
                		case SETS_CARD_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case IF_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case NOT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FORALL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case EXISTS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LAMBDA:
                					{
                						alt59=1;
                					}
                				    break;
                				case MINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNEG_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSPOSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSCLOSURE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TUPLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNAND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVCOMP_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUMINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVPLUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSUB_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVMULT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSMOD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSHL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVASHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLSHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case SX_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVZEROEXTEND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVREPEAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONCAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LENGTH_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONTAINS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUBSTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_INDEXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_REPLACE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_PREFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUFFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOI_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_ITOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U16TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU16_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U32TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU32_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case SETS_CARD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case PARENHASH:
                					{
                						alt59=1;
                					}
                				    break;
                				case LBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case UNIVSET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;
                				case ARRAY_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRUE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FALSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DECIMAL_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case INTEGER_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case HEX_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case BINARY_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case IDENTIFIER:
                					{
                						alt59=1;
                					}
                				    break;
                				case FLOOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IS_INTEGER_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case ABS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DIVISIBLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DISTINCT_TOK:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case LPAREN:
                			{
                				switch ( LA(3) )
                				{
                				case RPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case NOT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FORALL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case EXISTS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LAMBDA:
                					{
                						alt59=1;
                					}
                				    break;
                				case MINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNEG_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSPOSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSCLOSURE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TUPLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNAND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVCOMP_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUMINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVPLUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSUB_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVMULT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSMOD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSHL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVASHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLSHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case SX_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVZEROEXTEND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVREPEAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONCAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LENGTH_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONTAINS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUBSTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_INDEXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_REPLACE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_PREFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUFFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOI_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_ITOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U16TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU16_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U32TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU32_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case SETS_CARD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case PARENHASH:
                					{
                						alt59=1;
                					}
                				    break;
                				case LBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case UNIVSET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;
                				case ARRAY_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRUE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FALSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DECIMAL_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case INTEGER_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case HEX_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case BINARY_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case IDENTIFIER:
                					{
                						alt59=1;
                					}
                				    break;
                				case FLOOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IS_INTEGER_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case ABS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DIVISIBLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DISTINCT_TOK:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case PARENHASH:
                			{
                				switch ( LA(3) )
                				{
                				case HASHPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case IDENTIFIER:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case LBRACE:
                			{
                				switch ( LA(3) )
                				{
                				case RBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case NOT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FORALL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case EXISTS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LAMBDA:
                					{
                						alt59=1;
                					}
                				    break;
                				case MINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNEG_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSPOSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRANSCLOSURE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TUPLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNAND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVCOMP_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVXNOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUMINUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVPLUS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSUB_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVMULT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSDIV_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVUREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSREM_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSMOD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSHL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVASHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLSHR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case SX_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVZEROEXTEND_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVREPEAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVROTL_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BVSGE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONCAT_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LENGTH_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_CONTAINS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUBSTR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_INDEXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_REPLACE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_PREFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_SUFFIXOF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOI_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_ITOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U16TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU16_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_U32TOS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_STOU32_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case STRING_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case SETS_CARD_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IF_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;
                				case PARENHASH:
                					{
                						alt59=1;
                					}
                				    break;
                				case LBRACE:
                					{
                						alt59=1;
                					}
                				    break;
                				case UNIVSET_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;
                				case ARRAY_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case TRUE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case FALSE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DECIMAL_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case INTEGER_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case HEX_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case BINARY_LITERAL:
                					{
                						alt59=1;
                					}
                				    break;
                				case IDENTIFIER:
                					{
                						alt59=1;
                					}
                				    break;
                				case FLOOR_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case IS_INTEGER_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case ABS_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DIVISIBLE_TOK:
                					{
                						alt59=1;
                					}
                				    break;
                				case DISTINCT_TOK:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case UNIVSET_TOK:
                			{
                				alt59=1;
                			}
                		    break;
                		case BAR:
                			{
                				switch ( LA(3) )
                				{
                				case BAR:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case ARRAY_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case TRUE_TOK:
                			{
                				alt59=1;
                			}
                		    break;
                		case FALSE_TOK:
                			{
                				alt59=1;
                			}
                		    break;
                		case DECIMAL_LITERAL:
                			{
                				alt59=1;
                			}
                		    break;
                		case INTEGER_LITERAL:
                			{
                				alt59=1;
                			}
                		    break;
                		case HEX_LITERAL:
                			{
                				alt59=1;
                			}
                		    break;
                		case BINARY_LITERAL:
                			{
                				alt59=1;
                			}
                		    break;
                		case EXISTS_TOK:
                		case FORALL_TOK:
                		case IDENTIFIER:
                		case LAMBDA:
                		case LET_TOK:
                		case MINUS_TOK:
                			{
                				alt59=1;
                			}
                		    break;
                		case FLOOR_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case IS_INTEGER_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case ABS_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case DIVISIBLE_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case DISTINCT_TOK:
                			{
                				switch ( LA(3) )
                				{
                				case LPAREN:
                					{
                						alt59=1;
                					}
                				    break;

                				}

                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt59)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1408:7: NOT_TOK
            	    {
            	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_nots4450);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenotsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return n;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             ++n
            	            ; 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop59;	/* break out of the loop */
            	    break;
                }
            }
            loop59: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenotsEx; /* Prevent compiler warnings */
    rulenotsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return n;
}
/* $ANTLR end nots */

/**
 * $ANTLR start prefixFormula
 * ../../../../../../src/parser/cvc/Cvc.g:1411:1: prefixFormula[CVC4::Expr& f] : ( ( FORALL_TOK | EXISTS_TOK ) LPAREN boundVarDecl[ids,t] ( COMMA boundVarDecl[ids,t] )* RPAREN COLON ( instantiationPatterns[ipl] )? formula[f] | LET_TOK letDecl ( COMMA letDecl )* IN_TOK formula[f] | LAMBDA LPAREN boundVarDeclsReturn[terms,types] RPAREN COLON formula[f] );
 */
static void
prefixFormula(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      std::vector<std::string> ids;
      std::vector<Expr> terms;
      std::vector<Type> types;
      std::vector<Expr> bvs;
      Type t;
      Kind k;
      Expr ipl;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1422:3: ( ( FORALL_TOK | EXISTS_TOK ) LPAREN boundVarDecl[ids,t] ( COMMA boundVarDecl[ids,t] )* RPAREN COLON ( instantiationPatterns[ipl] )? formula[f] | LET_TOK letDecl ( COMMA letDecl )* IN_TOK formula[f] | LAMBDA LPAREN boundVarDeclsReturn[terms,types] RPAREN COLON formula[f] )

            ANTLR3_UINT32 alt64;

            alt64=3;

            switch ( LA(1) )
            {
            case EXISTS_TOK:
            case FORALL_TOK:
            	{
            		alt64=1;
            	}
                break;
            case LET_TOK:
            	{
            		alt64=2;
            	}
                break;
            case LAMBDA:
            	{
            		alt64=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 64;
                EXCEPTION->state        = 0;


                goto ruleprefixFormulaEx;

            }

            switch (alt64)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1422:5: ( FORALL_TOK | EXISTS_TOK ) LPAREN boundVarDecl[ids,t] ( COMMA boundVarDecl[ids,t] )* RPAREN COLON ( instantiationPatterns[ipl] )? formula[f]
        	    {
        	        // ../../../../../../src/parser/cvc/Cvc.g:1422:5: ( FORALL_TOK | EXISTS_TOK )
        	        {
        	            int alt60=2;
        	            switch ( LA(1) )
        	            {
        	            case FORALL_TOK:
        	            	{
        	            		alt60=1;
        	            	}
        	                break;
        	            case EXISTS_TOK:
        	            	{
        	            		alt60=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 60;
        	                EXCEPTION->state        = 0;


        	                goto ruleprefixFormulaEx;

        	            }

        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1422:7: FORALL_TOK
        	        	    {
        	        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_prefixFormula4482);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprefixFormulaEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             k = kind::FORALL; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1422:42: EXISTS_TOK
        	        	    {
        	        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_prefixFormula4488);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprefixFormulaEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             k = kind::EXISTS; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_prefixFormula4500);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_boundVarDecl_in_prefixFormula4506);
        	        boundVarDecl(ctx, ids, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             for(std::vector<std::string>::const_iterator i = ids.begin(); i != ids.end(); ++i) {
        	                    bvs.push_back(PARSER_STATE->mkBoundVar(*i, t));
        	                  }
        	                  ids.clear();
        	                
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1430:5: ( COMMA boundVarDecl[ids,t] )*

        	        for (;;)
        	        {
        	            int alt61=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt61=1;
        	            	}
        	                break;

        	            }

        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1430:7: COMMA boundVarDecl[ids,t]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_prefixFormula4521);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprefixFormulaEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_boundVarDecl_in_prefixFormula4523);
        	        	        boundVarDecl(ctx, ids, t);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprefixFormulaEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {

        	        	                    for(std::vector<std::string>::const_iterator i = ids.begin(); i != ids.end(); ++i) {
        	        	                      bvs.push_back(PARSER_STATE->mkBoundVar(*i, t));
        	        	                    }
        	        	                    ids.clear();
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop61;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop61: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_prefixFormula4541);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                  terms.push_back( EXPR_MANAGER->mkExpr( kind::BOUND_VAR_LIST, bvs ) ); 
        	        }


        	         MATCHT(COLON, &FOLLOW_COLON_in_prefixFormula4549);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1439:11: ( instantiationPatterns[ipl] )?
        	        {
        	            int alt62=2;
        	            switch ( LA(1) )
        	            {
        	                case PATTERN_TOK:
        	                	{
        	                		alt62=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt62)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1439:11: instantiationPatterns[ipl]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_instantiationPatterns_in_prefixFormula4551);
        	        	        instantiationPatterns(ctx, ipl);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprefixFormulaEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_formula_in_prefixFormula4555);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->popScope();
        	                  terms.push_back(f);
        	                  if(! ipl.isNull()) {
        	                    terms.push_back(ipl);
        	                  }
        	                  f = MK_EXPR(k, terms);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1451:5: LET_TOK letDecl ( COMMA letDecl )* IN_TOK formula[f]
        	    {
        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_prefixFormula4574);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_letDecl_in_prefixFormula4582);
        	        letDecl(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1452:13: ( COMMA letDecl )*

        	        for (;;)
        	        {
        	            int alt63=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt63=1;
        	            	}
        	                break;

        	            }

        	            switch (alt63)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1452:15: COMMA letDecl
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_prefixFormula4586);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprefixFormulaEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_letDecl_in_prefixFormula4588);
        	        	        letDecl(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprefixFormulaEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop63;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop63: ; /* Jump out to here if this rule does not match */


        	         MATCHT(IN_TOK, &FOLLOW_IN_TOK_in_prefixFormula4597);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_prefixFormula4599);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1456:5: LAMBDA LPAREN boundVarDeclsReturn[terms,types] RPAREN COLON formula[f]
        	    {
        	         MATCHT(LAMBDA, &FOLLOW_LAMBDA_in_prefixFormula4614);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_prefixFormula4618);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_boundVarDeclsReturn_in_prefixFormula4624);
        	        boundVarDeclsReturn(ctx, terms, types);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_prefixFormula4631);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COLON, &FOLLOW_COLON_in_prefixFormula4633);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_prefixFormula4635);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprefixFormulaEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             PARSER_STATE->popScope();
        	                  Type t = EXPR_MANAGER->mkFunctionType(types, f.getType());
        	                  std::string name = "lambda";
        	                  Expr func = PARSER_STATE->mkAnonymousFunction(name, t, ExprManager::VAR_FLAG_DEFINED);
        	                  Command* cmd = new DefineFunctionCommand(name, func, terms, f);
        	                  PARSER_STATE->preemptCommand(cmd);
        	                  f = func;
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleprefixFormulaEx; /* Prevent compiler warnings */
    ruleprefixFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end prefixFormula */

/**
 * $ANTLR start instantiationPatterns
 * ../../../../../../src/parser/cvc/Cvc.g:1469:1: instantiationPatterns[ CVC4::Expr& expr ] : ( PATTERN_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN COLON )+ ;
 */
static void
instantiationPatterns(pCvcParser ctx, CVC4::Expr& expr)
{
    /* Initialize rule variables
     */


      std::vector<Expr> args;
      Expr f;
      std::vector<Expr> patterns;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1475:3: ( ( PATTERN_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN COLON )+ )
        // ../../../../../../src/parser/cvc/Cvc.g:1475:5: ( PATTERN_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN COLON )+
        {
            // ../../../../../../src/parser/cvc/Cvc.g:1475:5: ( PATTERN_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN COLON )+
            {
                int cnt66=0;

                for (;;)
                {
                    int alt66=2;
            	switch ( LA(1) )
            	{
            	case PATTERN_TOK:
            		{
            			alt66=1;
            		}
            	    break;

            	}

            	switch (alt66)
            	{
            	    case 1:
            	        // ../../../../../../src/parser/cvc/Cvc.g:1475:7: PATTERN_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN COLON
            	        {
            	             MATCHT(PATTERN_TOK, &FOLLOW_PATTERN_TOK_in_instantiationPatterns4663);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleinstantiationPatternsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	             MATCHT(LPAREN, &FOLLOW_LPAREN_in_instantiationPatterns4665);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleinstantiationPatternsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	            FOLLOWPUSH(FOLLOW_formula_in_instantiationPatterns4667);
            	            formula(ctx, f);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleinstantiationPatternsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {
            	                 args.push_back( f ); 
            	            }


            	            // ../../../../../../src/parser/cvc/Cvc.g:1475:62: ( COMMA formula[f] )*

            	            for (;;)
            	            {
            	                int alt65=2;
            	                switch ( LA(1) )
            	                {
            	                case COMMA:
            	                	{
            	                		alt65=1;
            	                	}
            	                    break;

            	                }

            	                switch (alt65)
            	                {
            	            	case 1:
            	            	    // ../../../../../../src/parser/cvc/Cvc.g:1475:63: COMMA formula[f]
            	            	    {
            	            	         MATCHT(COMMA, &FOLLOW_COMMA_in_instantiationPatterns4673);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleinstantiationPatternsEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            return ;
            	            	        }


            	            	        FOLLOWPUSH(FOLLOW_formula_in_instantiationPatterns4675);
            	            	        formula(ctx, f);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleinstantiationPatternsEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            return ;
            	            	        }


            	            	        if ( BACKTRACKING==0 )
            	            	        {
            	            	             args.push_back( f ); 
            	            	        }


            	            	    }
            	            	    break;

            	            	default:
            	            	    goto loop65;	/* break out of the loop */
            	            	    break;
            	                }
            	            }
            	            loop65: ; /* Jump out to here if this rule does not match */


            	             MATCHT(RPAREN, &FOLLOW_RPAREN_in_instantiationPatterns4683);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleinstantiationPatternsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	             MATCHT(COLON, &FOLLOW_COLON_in_instantiationPatterns4685);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleinstantiationPatternsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {
            	                 patterns.push_back( EXPR_MANAGER->mkExpr( kind::INST_PATTERN, args ) );
            	                        args.clear();
            	                      
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt66 >= 1 )
            		{
            		    goto loop66;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleinstantiationPatternsEx;
            	}
            	cnt66++;
                }
                loop66: ;	/* Jump to here if this rule does not match */
            }

            if ( BACKTRACKING==0 )
            {
                 if(! patterns.empty()) {
                       expr = EXPR_MANAGER->mkExpr( kind::INST_PATTERN_LIST, patterns );
                       }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinstantiationPatternsEx; /* Prevent compiler warnings */
    ruleinstantiationPatternsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end instantiationPatterns */

/**
 * $ANTLR start letDecl
 * ../../../../../../src/parser/cvc/Cvc.g:1488:1: letDecl : identifier[name,CHECK_NONE,SYM_VARIABLE] EQUAL_TOK formula[e] ;
 */
static void
letDecl(pCvcParser ctx)
{
    /* Initialize rule variables
     */


      Expr e;
      std::string name;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1493:3: ( identifier[name,CHECK_NONE,SYM_VARIABLE] EQUAL_TOK formula[e] )
        // ../../../../../../src/parser/cvc/Cvc.g:1493:5: identifier[name,CHECK_NONE,SYM_VARIABLE] EQUAL_TOK formula[e]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_letDecl4722);
            identifier(ctx, name, CHECK_NONE, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleletDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_letDecl4725);
            if  (HASEXCEPTION())
            {
                goto ruleletDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_formula_in_letDecl4727);
            formula(ctx, e);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleletDeclEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 Debug("parser") << language::SetLanguage(language::output::LANG_CVC4) << e.getType() << std::endl;
                      PARSER_STATE->defineVar(name, e);
                      Debug("parser") << "LET[" << PARSER_STATE->scopeLevel() << "]: "
                                      << name << std::endl
                                      << " ==>" << " " << e << std::endl;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleletDeclEx; /* Prevent compiler warnings */
    ruleletDeclEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end letDecl */

/**
 * $ANTLR start booleanBinop
 * ../../../../../../src/parser/cvc/Cvc.g:1502:1: booleanBinop[unsigned& op] : ( IFF_TOK | IMPLIES_TOK | OR_TOK | XOR_TOK | AND_TOK | JOIN_TOK | PRODUCT_TOK );
 */
static void
booleanBinop(pCvcParser ctx, unsigned& op)
{
    /* Initialize rule variables
     */


      op = LT(1)->getType(LT(1));

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1506:3: ( IFF_TOK | IMPLIES_TOK | OR_TOK | XOR_TOK | AND_TOK | JOIN_TOK | PRODUCT_TOK )
        // ../../../../../../src/parser/cvc/Cvc.g:
        {
            if ( LA(1) == AND_TOK || LA(1) == IFF_TOK || LA(1) == IMPLIES_TOK || LA(1) == JOIN_TOK || LA(1) == OR_TOK || LA(1) == PRODUCT_TOK || LA(1) == XOR_TOK )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulebooleanBinopEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebooleanBinopEx; /* Prevent compiler warnings */
    rulebooleanBinopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end booleanBinop */

/**
 * $ANTLR start comparison
 * ../../../../../../src/parser/cvc/Cvc.g:1515:1: comparison[CVC4::Expr& f] : term[f] ( comparisonBinop[op] term[f] )* ;
 */
static void
comparison(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      std::vector<CVC4::Expr> expressions;
      std::vector<unsigned> operators;
      unsigned op;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1521:3: ( term[f] ( comparisonBinop[op] term[f] )* )
        // ../../../../../../src/parser/cvc/Cvc.g:1521:5: term[f] ( comparisonBinop[op] term[f] )*
        {
            FOLLOWPUSH(FOLLOW_term_in_comparison4808);
            term(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecomparisonEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 expressions.push_back(f); 
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1522:5: ( comparisonBinop[op] term[f] )*

            for (;;)
            {
                int alt67=2;
                switch ( LA(1) )
                {
                case DISEQUAL_TOK:
                case EQUAL_TOK:
                case FMF_CARD_TOK:
                case GEQ_TOK:
                case GT_TOK:
                case LEQ_TOK:
                case LT_TOK:
                case MEMBER_TOK:
                	{
                		alt67=1;
                	}
                    break;

                }

                switch (alt67)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1522:7: comparisonBinop[op] term[f]
            	    {
            	        FOLLOWPUSH(FOLLOW_comparisonBinop_in_comparison4819);
            	        comparisonBinop(ctx, op);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomparisonEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_term_in_comparison4822);
            	        term(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomparisonEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             operators.push_back(op); expressions.push_back(f); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop67;	/* break out of the loop */
            	    break;
                }
            }
            loop67: ; /* Jump out to here if this rule does not match */


            if ( BACKTRACKING==0 )
            {
                 f = createPrecedenceTree(PARSER_STATE, EXPR_MANAGER, expressions, operators); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparisonEx; /* Prevent compiler warnings */
    rulecomparisonEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end comparison */

/**
 * $ANTLR start comparisonBinop
 * ../../../../../../src/parser/cvc/Cvc.g:1527:1: comparisonBinop[unsigned& op] : ( EQUAL_TOK | DISEQUAL_TOK | GT_TOK | GEQ_TOK | LT_TOK | LEQ_TOK | MEMBER_TOK | FMF_CARD_TOK );
 */
static void
comparisonBinop(pCvcParser ctx, unsigned& op)
{
    /* Initialize rule variables
     */


      op = LT(1)->getType(LT(1));

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1531:3: ( EQUAL_TOK | DISEQUAL_TOK | GT_TOK | GEQ_TOK | LT_TOK | LEQ_TOK | MEMBER_TOK | FMF_CARD_TOK )
        // ../../../../../../src/parser/cvc/Cvc.g:
        {
            if ( LA(1) == DISEQUAL_TOK || LA(1) == EQUAL_TOK || LA(1) == FMF_CARD_TOK || LA(1) == GEQ_TOK || LA(1) == GT_TOK || LA(1) == LEQ_TOK || ((LA(1) >= LT_TOK) && (LA(1) <= MEMBER_TOK)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulecomparisonBinopEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparisonBinopEx; /* Prevent compiler warnings */
    rulecomparisonBinopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end comparisonBinop */

/**
 * $ANTLR start arithmeticBinop
 * ../../../../../../src/parser/cvc/Cvc.g:1541:1: arithmeticBinop[unsigned& op] : ( PLUS_TOK | MINUS_TOK | STAR_TOK | INTDIV_TOK | MOD_TOK | DIV_TOK | EXP_TOK );
 */
static void
arithmeticBinop(pCvcParser ctx, unsigned& op)
{
    /* Initialize rule variables
     */


      op = LT(1)->getType(LT(1));

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1545:3: ( PLUS_TOK | MINUS_TOK | STAR_TOK | INTDIV_TOK | MOD_TOK | DIV_TOK | EXP_TOK )
        // ../../../../../../src/parser/cvc/Cvc.g:
        {
            if ( LA(1) == DIV_TOK || LA(1) == EXP_TOK || LA(1) == INTDIV_TOK || ((LA(1) >= MINUS_TOK) && (LA(1) <= MOD_TOK)) || LA(1) == PLUS_TOK || LA(1) == STAR_TOK )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulearithmeticBinopEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulearithmeticBinopEx; /* Prevent compiler warnings */
    rulearithmeticBinopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end arithmeticBinop */

/**
 * $ANTLR start term
 * ../../../../../../src/parser/cvc/Cvc.g:1555:1: term[CVC4::Expr& f] : uminusTerm[f] ( WITH_TOK ( arrayStore[f] ( COMMA arrayStore[f] )* | DOT ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* ) ) | ( arithmeticBinop[op] uminusTerm[f] )* ) ;
 */
static void
term(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      std::vector<CVC4::Expr> expressions;
      std::vector<unsigned> operators;
      unsigned op;
      Type t;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1562:3: ( uminusTerm[f] ( WITH_TOK ( arrayStore[f] ( COMMA arrayStore[f] )* | DOT ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* ) ) | ( arithmeticBinop[op] uminusTerm[f] )* ) )
        // ../../../../../../src/parser/cvc/Cvc.g:1562:5: uminusTerm[f] ( WITH_TOK ( arrayStore[f] ( COMMA arrayStore[f] )* | DOT ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* ) ) | ( arithmeticBinop[op] uminusTerm[f] )* )
        {
            FOLLOWPUSH(FOLLOW_uminusTerm_in_term4977);
            uminusTerm(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1563:5: ( WITH_TOK ( arrayStore[f] ( COMMA arrayStore[f] )* | DOT ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* ) ) | ( arithmeticBinop[op] uminusTerm[f] )* )
            {
                int alt74=2;
                switch ( LA(1) )
                {
                case WITH_TOK:
                	{
                		alt74=1;
                	}
                    break;
                case EOF:
                case AND_TOK:
                case BAR:
                case COLON:
                case COMMA:
                case DISEQUAL_TOK:
                case DIV_TOK:
                case ELSEIF_TOK:
                case ELSE_TOK:
                case ENDIF_TOK:
                case EQUAL_TOK:
                case EXP_TOK:
                case FMF_CARD_TOK:
                case GEQ_TOK:
                case GT_TOK:
                case HASHPAREN:
                case IFF_TOK:
                case IMPLIES_TOK:
                case INTDIV_TOK:
                case INTEGER_LITERAL:
                case IN_TOK:
                case JOIN_TOK:
                case LBRACKET:
                case LEQ_TOK:
                case LT_TOK:
                case MEMBER_TOK:
                case MINUS_TOK:
                case MOD_TOK:
                case OR_TOK:
                case PLUS_TOK:
                case PRODUCT_TOK:
                case RBRACE:
                case RBRACKET:
                case RPAREN:
                case SEMICOLON:
                case STAR_TOK:
                case THEN_TOK:
                case XOR_TOK:
                	{
                		alt74=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 74;
                    EXCEPTION->state        = 0;


                    goto ruletermEx;

                }

                switch (alt74)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1563:7: WITH_TOK ( arrayStore[f] ( COMMA arrayStore[f] )* | DOT ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* ) )
            	    {
            	         MATCHT(WITH_TOK, &FOLLOW_WITH_TOK_in_term4986);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:1564:7: ( arrayStore[f] ( COMMA arrayStore[f] )* | DOT ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* ) )
            	        {
            	            int alt72=2;
            	            switch ( LA(1) )
            	            {
            	            case LBRACKET:
            	            	{
            	            		alt72=1;
            	            	}
            	                break;
            	            case DOT:
            	            	{
            	            		alt72=2;
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return ;
            	                }

            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 72;
            	                EXCEPTION->state        = 0;


            	                goto ruletermEx;

            	            }

            	            switch (alt72)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1564:9: arrayStore[f] ( COMMA arrayStore[f] )*
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_arrayStore_in_term4996);
            	        	        arrayStore(ctx, f);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1564:23: ( COMMA arrayStore[f] )*

            	        	        for (;;)
            	        	        {
            	        	            int alt68=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case COMMA:
            	        	            	{
            	        	            		alt68=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt68)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1564:25: COMMA arrayStore[f]
            	        	        	    {
            	        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_term5001);
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        FOLLOWPUSH(FOLLOW_arrayStore_in_term5003);
            	        	        	        arrayStore(ctx, f);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop68;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop68: ; /* Jump out to here if this rule does not match */


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1565:9: DOT ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* )
            	        	    {
            	        	         MATCHT(DOT, &FOLLOW_DOT_in_term5017);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1565:13: ( tupleStore[f] ( COMMA DOT tupleStore[f] )* | recordStore[f] ( COMMA DOT recordStore[f] )* )
            	        	        {
            	        	            int alt71=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case INTEGER_LITERAL:
            	        	            	{
            	        	            		alt71=1;
            	        	            	}
            	        	                break;
            	        	            case IDENTIFIER:
            	        	            	{
            	        	            		alt71=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return ;
            	        	                }

            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 71;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletermEx;

            	        	            }

            	        	            switch (alt71)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1565:15: tupleStore[f] ( COMMA DOT tupleStore[f] )*
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_tupleStore_in_term5021);
            	        	        	        tupleStore(ctx, f);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        // ../../../../../../src/parser/cvc/Cvc.g:1565:29: ( COMMA DOT tupleStore[f] )*

            	        	        	        for (;;)
            	        	        	        {
            	        	        	            int alt69=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	            case COMMA:
            	        	        	            	{
            	        	        	            		alt69=1;
            	        	        	            	}
            	        	        	                break;

            	        	        	            }

            	        	        	            switch (alt69)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1565:31: COMMA DOT tupleStore[f]
            	        	        	        	    {
            	        	        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_term5026);
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletermEx;
            	        	        	        	        }
            	        	        	        	        if (HASFAILED())
            	        	        	        	        {
            	        	        	        	            return ;
            	        	        	        	        }


            	        	        	        	         MATCHT(DOT, &FOLLOW_DOT_in_term5028);
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletermEx;
            	        	        	        	        }
            	        	        	        	        if (HASFAILED())
            	        	        	        	        {
            	        	        	        	            return ;
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_tupleStore_in_term5030);
            	        	        	        	        tupleStore(ctx, f);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletermEx;
            	        	        	        	        }
            	        	        	        	        if (HASFAILED())
            	        	        	        	        {
            	        	        	        	            return ;
            	        	        	        	        }


            	        	        	        	    }
            	        	        	        	    break;

            	        	        	        	default:
            	        	        	        	    goto loop69;	/* break out of the loop */
            	        	        	        	    break;
            	        	        	            }
            	        	        	        }
            	        	        	        loop69: ; /* Jump out to here if this rule does not match */


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1566:15: recordStore[f] ( COMMA DOT recordStore[f] )*
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_recordStore_in_term5050);
            	        	        	        recordStore(ctx, f);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        // ../../../../../../src/parser/cvc/Cvc.g:1566:30: ( COMMA DOT recordStore[f] )*

            	        	        	        for (;;)
            	        	        	        {
            	        	        	            int alt70=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	            case COMMA:
            	        	        	            	{
            	        	        	            		alt70=1;
            	        	        	            	}
            	        	        	                break;

            	        	        	            }

            	        	        	            switch (alt70)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1566:32: COMMA DOT recordStore[f]
            	        	        	        	    {
            	        	        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_term5055);
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletermEx;
            	        	        	        	        }
            	        	        	        	        if (HASFAILED())
            	        	        	        	        {
            	        	        	        	            return ;
            	        	        	        	        }


            	        	        	        	         MATCHT(DOT, &FOLLOW_DOT_in_term5057);
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletermEx;
            	        	        	        	        }
            	        	        	        	        if (HASFAILED())
            	        	        	        	        {
            	        	        	        	            return ;
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_recordStore_in_term5059);
            	        	        	        	        recordStore(ctx, f);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletermEx;
            	        	        	        	        }
            	        	        	        	        if (HASFAILED())
            	        	        	        	        {
            	        	        	        	            return ;
            	        	        	        	        }


            	        	        	        	    }
            	        	        	        	    break;

            	        	        	        	default:
            	        	        	        	    goto loop70;	/* break out of the loop */
            	        	        	        	    break;
            	        	        	            }
            	        	        	        }
            	        	        	        loop70: ; /* Jump out to here if this rule does not match */


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1567:7: ( arithmeticBinop[op] uminusTerm[f] )*
            	    {
            	        if ( BACKTRACKING==0 )
            	        {
            	             expressions.push_back(f); 
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:1568:7: ( arithmeticBinop[op] uminusTerm[f] )*

            	        for (;;)
            	        {
            	            int alt73=2;
            	            switch ( LA(1) )
            	            {
            	            case DIV_TOK:
            	            case EXP_TOK:
            	            case INTDIV_TOK:
            	            case MINUS_TOK:
            	            case MOD_TOK:
            	            case PLUS_TOK:
            	            case STAR_TOK:
            	            	{
            	            		alt73=1;
            	            	}
            	                break;

            	            }

            	            switch (alt73)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1568:9: arithmeticBinop[op] uminusTerm[f]
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_arithmeticBinop_in_term5085);
            	        	        arithmeticBinop(ctx, op);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_uminusTerm_in_term5088);
            	        	        uminusTerm(ctx, f);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {
            	        	             operators.push_back(op); expressions.push_back(f); 
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop73;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop73: ; /* Jump out to here if this rule does not match */


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = createPrecedenceTree(PARSER_STATE, EXPR_MANAGER, expressions, operators); 
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start arrayStore
 * ../../../../../../src/parser/cvc/Cvc.g:1577:1: arrayStore[CVC4::Expr& f] : LBRACKET formula[k] RBRACKET ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] ) ;
 */
static void
arrayStore(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      Expr f2, k;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1581:3: ( LBRACKET formula[k] RBRACKET ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] ) )
        // ../../../../../../src/parser/cvc/Cvc.g:1581:5: LBRACKET formula[k] RBRACKET ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] )
        {
             MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_arrayStore5129);
            if  (HASEXCEPTION())
            {
                goto rulearrayStoreEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_formula_in_arrayStore5131);
            formula(ctx, k);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulearrayStoreEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(RBRACKET, &FOLLOW_RBRACKET_in_arrayStore5134);
            if  (HASEXCEPTION())
            {
                goto rulearrayStoreEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 f2 = MK_EXPR(CVC4::kind::SELECT, f, k); 
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1583:5: ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] )
            {
                int alt77=2;
                switch ( LA(1) )
                {
                case DOT:
                case LBRACKET:
                	{
                		alt77=1;
                	}
                    break;
                case ASSIGN_TOK:
                	{
                		alt77=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 77;
                    EXCEPTION->state        = 0;


                    goto rulearrayStoreEx;

                }

                switch (alt77)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1583:7: ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) )
            	    {
            	        // ../../../../../../src/parser/cvc/Cvc.g:1583:7: ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) )
            	        {
            	            int alt76=2;
            	            switch ( LA(1) )
            	            {
            	            case LBRACKET:
            	            	{
            	            		alt76=1;
            	            	}
            	                break;
            	            case DOT:
            	            	{
            	            		alt76=2;
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return ;
            	                }

            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 76;
            	                EXCEPTION->state        = 0;


            	                goto rulearrayStoreEx;

            	            }

            	            switch (alt76)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1583:9: arrayStore[f2]
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_arrayStore_in_arrayStore5150);
            	        	        arrayStore(ctx, f2);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulearrayStoreEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1584:9: DOT ( tupleStore[f2] | recordStore[f2] )
            	        	    {
            	        	         MATCHT(DOT, &FOLLOW_DOT_in_arrayStore5161);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulearrayStoreEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1584:13: ( tupleStore[f2] | recordStore[f2] )
            	        	        {
            	        	            int alt75=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case INTEGER_LITERAL:
            	        	            	{
            	        	            		alt75=1;
            	        	            	}
            	        	                break;
            	        	            case IDENTIFIER:
            	        	            	{
            	        	            		alt75=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return ;
            	        	                }

            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 75;
            	        	                EXCEPTION->state        = 0;


            	        	                goto rulearrayStoreEx;

            	        	            }

            	        	            switch (alt75)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1584:15: tupleStore[f2]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_tupleStore_in_arrayStore5165);
            	        	        	        tupleStore(ctx, f2);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulearrayStoreEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1585:15: recordStore[f2]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_recordStore_in_arrayStore5182);
            	        	        	        recordStore(ctx, f2);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulearrayStoreEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1586:7: ASSIGN_TOK term[f2]
            	    {
            	         MATCHT(ASSIGN_TOK, &FOLLOW_ASSIGN_TOK_in_arrayStore5195);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulearrayStoreEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_term_in_arrayStore5197);
            	        term(ctx, f2);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulearrayStoreEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                 f = MK_EXPR(CVC4::kind::STORE, f, k, f2); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulearrayStoreEx; /* Prevent compiler warnings */
    rulearrayStoreEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end arrayStore */

/**
 * $ANTLR start tupleStore
 * ../../../../../../src/parser/cvc/Cvc.g:1594:1: tupleStore[CVC4::Expr& f] : k= numeral ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] ) ;
 */
static void
tupleStore(pCvcParser ctx, CVC4::Expr& f)
{
    unsigned k;
    #undef	RETURN_TYPE_k
    #define	RETURN_TYPE_k unsigned

    /* Initialize rule variables
     */


      Expr f2;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1598:3: (k= numeral ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] ) )
        // ../../../../../../src/parser/cvc/Cvc.g:1598:5: k= numeral ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] )
        {
            FOLLOWPUSH(FOLLOW_numeral_in_tupleStore5229);
            k=numeral(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletupleStoreEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 Type t = f.getType();
                      if(! t.isTuple()) {
                        PARSER_STATE->parseError("tuple-update applied to non-tuple");
                      }
                      size_t length = ((DatatypeType)t).getTupleLength();
                      if(k >= length) {
                        std::stringstream ss;
                        ss << "tuple is of length " << length << "; cannot update index " << k;
                        PARSER_STATE->parseError(ss.str());
                      }
                      std::vector<Expr> args;
                      const Datatype & dt = ((DatatypeType)t).getDatatype();
                      args.push_back( dt[0][k].getSelector() );
                      args.push_back( f );
                      f2 = MK_EXPR(CVC4::kind::APPLY_SELECTOR_TOTAL,args);
                    
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1615:5: ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] )
            {
                int alt80=2;
                switch ( LA(1) )
                {
                case DOT:
                case LBRACKET:
                	{
                		alt80=1;
                	}
                    break;
                case ASSIGN_TOK:
                	{
                		alt80=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 80;
                    EXCEPTION->state        = 0;


                    goto ruletupleStoreEx;

                }

                switch (alt80)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1615:7: ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) )
            	    {
            	        // ../../../../../../src/parser/cvc/Cvc.g:1615:7: ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) )
            	        {
            	            int alt79=2;
            	            switch ( LA(1) )
            	            {
            	            case LBRACKET:
            	            	{
            	            		alt79=1;
            	            	}
            	                break;
            	            case DOT:
            	            	{
            	            		alt79=2;
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return ;
            	                }

            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 79;
            	                EXCEPTION->state        = 0;


            	                goto ruletupleStoreEx;

            	            }

            	            switch (alt79)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1615:9: arrayStore[f2]
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_arrayStore_in_tupleStore5245);
            	        	        arrayStore(ctx, f2);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletupleStoreEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1616:9: DOT ( tupleStore[f2] | recordStore[f2] )
            	        	    {
            	        	         MATCHT(DOT, &FOLLOW_DOT_in_tupleStore5256);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletupleStoreEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1616:13: ( tupleStore[f2] | recordStore[f2] )
            	        	        {
            	        	            int alt78=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case INTEGER_LITERAL:
            	        	            	{
            	        	            		alt78=1;
            	        	            	}
            	        	                break;
            	        	            case IDENTIFIER:
            	        	            	{
            	        	            		alt78=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return ;
            	        	                }

            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 78;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletupleStoreEx;

            	        	            }

            	        	            switch (alt78)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1616:15: tupleStore[f2]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_tupleStore_in_tupleStore5260);
            	        	        	        tupleStore(ctx, f2);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletupleStoreEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1617:15: recordStore[f2]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_recordStore_in_tupleStore5277);
            	        	        	        recordStore(ctx, f2);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletupleStoreEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1618:7: ASSIGN_TOK term[f2]
            	    {
            	         MATCHT(ASSIGN_TOK, &FOLLOW_ASSIGN_TOK_in_tupleStore5290);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletupleStoreEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_term_in_tupleStore5292);
            	        term(ctx, f2);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletupleStoreEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                 f = MK_EXPR(MK_CONST(TupleUpdate(k)), f, f2); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletupleStoreEx; /* Prevent compiler warnings */
    ruletupleStoreEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tupleStore */

/**
 * $ANTLR start recordStore
 * ../../../../../../src/parser/cvc/Cvc.g:1626:1: recordStore[CVC4::Expr& f] : identifier[id,CHECK_NONE,SYM_VARIABLE] ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] ) ;
 */
static void
recordStore(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      std::string id;
      Expr f2;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1631:3: ( identifier[id,CHECK_NONE,SYM_VARIABLE] ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] ) )
        // ../../../../../../src/parser/cvc/Cvc.g:1631:5: identifier[id,CHECK_NONE,SYM_VARIABLE] ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] )
        {
            FOLLOWPUSH(FOLLOW_identifier_in_recordStore5322);
            identifier(ctx, id, CHECK_NONE, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerecordStoreEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 Type t = f.getType();
                      if(! t.isRecord()) {
                        std::stringstream ss;
                        ss << "record-update applied to non-record term" << std::endl
                           << "the term: " << f << std::endl
                           << "its type: " << t;
                        PARSER_STATE->parseError(ss.str());
                      }
                      const Record& rec = ((DatatypeType)t).getRecord();
                      if(! rec.contains(id)) {
                        PARSER_STATE->parseError(std::string("no such field `") + id + "' in record");
                      }
                      std::vector<Expr> args;
                      const Datatype & dt = ((DatatypeType)t).getDatatype();
                      args.push_back( dt[0][id].getSelector() );
                      args.push_back( f );
                      f2 = MK_EXPR(CVC4::kind::APPLY_SELECTOR_TOTAL,args);
                    
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1650:5: ( ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) ) | ASSIGN_TOK term[f2] )
            {
                int alt83=2;
                switch ( LA(1) )
                {
                case DOT:
                case LBRACKET:
                	{
                		alt83=1;
                	}
                    break;
                case ASSIGN_TOK:
                	{
                		alt83=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 83;
                    EXCEPTION->state        = 0;


                    goto rulerecordStoreEx;

                }

                switch (alt83)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1650:7: ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) )
            	    {
            	        // ../../../../../../src/parser/cvc/Cvc.g:1650:7: ( arrayStore[f2] | DOT ( tupleStore[f2] | recordStore[f2] ) )
            	        {
            	            int alt82=2;
            	            switch ( LA(1) )
            	            {
            	            case LBRACKET:
            	            	{
            	            		alt82=1;
            	            	}
            	                break;
            	            case DOT:
            	            	{
            	            		alt82=2;
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return ;
            	                }

            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 82;
            	                EXCEPTION->state        = 0;


            	                goto rulerecordStoreEx;

            	            }

            	            switch (alt82)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1650:9: arrayStore[f2]
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_arrayStore_in_recordStore5339);
            	        	        arrayStore(ctx, f2);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulerecordStoreEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1651:9: DOT ( tupleStore[f2] | recordStore[f2] )
            	        	    {
            	        	         MATCHT(DOT, &FOLLOW_DOT_in_recordStore5350);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulerecordStoreEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1651:13: ( tupleStore[f2] | recordStore[f2] )
            	        	        {
            	        	            int alt81=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case INTEGER_LITERAL:
            	        	            	{
            	        	            		alt81=1;
            	        	            	}
            	        	                break;
            	        	            case IDENTIFIER:
            	        	            	{
            	        	            		alt81=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return ;
            	        	                }

            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 81;
            	        	                EXCEPTION->state        = 0;


            	        	                goto rulerecordStoreEx;

            	        	            }

            	        	            switch (alt81)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1651:15: tupleStore[f2]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_tupleStore_in_recordStore5354);
            	        	        	        tupleStore(ctx, f2);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulerecordStoreEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1652:15: recordStore[f2]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_recordStore_in_recordStore5371);
            	        	        	        recordStore(ctx, f2);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulerecordStoreEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1653:7: ASSIGN_TOK term[f2]
            	    {
            	         MATCHT(ASSIGN_TOK, &FOLLOW_ASSIGN_TOK_in_recordStore5384);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerecordStoreEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_term_in_recordStore5386);
            	        term(ctx, f2);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerecordStoreEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                 f = MK_EXPR(MK_CONST(RecordUpdate(id)), f, f2); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulerecordStoreEx; /* Prevent compiler warnings */
    rulerecordStoreEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end recordStore */

/**
 * $ANTLR start uminusTerm
 * ../../../../../../src/parser/cvc/Cvc.g:1658:1: uminusTerm[CVC4::Expr& f] : ( ( MINUS_TOK )+ bvBinaryOpTerm[f] | bvBinaryOpTerm[f] );
 */
static void
uminusTerm(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      unsigned minusCount = 0;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1663:3: ( ( MINUS_TOK )+ bvBinaryOpTerm[f] | bvBinaryOpTerm[f] )

            ANTLR3_UINT32 alt85;

            alt85=2;

            switch ( LA(1) )
            {
            case MINUS_TOK:
            	{
            		alt85=1;
            	}
                break;
            case ABS_TOK:
            case ARRAY_TOK:
            case BAR:
            case BINARY_LITERAL:
            case BVASHR_TOK:
            case BVCOMP_TOK:
            case BVGE_TOK:
            case BVGT_TOK:
            case BVLE_TOK:
            case BVLSHR_TOK:
            case BVLT_TOK:
            case BVMULT_TOK:
            case BVNAND_TOK:
            case BVNEG_TOK:
            case BVNOR_TOK:
            case BVPLUS_TOK:
            case BVREPEAT_TOK:
            case BVROTL_TOK:
            case BVROTR_TOK:
            case BVSDIV_TOK:
            case BVSGE_TOK:
            case BVSGT_TOK:
            case BVSHL_TOK:
            case BVSLE_TOK:
            case BVSLT_TOK:
            case BVSMOD_TOK:
            case BVSREM_TOK:
            case BVSUB_TOK:
            case BVUDIV_TOK:
            case BVUMINUS_TOK:
            case BVUREM_TOK:
            case BVXNOR_TOK:
            case BVXOR_TOK:
            case BVZEROEXTEND_TOK:
            case DECIMAL_LITERAL:
            case DISTINCT_TOK:
            case DIVISIBLE_TOK:
            case FALSE_TOK:
            case FLOOR_TOK:
            case HEX_LITERAL:
            case IDENTIFIER:
            case IF_TOK:
            case INTEGER_LITERAL:
            case IS_INTEGER_TOK:
            case LBRACE:
            case LPAREN:
            case NOT_TOK:
            case PARENHASH:
            case SETS_CARD_TOK:
            case STRING_CONCAT_TOK:
            case STRING_CONTAINS_TOK:
            case STRING_INDEXOF_TOK:
            case STRING_ITOS_TOK:
            case STRING_LENGTH_TOK:
            case STRING_LITERAL:
            case STRING_PREFIXOF_TOK:
            case STRING_REPLACE_TOK:
            case STRING_STOI_TOK:
            case STRING_STOU16_TOK:
            case STRING_STOU32_TOK:
            case STRING_SUBSTR_TOK:
            case STRING_SUFFIXOF_TOK:
            case STRING_U16TOS_TOK:
            case STRING_U32TOS_TOK:
            case SX_TOK:
            case TRANSCLOSURE_TOK:
            case TRANSPOSE_TOK:
            case TRUE_TOK:
            case TUPLE_TOK:
            case UNIVSET_TOK:
            	{
            		alt85=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 85;
                EXCEPTION->state        = 0;


                goto ruleuminusTermEx;

            }

            switch (alt85)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1663:5: ( MINUS_TOK )+ bvBinaryOpTerm[f]
        	    {
        	        // ../../../../../../src/parser/cvc/Cvc.g:1663:5: ( MINUS_TOK )+
        	        {
        	            int cnt84=0;

        	            for (;;)
        	            {
        	                int alt84=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case MINUS_TOK:
        	        		{
        	        			alt84=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt84)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:1663:6: MINUS_TOK
        	        	        {
        	        	             MATCHT(MINUS_TOK, &FOLLOW_MINUS_TOK_in_uminusTerm5423);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleuminusTermEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }


        	        	            if ( BACKTRACKING==0 )
        	        	            {
        	        	                 ++minusCount; 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt84 >= 1 )
        	        		{
        	        		    goto loop84;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    return ;
        	        		}

        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleuminusTermEx;
        	        	}
        	        	cnt84++;
        	            }
        	            loop84: ;	/* Jump to here if this rule does not match */
        	        }

        	        FOLLOWPUSH(FOLLOW_bvBinaryOpTerm_in_uminusTerm5429);
        	        bvBinaryOpTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuminusTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             while(minusCount > 0) { --minusCount; f = MK_EXPR(CVC4::kind::UMINUS, f); } 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1665:5: bvBinaryOpTerm[f]
        	    {
        	        FOLLOWPUSH(FOLLOW_bvBinaryOpTerm_in_uminusTerm5442);
        	        bvBinaryOpTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuminusTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleuminusTermEx; /* Prevent compiler warnings */
    ruleuminusTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end uminusTerm */

/**
 * $ANTLR start bvBinaryOpTerm
 * ../../../../../../src/parser/cvc/Cvc.g:1669:1: bvBinaryOpTerm[CVC4::Expr& f] : bvNegTerm[f] ( bvBinop[op] bvNegTerm[f] )* ;
 */
static void
bvBinaryOpTerm(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      std::vector<CVC4::Expr> expressions;
      std::vector<unsigned> operators;
      unsigned op;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1675:3: ( bvNegTerm[f] ( bvBinop[op] bvNegTerm[f] )* )
        // ../../../../../../src/parser/cvc/Cvc.g:1675:5: bvNegTerm[f] ( bvBinop[op] bvNegTerm[f] )*
        {
            FOLLOWPUSH(FOLLOW_bvNegTerm_in_bvBinaryOpTerm5464);
            bvNegTerm(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebvBinaryOpTermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 expressions.push_back(f); 
            }


            // ../../../../../../src/parser/cvc/Cvc.g:1676:5: ( bvBinop[op] bvNegTerm[f] )*

            for (;;)
            {
                int alt86=2;
                switch ( LA(1) )
                {
                case BAR:
                	{
                		switch ( LA(2) )
                		{
                		case BAR:
                			{
                				switch ( LA(3) )
                				{
                				case BAR:
                					{
                						alt86=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case ABS_TOK:
                		case ARRAY_TOK:
                		case BINARY_LITERAL:
                		case BVASHR_TOK:
                		case BVCOMP_TOK:
                		case BVGE_TOK:
                		case BVGT_TOK:
                		case BVLE_TOK:
                		case BVLSHR_TOK:
                		case BVLT_TOK:
                		case BVMULT_TOK:
                		case BVNAND_TOK:
                		case BVNEG_TOK:
                		case BVNOR_TOK:
                		case BVPLUS_TOK:
                		case BVREPEAT_TOK:
                		case BVROTL_TOK:
                		case BVROTR_TOK:
                		case BVSDIV_TOK:
                		case BVSGE_TOK:
                		case BVSGT_TOK:
                		case BVSHL_TOK:
                		case BVSLE_TOK:
                		case BVSLT_TOK:
                		case BVSMOD_TOK:
                		case BVSREM_TOK:
                		case BVSUB_TOK:
                		case BVUDIV_TOK:
                		case BVUMINUS_TOK:
                		case BVUREM_TOK:
                		case BVXNOR_TOK:
                		case BVXOR_TOK:
                		case BVZEROEXTEND_TOK:
                		case DECIMAL_LITERAL:
                		case DISTINCT_TOK:
                		case DIVISIBLE_TOK:
                		case FALSE_TOK:
                		case FLOOR_TOK:
                		case HEX_LITERAL:
                		case IDENTIFIER:
                		case IF_TOK:
                		case INTEGER_LITERAL:
                		case IS_INTEGER_TOK:
                		case LBRACE:
                		case LPAREN:
                		case NOT_TOK:
                		case PARENHASH:
                		case SETS_CARD_TOK:
                		case STRING_CONCAT_TOK:
                		case STRING_CONTAINS_TOK:
                		case STRING_INDEXOF_TOK:
                		case STRING_ITOS_TOK:
                		case STRING_LENGTH_TOK:
                		case STRING_LITERAL:
                		case STRING_PREFIXOF_TOK:
                		case STRING_REPLACE_TOK:
                		case STRING_STOI_TOK:
                		case STRING_STOU16_TOK:
                		case STRING_STOU32_TOK:
                		case STRING_SUBSTR_TOK:
                		case STRING_SUFFIXOF_TOK:
                		case STRING_U16TOS_TOK:
                		case STRING_U32TOS_TOK:
                		case SX_TOK:
                		case TRANSCLOSURE_TOK:
                		case TRANSPOSE_TOK:
                		case TRUE_TOK:
                		case TUPLE_TOK:
                		case UNIVSET_TOK:
                			{
                				alt86=1;
                			}
                		    break;

                		}

                	}
                    break;
                case BVAND_TOK:
                case CONCAT_TOK:
                	{
                		alt86=1;
                	}
                    break;

                }

                switch (alt86)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1676:7: bvBinop[op] bvNegTerm[f]
            	    {
            	        FOLLOWPUSH(FOLLOW_bvBinop_in_bvBinaryOpTerm5475);
            	        bvBinop(ctx, op);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebvBinaryOpTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_bvNegTerm_in_bvBinaryOpTerm5478);
            	        bvNegTerm(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebvBinaryOpTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             operators.push_back(op); expressions.push_back(f); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop86;	/* break out of the loop */
            	    break;
                }
            }
            loop86: ; /* Jump out to here if this rule does not match */


            if ( BACKTRACKING==0 )
            {
                 f = createPrecedenceTree(PARSER_STATE, EXPR_MANAGER, expressions, operators); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebvBinaryOpTermEx; /* Prevent compiler warnings */
    rulebvBinaryOpTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bvBinaryOpTerm */

/**
 * $ANTLR start bvBinop
 * ../../../../../../src/parser/cvc/Cvc.g:1679:1: bvBinop[unsigned& op] : ( CONCAT_TOK | BAR | BVAND_TOK );
 */
static void
bvBinop(pCvcParser ctx, unsigned& op)
{
    /* Initialize rule variables
     */


      op = LT(1)->getType(LT(1));

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1683:3: ( CONCAT_TOK | BAR | BVAND_TOK )
        // ../../../../../../src/parser/cvc/Cvc.g:
        {
            if ( LA(1) == BAR || LA(1) == BVAND_TOK || LA(1) == CONCAT_TOK )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulebvBinopEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebvBinopEx; /* Prevent compiler warnings */
    rulebvBinopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bvBinop */

/**
 * $ANTLR start bvNegTerm
 * ../../../../../../src/parser/cvc/Cvc.g:1688:1: bvNegTerm[CVC4::Expr& f] : ( BVNEG_TOK bvNegTerm[f] | NOT_TOK bvNegTerm[f] | TRANSPOSE_TOK bvNegTerm[f] | TRANSCLOSURE_TOK bvNegTerm[f] | TUPLE_TOK LPAREN bvNegTerm[f] RPAREN | postfixTerm[f] );
 */
static void
bvNegTerm(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1690:3: ( BVNEG_TOK bvNegTerm[f] | NOT_TOK bvNegTerm[f] | TRANSPOSE_TOK bvNegTerm[f] | TRANSCLOSURE_TOK bvNegTerm[f] | TUPLE_TOK LPAREN bvNegTerm[f] RPAREN | postfixTerm[f] )

            ANTLR3_UINT32 alt87;

            alt87=6;

            switch ( LA(1) )
            {
            case BVNEG_TOK:
            	{
            		alt87=1;
            	}
                break;
            case NOT_TOK:
            	{
            		alt87=2;
            	}
                break;
            case TRANSPOSE_TOK:
            	{
            		alt87=3;
            	}
                break;
            case TRANSCLOSURE_TOK:
            	{
            		alt87=4;
            	}
                break;
            case TUPLE_TOK:
            	{
            		alt87=5;
            	}
                break;
            case ABS_TOK:
            case ARRAY_TOK:
            case BAR:
            case BINARY_LITERAL:
            case BVASHR_TOK:
            case BVCOMP_TOK:
            case BVGE_TOK:
            case BVGT_TOK:
            case BVLE_TOK:
            case BVLSHR_TOK:
            case BVLT_TOK:
            case BVMULT_TOK:
            case BVNAND_TOK:
            case BVNOR_TOK:
            case BVPLUS_TOK:
            case BVREPEAT_TOK:
            case BVROTL_TOK:
            case BVROTR_TOK:
            case BVSDIV_TOK:
            case BVSGE_TOK:
            case BVSGT_TOK:
            case BVSHL_TOK:
            case BVSLE_TOK:
            case BVSLT_TOK:
            case BVSMOD_TOK:
            case BVSREM_TOK:
            case BVSUB_TOK:
            case BVUDIV_TOK:
            case BVUMINUS_TOK:
            case BVUREM_TOK:
            case BVXNOR_TOK:
            case BVXOR_TOK:
            case BVZEROEXTEND_TOK:
            case DECIMAL_LITERAL:
            case DISTINCT_TOK:
            case DIVISIBLE_TOK:
            case FALSE_TOK:
            case FLOOR_TOK:
            case HEX_LITERAL:
            case IDENTIFIER:
            case IF_TOK:
            case INTEGER_LITERAL:
            case IS_INTEGER_TOK:
            case LBRACE:
            case LPAREN:
            case PARENHASH:
            case SETS_CARD_TOK:
            case STRING_CONCAT_TOK:
            case STRING_CONTAINS_TOK:
            case STRING_INDEXOF_TOK:
            case STRING_ITOS_TOK:
            case STRING_LENGTH_TOK:
            case STRING_LITERAL:
            case STRING_PREFIXOF_TOK:
            case STRING_REPLACE_TOK:
            case STRING_STOI_TOK:
            case STRING_STOU16_TOK:
            case STRING_STOU32_TOK:
            case STRING_SUBSTR_TOK:
            case STRING_SUFFIXOF_TOK:
            case STRING_U16TOS_TOK:
            case STRING_U32TOS_TOK:
            case SX_TOK:
            case TRUE_TOK:
            case UNIVSET_TOK:
            	{
            		alt87=6;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 87;
                EXCEPTION->state        = 0;


                goto rulebvNegTermEx;

            }

            switch (alt87)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1690:5: BVNEG_TOK bvNegTerm[f]
        	    {
        	         MATCHT(BVNEG_TOK, &FOLLOW_BVNEG_TOK_in_bvNegTerm5541);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_bvNegTerm_in_bvNegTerm5543);
        	        bvNegTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_NOT, f); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1692:5: NOT_TOK bvNegTerm[f]
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_bvNegTerm5556);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_bvNegTerm_in_bvNegTerm5558);
        	        bvNegTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::COMPLEMENT, f); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1694:5: TRANSPOSE_TOK bvNegTerm[f]
        	    {
        	         MATCHT(TRANSPOSE_TOK, &FOLLOW_TRANSPOSE_TOK_in_bvNegTerm5572);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_bvNegTerm_in_bvNegTerm5574);
        	        bvNegTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::TRANSPOSE, f); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1696:5: TRANSCLOSURE_TOK bvNegTerm[f]
        	    {
        	         MATCHT(TRANSCLOSURE_TOK, &FOLLOW_TRANSCLOSURE_TOK_in_bvNegTerm5588);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_bvNegTerm_in_bvNegTerm5590);
        	        bvNegTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::TCLOSURE, f); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1698:5: TUPLE_TOK LPAREN bvNegTerm[f] RPAREN
        	    {
        	         MATCHT(TUPLE_TOK, &FOLLOW_TUPLE_TOK_in_bvNegTerm5603);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvNegTerm5605);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_bvNegTerm_in_bvNegTerm5607);
        	        bvNegTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvNegTerm5610);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             std::vector<Type> types;
        	                  std::vector<Expr> args;
        	                  args.push_back(f);
        	            	  types.push_back(f.getType());
        	                  DatatypeType t = EXPR_MANAGER->mkTupleType(types);
        	                  const Datatype& dt = t.getDatatype();
        	                  args.insert( args.begin(), dt[0].getConstructor() );
        	                  f = MK_EXPR(kind::APPLY_CONSTRUCTOR, args);
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1708:5: postfixTerm[f]
        	    {
        	        FOLLOWPUSH(FOLLOW_postfixTerm_in_bvNegTerm5635);
        	        postfixTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvNegTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebvNegTermEx; /* Prevent compiler warnings */
    rulebvNegTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bvNegTerm */

/**
 * $ANTLR start postfixTerm
 * ../../../../../../src/parser/cvc/Cvc.g:1720:1: postfixTerm[CVC4::Expr& f] : ( bvTerm[f] ( LBRACKET ( formula[f2] |k1= numeral COLON k2= numeral ) RBRACKET | ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK ) k= numeral | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | DOT ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral ) )* | FLOOR_TOK LPAREN formula[f] RPAREN | IS_INTEGER_TOK LPAREN formula[f] RPAREN | ABS_TOK LPAREN formula[f] RPAREN | DIVISIBLE_TOK LPAREN formula[f] COMMA n= numeral RPAREN | DISTINCT_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN ) ( typeAscription[f, t] )? ;
 */
static void
postfixTerm(pCvcParser ctx, CVC4::Expr& f)
{
    unsigned k1;
    #undef	RETURN_TYPE_k1
    #define	RETURN_TYPE_k1 unsigned

    unsigned k2;
    #undef	RETURN_TYPE_k2
    #define	RETURN_TYPE_k2 unsigned

    unsigned k;
    #undef	RETURN_TYPE_k
    #define	RETURN_TYPE_k unsigned

    unsigned n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n unsigned

    /* Initialize rule variables
     */


      Expr f2;
      bool extract = false, left = false;
      std::vector<Expr> args;
      std::string id;
      Type t;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:1728:3: ( ( bvTerm[f] ( LBRACKET ( formula[f2] |k1= numeral COLON k2= numeral ) RBRACKET | ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK ) k= numeral | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | DOT ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral ) )* | FLOOR_TOK LPAREN formula[f] RPAREN | IS_INTEGER_TOK LPAREN formula[f] RPAREN | ABS_TOK LPAREN formula[f] RPAREN | DIVISIBLE_TOK LPAREN formula[f] COMMA n= numeral RPAREN | DISTINCT_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN ) ( typeAscription[f, t] )? )
        // ../../../../../../src/parser/cvc/Cvc.g:1728:5: ( bvTerm[f] ( LBRACKET ( formula[f2] |k1= numeral COLON k2= numeral ) RBRACKET | ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK ) k= numeral | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | DOT ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral ) )* | FLOOR_TOK LPAREN formula[f] RPAREN | IS_INTEGER_TOK LPAREN formula[f] RPAREN | ABS_TOK LPAREN formula[f] RPAREN | DIVISIBLE_TOK LPAREN formula[f] COMMA n= numeral RPAREN | DISTINCT_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN ) ( typeAscription[f, t] )?
        {
            // ../../../../../../src/parser/cvc/Cvc.g:1728:5: ( bvTerm[f] ( LBRACKET ( formula[f2] |k1= numeral COLON k2= numeral ) RBRACKET | ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK ) k= numeral | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | DOT ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral ) )* | FLOOR_TOK LPAREN formula[f] RPAREN | IS_INTEGER_TOK LPAREN formula[f] RPAREN | ABS_TOK LPAREN formula[f] RPAREN | DIVISIBLE_TOK LPAREN formula[f] COMMA n= numeral RPAREN | DISTINCT_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN )
            {
                int alt94=6;
                switch ( LA(1) )
                {
                case ARRAY_TOK:
                case BAR:
                case BINARY_LITERAL:
                case BVASHR_TOK:
                case BVCOMP_TOK:
                case BVGE_TOK:
                case BVGT_TOK:
                case BVLE_TOK:
                case BVLSHR_TOK:
                case BVLT_TOK:
                case BVMULT_TOK:
                case BVNAND_TOK:
                case BVNOR_TOK:
                case BVPLUS_TOK:
                case BVREPEAT_TOK:
                case BVROTL_TOK:
                case BVROTR_TOK:
                case BVSDIV_TOK:
                case BVSGE_TOK:
                case BVSGT_TOK:
                case BVSHL_TOK:
                case BVSLE_TOK:
                case BVSLT_TOK:
                case BVSMOD_TOK:
                case BVSREM_TOK:
                case BVSUB_TOK:
                case BVUDIV_TOK:
                case BVUMINUS_TOK:
                case BVUREM_TOK:
                case BVXNOR_TOK:
                case BVXOR_TOK:
                case BVZEROEXTEND_TOK:
                case DECIMAL_LITERAL:
                case FALSE_TOK:
                case HEX_LITERAL:
                case IDENTIFIER:
                case IF_TOK:
                case INTEGER_LITERAL:
                case LBRACE:
                case LPAREN:
                case PARENHASH:
                case SETS_CARD_TOK:
                case STRING_CONCAT_TOK:
                case STRING_CONTAINS_TOK:
                case STRING_INDEXOF_TOK:
                case STRING_ITOS_TOK:
                case STRING_LENGTH_TOK:
                case STRING_LITERAL:
                case STRING_PREFIXOF_TOK:
                case STRING_REPLACE_TOK:
                case STRING_STOI_TOK:
                case STRING_STOU16_TOK:
                case STRING_STOU32_TOK:
                case STRING_SUBSTR_TOK:
                case STRING_SUFFIXOF_TOK:
                case STRING_U16TOS_TOK:
                case STRING_U32TOS_TOK:
                case SX_TOK:
                case TRUE_TOK:
                case UNIVSET_TOK:
                	{
                		alt94=1;
                	}
                    break;
                case FLOOR_TOK:
                	{
                		alt94=2;
                	}
                    break;
                case IS_INTEGER_TOK:
                	{
                		alt94=3;
                	}
                    break;
                case ABS_TOK:
                	{
                		alt94=4;
                	}
                    break;
                case DIVISIBLE_TOK:
                	{
                		alt94=5;
                	}
                    break;
                case DISTINCT_TOK:
                	{
                		alt94=6;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 94;
                    EXCEPTION->state        = 0;


                    goto rulepostfixTermEx;

                }

                switch (alt94)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1728:7: bvTerm[f] ( LBRACKET ( formula[f2] |k1= numeral COLON k2= numeral ) RBRACKET | ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK ) k= numeral | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | DOT ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral ) )*
            	    {
            	        FOLLOWPUSH(FOLLOW_bvTerm_in_postfixTerm5659);
            	        bvTerm(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:1729:5: ( LBRACKET ( formula[f2] |k1= numeral COLON k2= numeral ) RBRACKET | ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK ) k= numeral | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | DOT ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral ) )*

            	        for (;;)
            	        {
            	            int alt92=5;
            	            switch ( LA(1) )
            	            {
            	            case LBRACKET:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case IDENTIFIER:
            	            			{
            	            				switch ( LA(3) )
            	            				{
            	            				case AND_TOK:
            	            				case BAR:
            	            				case BVAND_TOK:
            	            				case COLON:
            	            				case CONCAT_TOK:
            	            				case DISEQUAL_TOK:
            	            				case DIV_TOK:
            	            				case DOT:
            	            				case EQUAL_TOK:
            	            				case EXP_TOK:
            	            				case FMF_CARD_TOK:
            	            				case GEQ_TOK:
            	            				case GT_TOK:
            	            				case IFF_TOK:
            	            				case IMPLIES_TOK:
            	            				case INTDIV_TOK:
            	            				case JOIN_TOK:
            	            				case LBRACKET:
            	            				case LEFTSHIFT_TOK:
            	            				case LEQ_TOK:
            	            				case LPAREN:
            	            				case LT_TOK:
            	            				case MEMBER_TOK:
            	            				case MINUS_TOK:
            	            				case MOD_TOK:
            	            				case OR_TOK:
            	            				case PLUS_TOK:
            	            				case PRODUCT_TOK:
            	            				case RBRACKET:
            	            				case RIGHTSHIFT_TOK:
            	            				case STAR_TOK:
            	            				case WITH_TOK:
            	            				case XOR_TOK:
            	            					{
            	            						alt92=1;
            	            					}
            	            				    break;

            	            				}

            	            			}
            	            		    break;
            	            		case ABS_TOK:
            	            		case ARRAY_TOK:
            	            		case BAR:
            	            		case BINARY_LITERAL:
            	            		case BVASHR_TOK:
            	            		case BVCOMP_TOK:
            	            		case BVGE_TOK:
            	            		case BVGT_TOK:
            	            		case BVLE_TOK:
            	            		case BVLSHR_TOK:
            	            		case BVLT_TOK:
            	            		case BVMULT_TOK:
            	            		case BVNAND_TOK:
            	            		case BVNEG_TOK:
            	            		case BVNOR_TOK:
            	            		case BVPLUS_TOK:
            	            		case BVREPEAT_TOK:
            	            		case BVROTL_TOK:
            	            		case BVROTR_TOK:
            	            		case BVSDIV_TOK:
            	            		case BVSGE_TOK:
            	            		case BVSGT_TOK:
            	            		case BVSHL_TOK:
            	            		case BVSLE_TOK:
            	            		case BVSLT_TOK:
            	            		case BVSMOD_TOK:
            	            		case BVSREM_TOK:
            	            		case BVSUB_TOK:
            	            		case BVUDIV_TOK:
            	            		case BVUMINUS_TOK:
            	            		case BVUREM_TOK:
            	            		case BVXNOR_TOK:
            	            		case BVXOR_TOK:
            	            		case BVZEROEXTEND_TOK:
            	            		case DECIMAL_LITERAL:
            	            		case DISTINCT_TOK:
            	            		case DIVISIBLE_TOK:
            	            		case EXISTS_TOK:
            	            		case FALSE_TOK:
            	            		case FLOOR_TOK:
            	            		case FORALL_TOK:
            	            		case HEX_LITERAL:
            	            		case IF_TOK:
            	            		case INTEGER_LITERAL:
            	            		case IS_INTEGER_TOK:
            	            		case LAMBDA:
            	            		case LBRACE:
            	            		case LET_TOK:
            	            		case LPAREN:
            	            		case MINUS_TOK:
            	            		case NOT_TOK:
            	            		case PARENHASH:
            	            		case SETS_CARD_TOK:
            	            		case STRING_CONCAT_TOK:
            	            		case STRING_CONTAINS_TOK:
            	            		case STRING_INDEXOF_TOK:
            	            		case STRING_ITOS_TOK:
            	            		case STRING_LENGTH_TOK:
            	            		case STRING_LITERAL:
            	            		case STRING_PREFIXOF_TOK:
            	            		case STRING_REPLACE_TOK:
            	            		case STRING_STOI_TOK:
            	            		case STRING_STOU16_TOK:
            	            		case STRING_STOU32_TOK:
            	            		case STRING_SUBSTR_TOK:
            	            		case STRING_SUFFIXOF_TOK:
            	            		case STRING_U16TOS_TOK:
            	            		case STRING_U32TOS_TOK:
            	            		case SX_TOK:
            	            		case TRANSCLOSURE_TOK:
            	            		case TRANSPOSE_TOK:
            	            		case TRUE_TOK:
            	            		case TUPLE_TOK:
            	            		case UNIVSET_TOK:
            	            			{
            	            				alt92=1;
            	            			}
            	            		    break;

            	            		}

            	            	}
            	                break;
            	            case LEFTSHIFT_TOK:
            	            case RIGHTSHIFT_TOK:
            	            	{
            	            		alt92=2;
            	            	}
            	                break;
            	            case LPAREN:
            	            	{
            	            		alt92=3;
            	            	}
            	                break;
            	            case DOT:
            	            	{
            	            		alt92=4;
            	            	}
            	                break;

            	            }

            	            switch (alt92)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1730:7: LBRACKET ( formula[f2] |k1= numeral COLON k2= numeral ) RBRACKET
            	        	    {
            	        	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_postfixTerm5676);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1731:9: ( formula[f2] |k1= numeral COLON k2= numeral )
            	        	        {
            	        	            int alt88=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case ABS_TOK:
            	        	            case ARRAY_TOK:
            	        	            case BAR:
            	        	            case BINARY_LITERAL:
            	        	            case BVASHR_TOK:
            	        	            case BVCOMP_TOK:
            	        	            case BVGE_TOK:
            	        	            case BVGT_TOK:
            	        	            case BVLE_TOK:
            	        	            case BVLSHR_TOK:
            	        	            case BVLT_TOK:
            	        	            case BVMULT_TOK:
            	        	            case BVNAND_TOK:
            	        	            case BVNEG_TOK:
            	        	            case BVNOR_TOK:
            	        	            case BVPLUS_TOK:
            	        	            case BVREPEAT_TOK:
            	        	            case BVROTL_TOK:
            	        	            case BVROTR_TOK:
            	        	            case BVSDIV_TOK:
            	        	            case BVSGE_TOK:
            	        	            case BVSGT_TOK:
            	        	            case BVSHL_TOK:
            	        	            case BVSLE_TOK:
            	        	            case BVSLT_TOK:
            	        	            case BVSMOD_TOK:
            	        	            case BVSREM_TOK:
            	        	            case BVSUB_TOK:
            	        	            case BVUDIV_TOK:
            	        	            case BVUMINUS_TOK:
            	        	            case BVUREM_TOK:
            	        	            case BVXNOR_TOK:
            	        	            case BVXOR_TOK:
            	        	            case BVZEROEXTEND_TOK:
            	        	            case DECIMAL_LITERAL:
            	        	            case DISTINCT_TOK:
            	        	            case DIVISIBLE_TOK:
            	        	            case EXISTS_TOK:
            	        	            case FALSE_TOK:
            	        	            case FLOOR_TOK:
            	        	            case FORALL_TOK:
            	        	            case HEX_LITERAL:
            	        	            case IDENTIFIER:
            	        	            case IF_TOK:
            	        	            case IS_INTEGER_TOK:
            	        	            case LAMBDA:
            	        	            case LBRACE:
            	        	            case LET_TOK:
            	        	            case LPAREN:
            	        	            case MINUS_TOK:
            	        	            case NOT_TOK:
            	        	            case PARENHASH:
            	        	            case SETS_CARD_TOK:
            	        	            case STRING_CONCAT_TOK:
            	        	            case STRING_CONTAINS_TOK:
            	        	            case STRING_INDEXOF_TOK:
            	        	            case STRING_ITOS_TOK:
            	        	            case STRING_LENGTH_TOK:
            	        	            case STRING_LITERAL:
            	        	            case STRING_PREFIXOF_TOK:
            	        	            case STRING_REPLACE_TOK:
            	        	            case STRING_STOI_TOK:
            	        	            case STRING_STOU16_TOK:
            	        	            case STRING_STOU32_TOK:
            	        	            case STRING_SUBSTR_TOK:
            	        	            case STRING_SUFFIXOF_TOK:
            	        	            case STRING_U16TOS_TOK:
            	        	            case STRING_U32TOS_TOK:
            	        	            case SX_TOK:
            	        	            case TRANSCLOSURE_TOK:
            	        	            case TRANSPOSE_TOK:
            	        	            case TRUE_TOK:
            	        	            case TUPLE_TOK:
            	        	            case UNIVSET_TOK:
            	        	            	{
            	        	            		alt88=1;
            	        	            	}
            	        	                break;
            	        	            case INTEGER_LITERAL:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case AND_TOK:
            	        	            		case BAR:
            	        	            		case BVAND_TOK:
            	        	            		case CONCAT_TOK:
            	        	            		case DISEQUAL_TOK:
            	        	            		case DIV_TOK:
            	        	            		case DOT:
            	        	            		case EQUAL_TOK:
            	        	            		case EXP_TOK:
            	        	            		case FMF_CARD_TOK:
            	        	            		case GEQ_TOK:
            	        	            		case GT_TOK:
            	        	            		case IFF_TOK:
            	        	            		case IMPLIES_TOK:
            	        	            		case INTDIV_TOK:
            	        	            		case JOIN_TOK:
            	        	            		case LBRACKET:
            	        	            		case LEFTSHIFT_TOK:
            	        	            		case LEQ_TOK:
            	        	            		case LPAREN:
            	        	            		case LT_TOK:
            	        	            		case MEMBER_TOK:
            	        	            		case MINUS_TOK:
            	        	            		case MOD_TOK:
            	        	            		case OR_TOK:
            	        	            		case PLUS_TOK:
            	        	            		case PRODUCT_TOK:
            	        	            		case RBRACKET:
            	        	            		case RIGHTSHIFT_TOK:
            	        	            		case STAR_TOK:
            	        	            		case WITH_TOK:
            	        	            		case XOR_TOK:
            	        	            			{
            	        	            				alt88=1;
            	        	            			}
            	        	            		    break;
            	        	            		case COLON:
            	        	            			{
            	        	            				switch ( LA(3) )
            	        	            				{
            	        	            				case COLON:
            	        	            					{
            	        	            						alt88=1;
            	        	            					}
            	        	            				    break;
            	        	            				case INTEGER_LITERAL:
            	        	            					{
            	        	            						alt88=2;
            	        	            					}
            	        	            				    break;

            	        	            				default:
            	        	            				    if (BACKTRACKING>0)
            	        	            				    {
            	        	            				        FAILEDFLAG = ANTLR3_TRUE;
            	        	            				        return ;
            	        	            				    }

            	        	            				    CONSTRUCTEX();
            	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            				    EXCEPTION->message      = (void *)"";
            	        	            				    EXCEPTION->decisionNum  = 88;
            	        	            				    EXCEPTION->state        = 81;


            	        	            				    goto rulepostfixTermEx;

            	        	            				}

            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    if (BACKTRACKING>0)
            	        	            		    {
            	        	            		        FAILEDFLAG = ANTLR3_TRUE;
            	        	            		        return ;
            	        	            		    }

            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 88;
            	        	            		    EXCEPTION->state        = 67;


            	        	            		    goto rulepostfixTermEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return ;
            	        	                }

            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 88;
            	        	                EXCEPTION->state        = 0;


            	        	                goto rulepostfixTermEx;

            	        	            }

            	        	            switch (alt88)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1731:11: formula[f2]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm5688);
            	        	        	        formula(ctx, f2);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        if ( BACKTRACKING==0 )
            	        	        	        {
            	        	        	             extract = false; 
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1732:11: k1= numeral COLON k2= numeral
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_numeral_in_postfixTerm5705);
            	        	        	        k1=numeral(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	         MATCHT(COLON, &FOLLOW_COLON_in_postfixTerm5707);
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        FOLLOWPUSH(FOLLOW_numeral_in_postfixTerm5711);
            	        	        	        k2=numeral(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        if ( BACKTRACKING==0 )
            	        	        	        {
            	        	        	             extract = true; 
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	         MATCHT(RBRACKET, &FOLLOW_RBRACKET_in_postfixTerm5723);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {
            	        	             if(extract) {
            	        	                      /* bitvector extract */
            	        	                      f = MK_EXPR(MK_CONST(BitVectorExtract(k1, k2)), f);
            	        	                    } else {
            	        	                      /* array select */
            	        	                      f = MK_EXPR(CVC4::kind::SELECT, f, f2);
            	        	                    }
            	        	                  
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1743:7: ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK ) k= numeral
            	        	    {
            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1743:7: ( LEFTSHIFT_TOK | RIGHTSHIFT_TOK )
            	        	        {
            	        	            int alt89=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case LEFTSHIFT_TOK:
            	        	            	{
            	        	            		alt89=1;
            	        	            	}
            	        	                break;
            	        	            case RIGHTSHIFT_TOK:
            	        	            	{
            	        	            		alt89=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return ;
            	        	                }

            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 89;
            	        	                EXCEPTION->state        = 0;


            	        	                goto rulepostfixTermEx;

            	        	            }

            	        	            switch (alt89)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1743:9: LEFTSHIFT_TOK
            	        	        	    {
            	        	        	         MATCHT(LEFTSHIFT_TOK, &FOLLOW_LEFTSHIFT_TOK_in_postfixTerm5749);
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        if ( BACKTRACKING==0 )
            	        	        	        {
            	        	        	             left = true; 
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1744:9: RIGHTSHIFT_TOK
            	        	        	    {
            	        	        	         MATCHT(RIGHTSHIFT_TOK, &FOLLOW_RIGHTSHIFT_TOK_in_postfixTerm5761);
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        if ( BACKTRACKING==0 )
            	        	        	        {
            	        	        	             left = false; 
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_numeral_in_postfixTerm5769);
            	        	        k=numeral(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {
            	        	             // Defined in:
            	        	                    // http://www.cs.nyu.edu/acsys/cvc3/doc/user_doc.html#user_doc_pres_lang_expr_bit
            	        	                    if(left) {
            	        	                      f = MK_EXPR(kind::BITVECTOR_CONCAT, f, MK_CONST(BitVector(k)));
            	        	                    } else {
            	        	                      unsigned n = BitVectorType(f.getType()).getSize();
            	        	                      f = MK_EXPR(kind::BITVECTOR_CONCAT, MK_CONST(BitVector(k)),
            	        	                                  MK_EXPR(MK_CONST(BitVectorExtract(n - 1, k)), f));
            	        	                    }
            	        	                  
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1757:7: LPAREN formula[f] ( COMMA formula[f] )* RPAREN
            	        	    {
            	        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_postfixTerm5794);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {
            	        	             args.push_back(f); 
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm5804);
            	        	        formula(ctx, f);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {
            	        	             args.push_back(f); 
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1759:7: ( COMMA formula[f] )*

            	        	        for (;;)
            	        	        {
            	        	            int alt90=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case COMMA:
            	        	            	{
            	        	            		alt90=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt90)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1759:9: COMMA formula[f]
            	        	        	    {
            	        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_postfixTerm5817);
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm5819);
            	        	        	        formula(ctx, f);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        if ( BACKTRACKING==0 )
            	        	        	        {
            	        	        	             args.push_back(f); 
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop90;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop90: ; /* Jump out to here if this rule does not match */


            	        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_postfixTerm5827);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {
            	        	             Type t = args.front().getType();
            	        	                    Debug("parser") << "type is " << t << std::endl;
            	        	                    Debug("parser") << "expr is " << args.front() << std::endl;
            	        	                    if(PARSER_STATE->isDefinedFunction(args.front())) {
            	        	                      f = MK_EXPR(CVC4::kind::APPLY, args);
            	        	                    } else if(t.isFunction()) {
            	        	                      f = MK_EXPR(CVC4::kind::APPLY_UF, args);
            	        	                    } else if(t.isConstructor()) {
            	        	                      f = MK_EXPR(CVC4::kind::APPLY_CONSTRUCTOR, args);
            	        	                    } else if(t.isSelector()) {
            	        	                      f = MK_EXPR(CVC4::kind::APPLY_SELECTOR, args);
            	        	                    } else if(t.isTester()) {
            	        	                      f = MK_EXPR(CVC4::kind::APPLY_TESTER, args);
            	        	                    } else {
            	        	                      PARSER_STATE->parseError("internal error: unhandled function application kind");
            	        	                    }
            	        	                  
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1780:7: DOT ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral )
            	        	    {
            	        	         MATCHT(DOT, &FOLLOW_DOT_in_postfixTerm5859);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // ../../../../../../src/parser/cvc/Cvc.g:1781:7: ( identifier[id,CHECK_NONE,SYM_VARIABLE] |k= numeral )
            	        	        {
            	        	            int alt91=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case IDENTIFIER:
            	        	            	{
            	        	            		alt91=1;
            	        	            	}
            	        	                break;
            	        	            case INTEGER_LITERAL:
            	        	            	{
            	        	            		alt91=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return ;
            	        	                }

            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 91;
            	        	                EXCEPTION->state        = 0;


            	        	                goto rulepostfixTermEx;

            	        	            }

            	        	            switch (alt91)
            	        	            {
            	        	        	case 1:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1781:9: identifier[id,CHECK_NONE,SYM_VARIABLE]
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_identifier_in_postfixTerm5869);
            	        	        	        identifier(ctx, id, CHECK_NONE, SYM_VARIABLE);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        if ( BACKTRACKING==0 )
            	        	        	        {
            	        	        	             Type t = f.getType();
            	        	        	                      if(! t.isRecord()) {
            	        	        	                        PARSER_STATE->parseError("record-select applied to non-record");
            	        	        	                      }
            	        	        	                      const Record& rec = ((DatatypeType)t).getRecord();
            	        	        	                      if(!rec.contains(id)){
            	        	        	                        PARSER_STATE->parseError(std::string("no such field `") + id + "' in record");
            	        	        	                      }
            	        	        	                      const Datatype & dt = ((DatatypeType)t).getDatatype();
            	        	        	                      std::vector<Expr> sargs;
            	        	        	                      sargs.push_back( dt[0][id].getSelector() );
            	        	        	                      sargs.push_back( f );
            	        	        	                      f = MK_EXPR(CVC4::kind::APPLY_SELECTOR_TOTAL,sargs);
            	        	        	                    
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // ../../../../../../src/parser/cvc/Cvc.g:1796:9: k= numeral
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_numeral_in_postfixTerm5892);
            	        	        	        k=numeral(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulepostfixTermEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        if ( BACKTRACKING==0 )
            	        	        	        {
            	        	        	             Type t = f.getType();
            	        	        	                      if(! t.isTuple()) {
            	        	        	                        PARSER_STATE->parseError("tuple-select applied to non-tuple");
            	        	        	                      }
            	        	        	                      size_t length = ((DatatypeType)t).getTupleLength();
            	        	        	                      if(k >= length) {
            	        	        	                        std::stringstream ss;
            	        	        	                        ss << "tuple is of length " << length << "; cannot access index " << k;
            	        	        	                        PARSER_STATE->parseError(ss.str());
            	        	        	                      }
            	        	        	                      const Datatype & dt = ((DatatypeType)t).getDatatype();
            	        	        	                      std::vector<Expr> sargs;
            	        	        	                      sargs.push_back( dt[0][k].getSelector() );
            	        	        	                      sargs.push_back( f );
            	        	        	                      f = MK_EXPR(CVC4::kind::APPLY_SELECTOR_TOTAL,sargs);
            	        	        	                    
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop92;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop92: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1815:7: FLOOR_TOK LPAREN formula[f] RPAREN
            	    {
            	         MATCHT(FLOOR_TOK, &FOLLOW_FLOOR_TOK_in_postfixTerm5925);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_postfixTerm5927);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm5929);
            	        formula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_postfixTerm5932);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = MK_EXPR(CVC4::kind::TO_INTEGER, f); 
            	        }


            	    }
            	    break;
            	case 3:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1817:7: IS_INTEGER_TOK LPAREN formula[f] RPAREN
            	    {
            	         MATCHT(IS_INTEGER_TOK, &FOLLOW_IS_INTEGER_TOK_in_postfixTerm5948);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_postfixTerm5950);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm5952);
            	        formula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_postfixTerm5955);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = MK_EXPR(CVC4::kind::IS_INTEGER, f); 
            	        }


            	    }
            	    break;
            	case 4:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1819:7: ABS_TOK LPAREN formula[f] RPAREN
            	    {
            	         MATCHT(ABS_TOK, &FOLLOW_ABS_TOK_in_postfixTerm5971);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_postfixTerm5973);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm5975);
            	        formula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_postfixTerm5978);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = MK_EXPR(CVC4::kind::ABS, f); 
            	        }


            	    }
            	    break;
            	case 5:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1821:7: DIVISIBLE_TOK LPAREN formula[f] COMMA n= numeral RPAREN
            	    {
            	         MATCHT(DIVISIBLE_TOK, &FOLLOW_DIVISIBLE_TOK_in_postfixTerm5994);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_postfixTerm5996);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm5998);
            	        formula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(COMMA, &FOLLOW_COMMA_in_postfixTerm6001);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_numeral_in_postfixTerm6005);
            	        n=numeral(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_postfixTerm6007);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = MK_EXPR(CVC4::kind::DIVISIBLE, MK_CONST(CVC4::Divisible(n)), f); 
            	        }


            	    }
            	    break;
            	case 6:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1823:7: DISTINCT_TOK LPAREN formula[f] ( COMMA formula[f] )* RPAREN
            	    {
            	         MATCHT(DISTINCT_TOK, &FOLLOW_DISTINCT_TOK_in_postfixTerm6023);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_postfixTerm6025);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm6033);
            	        formula(ctx, f);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             args.push_back(f); 
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:1825:7: ( COMMA formula[f] )*

            	        for (;;)
            	        {
            	            int alt93=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt93=1;
            	            	}
            	                break;

            	            }

            	            switch (alt93)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:1825:9: COMMA formula[f]
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_postfixTerm6046);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_formula_in_postfixTerm6048);
            	        	        formula(ctx, f);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepostfixTermEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {
            	        	             args.push_back(f); 
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop93;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop93: ; /* Jump out to here if this rule does not match */


            	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_postfixTerm6056);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             f = (args.size() == 1) ? MK_CONST(bool(true)) : MK_EXPR(CVC4::kind::DISTINCT, args); 
            	        }


            	    }
            	    break;

                }
            }

            // ../../../../../../src/parser/cvc/Cvc.g:1828:5: ( typeAscription[f, t] )?
            {
                int alt95=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case COLON:
                    		    	{
                    		    		alt95=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt95)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:1828:7: typeAscription[f, t]
            	    {
            	        FOLLOWPUSH(FOLLOW_typeAscription_in_postfixTerm6078);
            	        typeAscription(ctx, f, t);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixTermEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             if(f.getKind() == CVC4::kind::APPLY_CONSTRUCTOR && t.isDatatype()) {
            	                      std::vector<CVC4::Expr> v;
            	                      Expr e = f.getOperator();
            	                      const DatatypeConstructor& dtc = Datatype::datatypeOf(e)[Datatype::indexOf(e)];
            	                      v.push_back(MK_EXPR( CVC4::kind::APPLY_TYPE_ASCRIPTION,
            	                                           MK_CONST(AscriptionType(dtc.getSpecializedConstructorType(t))), f.getOperator() ));
            	                      v.insert(v.end(), f.begin(), f.end());
            	                      f = MK_EXPR(CVC4::kind::APPLY_CONSTRUCTOR, v);
            	                    } else if(f.getKind() == CVC4::kind::EMPTYSET && t.isSet()) {
            	                      f = MK_CONST(CVC4::EmptySet(t));
            	                    } else if(f.getKind() == CVC4::kind::UNIVERSE_SET && t.isSet()) {
            	                      f = EXPR_MANAGER->mkUniqueVar(t, kind::UNIVERSE_SET);
            	                    } else {
            	                      if(f.getType() != t) {
            	                        PARSER_STATE->parseError("Type ascription not satisfied.");
            	                      }
            	                    }
            	                  
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepostfixTermEx; /* Prevent compiler warnings */
    rulepostfixTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end postfixTerm */

/**
 * $ANTLR start bvTerm
 * ../../../../../../src/parser/cvc/Cvc.g:1850:1: bvTerm[CVC4::Expr& f] : ( BVXOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVNAND_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVNOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVCOMP_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVXNOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVUMINUS_TOK LPAREN formula[f] RPAREN | BVPLUS_TOK LPAREN k= numeral COMMA formula[f] ( COMMA formula[f2] )+ RPAREN | BVSUB_TOK LPAREN k= numeral COMMA formula[f] COMMA formula[f2] RPAREN | BVMULT_TOK LPAREN k= numeral COMMA formula[f] COMMA formula[f2] RPAREN | BVUDIV_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSDIV_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVUREM_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSREM_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSMOD_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSHL_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVASHR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVLSHR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | SX_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVZEROEXTEND_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVREPEAT_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVROTR_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVROTL_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVLT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVLE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVGT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVGE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSLT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSLE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSGT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSGE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | stringTerm[f] );
 */
static void
bvTerm(pCvcParser ctx, CVC4::Expr& f)
{
    unsigned k;
    #undef	RETURN_TYPE_k
    #define	RETURN_TYPE_k unsigned

    /* Initialize rule variables
     */


      Expr f2;
      std::vector<Expr> args;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1856:3: ( BVXOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVNAND_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVNOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVCOMP_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVXNOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVUMINUS_TOK LPAREN formula[f] RPAREN | BVPLUS_TOK LPAREN k= numeral COMMA formula[f] ( COMMA formula[f2] )+ RPAREN | BVSUB_TOK LPAREN k= numeral COMMA formula[f] COMMA formula[f2] RPAREN | BVMULT_TOK LPAREN k= numeral COMMA formula[f] COMMA formula[f2] RPAREN | BVUDIV_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSDIV_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVUREM_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSREM_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSMOD_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSHL_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVASHR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVLSHR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | SX_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVZEROEXTEND_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVREPEAT_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVROTR_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVROTL_TOK LPAREN formula[f] COMMA k= numeral RPAREN | BVLT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVLE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVGT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVGE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSLT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSLE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSGT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | BVSGE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | stringTerm[f] )

            ANTLR3_UINT32 alt97;

            alt97=31;

            switch ( LA(1) )
            {
            case BVXOR_TOK:
            	{
            		alt97=1;
            	}
                break;
            case BVNAND_TOK:
            	{
            		alt97=2;
            	}
                break;
            case BVNOR_TOK:
            	{
            		alt97=3;
            	}
                break;
            case BVCOMP_TOK:
            	{
            		alt97=4;
            	}
                break;
            case BVXNOR_TOK:
            	{
            		alt97=5;
            	}
                break;
            case BVUMINUS_TOK:
            	{
            		alt97=6;
            	}
                break;
            case BVPLUS_TOK:
            	{
            		alt97=7;
            	}
                break;
            case BVSUB_TOK:
            	{
            		alt97=8;
            	}
                break;
            case BVMULT_TOK:
            	{
            		alt97=9;
            	}
                break;
            case BVUDIV_TOK:
            	{
            		alt97=10;
            	}
                break;
            case BVSDIV_TOK:
            	{
            		alt97=11;
            	}
                break;
            case BVUREM_TOK:
            	{
            		alt97=12;
            	}
                break;
            case BVSREM_TOK:
            	{
            		alt97=13;
            	}
                break;
            case BVSMOD_TOK:
            	{
            		alt97=14;
            	}
                break;
            case BVSHL_TOK:
            	{
            		alt97=15;
            	}
                break;
            case BVASHR_TOK:
            	{
            		alt97=16;
            	}
                break;
            case BVLSHR_TOK:
            	{
            		alt97=17;
            	}
                break;
            case SX_TOK:
            	{
            		alt97=18;
            	}
                break;
            case BVZEROEXTEND_TOK:
            	{
            		alt97=19;
            	}
                break;
            case BVREPEAT_TOK:
            	{
            		alt97=20;
            	}
                break;
            case BVROTR_TOK:
            	{
            		alt97=21;
            	}
                break;
            case BVROTL_TOK:
            	{
            		alt97=22;
            	}
                break;
            case BVLT_TOK:
            	{
            		alt97=23;
            	}
                break;
            case BVLE_TOK:
            	{
            		alt97=24;
            	}
                break;
            case BVGT_TOK:
            	{
            		alt97=25;
            	}
                break;
            case BVGE_TOK:
            	{
            		alt97=26;
            	}
                break;
            case BVSLT_TOK:
            	{
            		alt97=27;
            	}
                break;
            case BVSLE_TOK:
            	{
            		alt97=28;
            	}
                break;
            case BVSGT_TOK:
            	{
            		alt97=29;
            	}
                break;
            case BVSGE_TOK:
            	{
            		alt97=30;
            	}
                break;
            case ARRAY_TOK:
            case BAR:
            case BINARY_LITERAL:
            case DECIMAL_LITERAL:
            case FALSE_TOK:
            case HEX_LITERAL:
            case IDENTIFIER:
            case IF_TOK:
            case INTEGER_LITERAL:
            case LBRACE:
            case LPAREN:
            case PARENHASH:
            case SETS_CARD_TOK:
            case STRING_CONCAT_TOK:
            case STRING_CONTAINS_TOK:
            case STRING_INDEXOF_TOK:
            case STRING_ITOS_TOK:
            case STRING_LENGTH_TOK:
            case STRING_LITERAL:
            case STRING_PREFIXOF_TOK:
            case STRING_REPLACE_TOK:
            case STRING_STOI_TOK:
            case STRING_STOU16_TOK:
            case STRING_STOU32_TOK:
            case STRING_SUBSTR_TOK:
            case STRING_SUFFIXOF_TOK:
            case STRING_U16TOS_TOK:
            case STRING_U32TOS_TOK:
            case TRUE_TOK:
            case UNIVSET_TOK:
            	{
            		alt97=31;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 97;
                EXCEPTION->state        = 0;


                goto rulebvTermEx;

            }

            switch (alt97)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1856:5: BVXOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVXOR_TOK, &FOLLOW_BVXOR_TOK_in_bvTerm6119);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6121);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6123);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6126);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6128);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6131);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_XOR, f, f2); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1858:5: BVNAND_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVNAND_TOK, &FOLLOW_BVNAND_TOK_in_bvTerm6143);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6145);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6147);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6150);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6152);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6155);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_NAND, f, f2); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1860:5: BVNOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVNOR_TOK, &FOLLOW_BVNOR_TOK_in_bvTerm6167);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6169);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6171);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6174);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6176);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6179);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_NOR, f, f2); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1862:5: BVCOMP_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVCOMP_TOK, &FOLLOW_BVCOMP_TOK_in_bvTerm6191);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6193);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6195);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6198);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6200);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6203);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_COMP, f, f2); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1864:5: BVXNOR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVXNOR_TOK, &FOLLOW_BVXNOR_TOK_in_bvTerm6215);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6217);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6219);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6222);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6224);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6227);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_XNOR, f, f2); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1868:5: BVUMINUS_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(BVUMINUS_TOK, &FOLLOW_BVUMINUS_TOK_in_bvTerm6246);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6248);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6250);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6253);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_NEG, f); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1871:5: BVPLUS_TOK LPAREN k= numeral COMMA formula[f] ( COMMA formula[f2] )+ RPAREN
        	    {
        	         MATCHT(BVPLUS_TOK, &FOLLOW_BVPLUS_TOK_in_bvTerm6271);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6273);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6277);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6279);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6281);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1872:5: ( COMMA formula[f2] )+
        	        {
        	            int cnt96=0;

        	            for (;;)
        	            {
        	                int alt96=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case COMMA:
        	        		{
        	        			alt96=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt96)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:1872:7: COMMA formula[f2]
        	        	        {
        	        	             MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6292);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebvTermEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_formula_in_bvTerm6294);
        	        	            formula(ctx, f2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebvTermEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }


        	        	            if ( BACKTRACKING==0 )
        	        	            {
        	        	                 args.push_back(f2); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt96 >= 1 )
        	        		{
        	        		    goto loop96;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    return ;
        	        		}

        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulebvTermEx;
        	        	}
        	        	cnt96++;
        	            }
        	            loop96: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6302);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                  if (k <= 0) {
        	                    PARSER_STATE->parseError("BVPLUS(k,_,_) must have k > 0");
        	                  }
        	                  for (unsigned i = 0; i < args.size(); ++ i) {
        	                    ENSURE_BV_SIZE(k, args[i]);
        	                  }
        	                  f = MK_EXPR(CVC4::kind::BITVECTOR_PLUS, args);
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1883:5: BVSUB_TOK LPAREN k= numeral COMMA formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSUB_TOK, &FOLLOW_BVSUB_TOK_in_bvTerm6320);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6322);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6326);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6328);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6330);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6333);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6335);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6338);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                  if (k <= 0) {
        	                    PARSER_STATE->parseError("BVSUB(k,_,_) must have k > 0");
        	                  }
        	                  ENSURE_BV_SIZE(k, f);
        	                  ENSURE_BV_SIZE(k, f2);
        	                  f = MK_EXPR(CVC4::kind::BITVECTOR_SUB, f, f2);
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1893:5: BVMULT_TOK LPAREN k= numeral COMMA formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVMULT_TOK, &FOLLOW_BVMULT_TOK_in_bvTerm6356);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6358);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6362);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6364);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6366);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6369);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6371);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6374);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                  if (k <= 0) {
        	                    PARSER_STATE->parseError("BVMULT(k,_,_) must have k > 0");
        	                  }
        	                  ENSURE_BV_SIZE(k, f);
        	                  ENSURE_BV_SIZE(k, f2);
        	                  f = MK_EXPR(CVC4::kind::BITVECTOR_MULT, f, f2);
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1903:5: BVUDIV_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVUDIV_TOK, &FOLLOW_BVUDIV_TOK_in_bvTerm6392);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6394);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6396);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6399);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6401);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6404);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_UDIV, f, f2); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1906:5: BVSDIV_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSDIV_TOK, &FOLLOW_BVSDIV_TOK_in_bvTerm6422);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6424);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6426);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6429);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6431);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6434);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SDIV, f, f2); 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1909:5: BVUREM_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVUREM_TOK, &FOLLOW_BVUREM_TOK_in_bvTerm6452);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6454);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6456);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6459);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6461);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6464);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_UREM, f, f2); 
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1912:5: BVSREM_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSREM_TOK, &FOLLOW_BVSREM_TOK_in_bvTerm6482);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6484);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6486);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6489);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6491);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6494);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SREM, f, f2); 
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1915:5: BVSMOD_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSMOD_TOK, &FOLLOW_BVSMOD_TOK_in_bvTerm6512);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6514);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6516);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6519);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6521);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6524);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SMOD, f, f2); 
        	        }


        	    }
        	    break;
        	case 15:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1918:5: BVSHL_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSHL_TOK, &FOLLOW_BVSHL_TOK_in_bvTerm6542);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6544);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6546);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6549);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6551);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6554);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SHL, f, f2); 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1921:5: BVASHR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVASHR_TOK, &FOLLOW_BVASHR_TOK_in_bvTerm6572);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6574);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6576);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6579);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6581);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6584);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_ASHR, f, f2); 
        	        }


        	    }
        	    break;
        	case 17:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1924:5: BVLSHR_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVLSHR_TOK, &FOLLOW_BVLSHR_TOK_in_bvTerm6602);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6604);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6606);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6609);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6611);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6614);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_LSHR, f, f2); 
        	        }


        	    }
        	    break;
        	case 18:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1927:5: SX_TOK LPAREN formula[f] COMMA k= numeral RPAREN
        	    {
        	         MATCHT(SX_TOK, &FOLLOW_SX_TOK_in_bvTerm6632);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6634);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6636);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6639);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6643);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6645);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             unsigned n = BitVectorType(f.getType()).getSize();
        	                  // Sign extension in TheoryBitVector is defined as in SMT-LIB
        	                  // which is different than in the CVC language
        	                  // SX(BITVECTOR(k), n) in CVC language extends to n bits
        	                  // In SMT-LIB, such a thing expands to k + n bits
        	                  f = MK_EXPR(MK_CONST(BitVectorSignExtend(k - n)), f); 
        	        }


        	    }
        	    break;
        	case 19:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1935:5: BVZEROEXTEND_TOK LPAREN formula[f] COMMA k= numeral RPAREN
        	    {
        	         MATCHT(BVZEROEXTEND_TOK, &FOLLOW_BVZEROEXTEND_TOK_in_bvTerm6663);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6665);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6667);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6670);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6674);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6676);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             unsigned n = BitVectorType(f.getType()).getSize();
        	                  // Zero extension in TheoryBitVector is defined as in SMT-LIB
        	                  // which is the same as in CVC3, but different than SX!
        	                  // SX(BITVECTOR(k), n) in CVC language extends to n bits
        	                  // BVZEROEXTEND(BITVECTOR(k), n) in CVC language extends to k + n bits
        	                  f = MK_EXPR(MK_CONST(BitVectorZeroExtend(k)), f); 
        	        }


        	    }
        	    break;
        	case 20:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1943:5: BVREPEAT_TOK LPAREN formula[f] COMMA k= numeral RPAREN
        	    {
        	         MATCHT(BVREPEAT_TOK, &FOLLOW_BVREPEAT_TOK_in_bvTerm6694);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6696);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6698);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6701);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6705);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6707);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(MK_CONST(BitVectorRepeat(k)), f); 
        	        }


        	    }
        	    break;
        	case 21:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1946:5: BVROTR_TOK LPAREN formula[f] COMMA k= numeral RPAREN
        	    {
        	         MATCHT(BVROTR_TOK, &FOLLOW_BVROTR_TOK_in_bvTerm6725);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6727);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6729);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6732);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6736);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6738);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(MK_CONST(BitVectorRotateRight(k)), f); 
        	        }


        	    }
        	    break;
        	case 22:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1949:5: BVROTL_TOK LPAREN formula[f] COMMA k= numeral RPAREN
        	    {
        	         MATCHT(BVROTL_TOK, &FOLLOW_BVROTL_TOK_in_bvTerm6756);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6758);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6760);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6763);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_numeral_in_bvTerm6767);
        	        k=numeral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6769);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(MK_CONST(BitVectorRotateLeft(k)), f); 
        	        }


        	    }
        	    break;
        	case 23:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1953:5: BVLT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVLT_TOK, &FOLLOW_BVLT_TOK_in_bvTerm6788);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6790);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6792);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6795);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6797);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6800);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_ULT, f, f2); 
        	        }


        	    }
        	    break;
        	case 24:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1955:5: BVLE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVLE_TOK, &FOLLOW_BVLE_TOK_in_bvTerm6812);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6814);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6816);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6819);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6821);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6824);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_ULE, f, f2); 
        	        }


        	    }
        	    break;
        	case 25:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1957:5: BVGT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVGT_TOK, &FOLLOW_BVGT_TOK_in_bvTerm6836);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6838);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6840);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6843);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6845);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6848);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_UGT, f, f2); 
        	        }


        	    }
        	    break;
        	case 26:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1959:5: BVGE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVGE_TOK, &FOLLOW_BVGE_TOK_in_bvTerm6860);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6862);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6864);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6867);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6869);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6872);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_UGE, f, f2); 
        	        }


        	    }
        	    break;
        	case 27:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1961:5: BVSLT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSLT_TOK, &FOLLOW_BVSLT_TOK_in_bvTerm6884);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6886);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6888);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6891);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6893);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6896);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SLT, f, f2); 
        	        }


        	    }
        	    break;
        	case 28:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1963:5: BVSLE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSLE_TOK, &FOLLOW_BVSLE_TOK_in_bvTerm6908);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6910);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6912);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6915);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6917);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6920);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SLE, f, f2); 
        	        }


        	    }
        	    break;
        	case 29:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1965:5: BVSGT_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSGT_TOK, &FOLLOW_BVSGT_TOK_in_bvTerm6932);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6934);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6936);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6939);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6941);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6944);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SGT, f, f2); 
        	        }


        	    }
        	    break;
        	case 30:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1967:5: BVSGE_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(BVSGE_TOK, &FOLLOW_BVSGE_TOK_in_bvTerm6956);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_bvTerm6958);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6960);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_bvTerm6963);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_bvTerm6965);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_bvTerm6968);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::BITVECTOR_SGE, f, f2); 
        	        }


        	    }
        	    break;
        	case 31:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1969:5: stringTerm[f]
        	    {
        	        FOLLOWPUSH(FOLLOW_stringTerm_in_bvTerm6980);
        	        stringTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebvTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebvTermEx; /* Prevent compiler warnings */
    rulebvTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bvTerm */

/**
 * $ANTLR start stringTerm
 * ../../../../../../src/parser/cvc/Cvc.g:1972:1: stringTerm[CVC4::Expr& f] : ( STRING_CONCAT_TOK LPAREN formula[f] ( COMMA formula[f2] )+ RPAREN | STRING_LENGTH_TOK LPAREN formula[f] RPAREN | STRING_CONTAINS_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | STRING_SUBSTR_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN | STRING_INDEXOF_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN | STRING_REPLACE_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN | STRING_PREFIXOF_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | STRING_SUFFIXOF_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | STRING_STOI_TOK LPAREN formula[f] RPAREN | STRING_ITOS_TOK LPAREN formula[f] RPAREN | STRING_U16TOS_TOK LPAREN formula[f] RPAREN | STRING_STOU16_TOK LPAREN formula[f] RPAREN | STRING_U32TOS_TOK LPAREN formula[f] RPAREN | STRING_STOU32_TOK LPAREN formula[f] RPAREN | str[s] | setsTerm[f] );
 */
static void
stringTerm(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      Expr f2;
      Expr f3;
      std::string s;
      std::vector<Expr> args;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:1980:3: ( STRING_CONCAT_TOK LPAREN formula[f] ( COMMA formula[f2] )+ RPAREN | STRING_LENGTH_TOK LPAREN formula[f] RPAREN | STRING_CONTAINS_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | STRING_SUBSTR_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN | STRING_INDEXOF_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN | STRING_REPLACE_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN | STRING_PREFIXOF_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | STRING_SUFFIXOF_TOK LPAREN formula[f] COMMA formula[f2] RPAREN | STRING_STOI_TOK LPAREN formula[f] RPAREN | STRING_ITOS_TOK LPAREN formula[f] RPAREN | STRING_U16TOS_TOK LPAREN formula[f] RPAREN | STRING_STOU16_TOK LPAREN formula[f] RPAREN | STRING_U32TOS_TOK LPAREN formula[f] RPAREN | STRING_STOU32_TOK LPAREN formula[f] RPAREN | str[s] | setsTerm[f] )

            ANTLR3_UINT32 alt99;

            alt99=16;

            switch ( LA(1) )
            {
            case STRING_CONCAT_TOK:
            	{
            		alt99=1;
            	}
                break;
            case STRING_LENGTH_TOK:
            	{
            		alt99=2;
            	}
                break;
            case STRING_CONTAINS_TOK:
            	{
            		alt99=3;
            	}
                break;
            case STRING_SUBSTR_TOK:
            	{
            		alt99=4;
            	}
                break;
            case STRING_INDEXOF_TOK:
            	{
            		alt99=5;
            	}
                break;
            case STRING_REPLACE_TOK:
            	{
            		alt99=6;
            	}
                break;
            case STRING_PREFIXOF_TOK:
            	{
            		alt99=7;
            	}
                break;
            case STRING_SUFFIXOF_TOK:
            	{
            		alt99=8;
            	}
                break;
            case STRING_STOI_TOK:
            	{
            		alt99=9;
            	}
                break;
            case STRING_ITOS_TOK:
            	{
            		alt99=10;
            	}
                break;
            case STRING_U16TOS_TOK:
            	{
            		alt99=11;
            	}
                break;
            case STRING_STOU16_TOK:
            	{
            		alt99=12;
            	}
                break;
            case STRING_U32TOS_TOK:
            	{
            		alt99=13;
            	}
                break;
            case STRING_STOU32_TOK:
            	{
            		alt99=14;
            	}
                break;
            case STRING_LITERAL:
            	{
            		alt99=15;
            	}
                break;
            case ARRAY_TOK:
            case BAR:
            case BINARY_LITERAL:
            case DECIMAL_LITERAL:
            case FALSE_TOK:
            case HEX_LITERAL:
            case IDENTIFIER:
            case IF_TOK:
            case INTEGER_LITERAL:
            case LBRACE:
            case LPAREN:
            case PARENHASH:
            case SETS_CARD_TOK:
            case TRUE_TOK:
            case UNIVSET_TOK:
            	{
            		alt99=16;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 99;
                EXCEPTION->state        = 0;


                goto rulestringTermEx;

            }

            switch (alt99)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1980:5: STRING_CONCAT_TOK LPAREN formula[f] ( COMMA formula[f2] )+ RPAREN
        	    {
        	         MATCHT(STRING_CONCAT_TOK, &FOLLOW_STRING_CONCAT_TOK_in_stringTerm7006);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7008);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7010);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:1981:5: ( COMMA formula[f2] )+
        	        {
        	            int cnt98=0;

        	            for (;;)
        	            {
        	                int alt98=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case COMMA:
        	        		{
        	        			alt98=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt98)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/cvc/Cvc.g:1981:7: COMMA formula[f2]
        	        	        {
        	        	             MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7021);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulestringTermEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_formula_in_stringTerm7023);
        	        	            formula(ctx, f2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulestringTermEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }


        	        	            if ( BACKTRACKING==0 )
        	        	            {
        	        	                 args.push_back(f2); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt98 >= 1 )
        	        		{
        	        		    goto loop98;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    return ;
        	        		}

        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulestringTermEx;
        	        	}
        	        	cnt98++;
        	            }
        	            loop98: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7031);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_CONCAT, args); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1983:5: STRING_LENGTH_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(STRING_LENGTH_TOK, &FOLLOW_STRING_LENGTH_TOK_in_stringTerm7043);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7045);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7047);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7050);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_LENGTH, f); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1985:5: STRING_CONTAINS_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(STRING_CONTAINS_TOK, &FOLLOW_STRING_CONTAINS_TOK_in_stringTerm7062);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7064);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7066);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7069);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7071);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7074);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_STRCTN, f, f2); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1987:5: STRING_SUBSTR_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN
        	    {
        	         MATCHT(STRING_SUBSTR_TOK, &FOLLOW_STRING_SUBSTR_TOK_in_stringTerm7086);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7088);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7090);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7093);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7095);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7098);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7100);
        	        formula(ctx, f3);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7103);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_SUBSTR, f, f2, f3); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1989:5: STRING_INDEXOF_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN
        	    {
        	         MATCHT(STRING_INDEXOF_TOK, &FOLLOW_STRING_INDEXOF_TOK_in_stringTerm7115);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7117);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7119);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7122);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7124);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7127);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7129);
        	        formula(ctx, f3);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7132);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_STRIDOF, f, f2, f3); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1991:5: STRING_REPLACE_TOK LPAREN formula[f] COMMA formula[f2] COMMA formula[f3] RPAREN
        	    {
        	         MATCHT(STRING_REPLACE_TOK, &FOLLOW_STRING_REPLACE_TOK_in_stringTerm7144);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7146);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7148);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7151);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7153);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7156);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7158);
        	        formula(ctx, f3);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7161);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_STRREPL, f, f2, f3); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1993:5: STRING_PREFIXOF_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(STRING_PREFIXOF_TOK, &FOLLOW_STRING_PREFIXOF_TOK_in_stringTerm7173);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7175);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7177);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7180);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7182);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7185);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_PREFIX, f, f2); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1995:5: STRING_SUFFIXOF_TOK LPAREN formula[f] COMMA formula[f2] RPAREN
        	    {
        	         MATCHT(STRING_SUFFIXOF_TOK, &FOLLOW_STRING_SUFFIXOF_TOK_in_stringTerm7197);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7199);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7201);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COMMA, &FOLLOW_COMMA_in_stringTerm7204);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7206);
        	        formula(ctx, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7209);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_SUFFIX, f, f2); 
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1997:5: STRING_STOI_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(STRING_STOI_TOK, &FOLLOW_STRING_STOI_TOK_in_stringTerm7221);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7223);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7225);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7228);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_STOI, f); 
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/cvc/Cvc.g:1999:5: STRING_ITOS_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(STRING_ITOS_TOK, &FOLLOW_STRING_ITOS_TOK_in_stringTerm7240);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7242);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7244);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7247);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_ITOS, f); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2001:5: STRING_U16TOS_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(STRING_U16TOS_TOK, &FOLLOW_STRING_U16TOS_TOK_in_stringTerm7259);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7261);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7263);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7266);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_U16TOS, f); 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2003:5: STRING_STOU16_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(STRING_STOU16_TOK, &FOLLOW_STRING_STOU16_TOK_in_stringTerm7278);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7280);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7282);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7285);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_STOU16, f); 
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2005:5: STRING_U32TOS_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(STRING_U32TOS_TOK, &FOLLOW_STRING_U32TOS_TOK_in_stringTerm7297);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7299);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7301);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7304);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_U32TOS, f); 
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2007:5: STRING_STOU32_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(STRING_STOU32_TOK, &FOLLOW_STRING_STOU32_TOK_in_stringTerm7316);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_stringTerm7318);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_stringTerm7320);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_stringTerm7323);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::STRING_STOU32, f); 
        	        }


        	    }
        	    break;
        	case 15:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2011:5: str[s]
        	    {
        	        FOLLOWPUSH(FOLLOW_str_in_stringTerm7346);
        	        str(ctx, s);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_CONST(CVC4::String(s)); 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2014:5: setsTerm[f]
        	    {
        	        FOLLOWPUSH(FOLLOW_setsTerm_in_stringTerm7360);
        	        setsTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestringTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestringTermEx; /* Prevent compiler warnings */
    rulestringTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stringTerm */

/**
 * $ANTLR start setsTerm
 * ../../../../../../src/parser/cvc/Cvc.g:2017:1: setsTerm[CVC4::Expr& f] : ( SETS_CARD_TOK LPAREN formula[f] RPAREN | simpleTerm[f] );
 */
static void
setsTerm(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */



    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:2021:3: ( SETS_CARD_TOK LPAREN formula[f] RPAREN | simpleTerm[f] )

            ANTLR3_UINT32 alt100;

            alt100=2;

            switch ( LA(1) )
            {
            case SETS_CARD_TOK:
            	{
            		alt100=1;
            	}
                break;
            case ARRAY_TOK:
            case BAR:
            case BINARY_LITERAL:
            case DECIMAL_LITERAL:
            case FALSE_TOK:
            case HEX_LITERAL:
            case IDENTIFIER:
            case IF_TOK:
            case INTEGER_LITERAL:
            case LBRACE:
            case LPAREN:
            case PARENHASH:
            case TRUE_TOK:
            case UNIVSET_TOK:
            	{
            		alt100=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 100;
                EXCEPTION->state        = 0;


                goto rulesetsTermEx;

            }

            switch (alt100)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2021:5: SETS_CARD_TOK LPAREN formula[f] RPAREN
        	    {
        	         MATCHT(SETS_CARD_TOK, &FOLLOW_SETS_CARD_TOK_in_setsTerm7388);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesetsTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_setsTerm7390);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesetsTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_setsTerm7392);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesetsTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_setsTerm7395);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesetsTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::CARD, f); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2023:5: simpleTerm[f]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleTerm_in_setsTerm7407);
        	        simpleTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesetsTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesetsTermEx; /* Prevent compiler warnings */
    rulesetsTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end setsTerm */

/**
 * $ANTLR start simpleTerm
 * ../../../../../../src/parser/cvc/Cvc.g:2028:1: simpleTerm[CVC4::Expr& f] : ( iteTerm[f] | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | LPAREN RPAREN | PARENHASH HASHPAREN | LBRACE RBRACE | UNIVSET_TOK | LBRACE formula[f] ( COMMA formula[f] )* RBRACE | BAR BAR formula[f] BAR BAR | ARRAY_TOK LPAREN restrictedType[t, CHECK_DECLARED] OF_TOK restrictedType[t2, CHECK_DECLARED] RPAREN COLON simpleTerm[f] | TRUE_TOK | FALSE_TOK | DECIMAL_LITERAL | INTEGER_LITERAL | HEX_LITERAL | BINARY_LITERAL | PARENHASH recordEntry[name,e] ( COMMA recordEntry[name,e] )* HASHPAREN | identifier[name,CHECK_DECLARED,SYM_VARIABLE] );
 */
static void
simpleTerm(pCvcParser ctx, CVC4::Expr& f)
{
    pANTLR3_COMMON_TOKEN    DECIMAL_LITERAL17;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL18;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL19;
    pANTLR3_COMMON_TOKEN    BINARY_LITERAL20;

    /* Initialize rule variables
     */


      std::string name;
      std::vector<Expr> args;
      std::vector<std::string> names;
      Expr e;
      Debug("parser-extra") << "term: " << AntlrInput::tokenText(LT(1)) << std::endl;
      Type t, t2;

    DECIMAL_LITERAL17       = NULL;
    INTEGER_LITERAL18       = NULL;
    HEX_LITERAL19       = NULL;
    BINARY_LITERAL20       = NULL;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:2038:3: ( iteTerm[f] | LPAREN formula[f] ( COMMA formula[f] )* RPAREN | LPAREN RPAREN | PARENHASH HASHPAREN | LBRACE RBRACE | UNIVSET_TOK | LBRACE formula[f] ( COMMA formula[f] )* RBRACE | BAR BAR formula[f] BAR BAR | ARRAY_TOK LPAREN restrictedType[t, CHECK_DECLARED] OF_TOK restrictedType[t2, CHECK_DECLARED] RPAREN COLON simpleTerm[f] | TRUE_TOK | FALSE_TOK | DECIMAL_LITERAL | INTEGER_LITERAL | HEX_LITERAL | BINARY_LITERAL | PARENHASH recordEntry[name,e] ( COMMA recordEntry[name,e] )* HASHPAREN | identifier[name,CHECK_DECLARED,SYM_VARIABLE] )

            ANTLR3_UINT32 alt104;

            alt104=17;

            switch ( LA(1) )
            {
            case IF_TOK:
            	{
            		alt104=1;
            	}
                break;
            case LPAREN:
            	{
            		switch ( LA(2) )
            		{
            		case RPAREN:
            			{
            				alt104=3;
            			}
            		    break;
            		case ABS_TOK:
            		case ARRAY_TOK:
            		case BAR:
            		case BINARY_LITERAL:
            		case BVASHR_TOK:
            		case BVCOMP_TOK:
            		case BVGE_TOK:
            		case BVGT_TOK:
            		case BVLE_TOK:
            		case BVLSHR_TOK:
            		case BVLT_TOK:
            		case BVMULT_TOK:
            		case BVNAND_TOK:
            		case BVNEG_TOK:
            		case BVNOR_TOK:
            		case BVPLUS_TOK:
            		case BVREPEAT_TOK:
            		case BVROTL_TOK:
            		case BVROTR_TOK:
            		case BVSDIV_TOK:
            		case BVSGE_TOK:
            		case BVSGT_TOK:
            		case BVSHL_TOK:
            		case BVSLE_TOK:
            		case BVSLT_TOK:
            		case BVSMOD_TOK:
            		case BVSREM_TOK:
            		case BVSUB_TOK:
            		case BVUDIV_TOK:
            		case BVUMINUS_TOK:
            		case BVUREM_TOK:
            		case BVXNOR_TOK:
            		case BVXOR_TOK:
            		case BVZEROEXTEND_TOK:
            		case DECIMAL_LITERAL:
            		case DISTINCT_TOK:
            		case DIVISIBLE_TOK:
            		case EXISTS_TOK:
            		case FALSE_TOK:
            		case FLOOR_TOK:
            		case FORALL_TOK:
            		case HEX_LITERAL:
            		case IDENTIFIER:
            		case IF_TOK:
            		case INTEGER_LITERAL:
            		case IS_INTEGER_TOK:
            		case LAMBDA:
            		case LBRACE:
            		case LET_TOK:
            		case LPAREN:
            		case MINUS_TOK:
            		case NOT_TOK:
            		case PARENHASH:
            		case SETS_CARD_TOK:
            		case STRING_CONCAT_TOK:
            		case STRING_CONTAINS_TOK:
            		case STRING_INDEXOF_TOK:
            		case STRING_ITOS_TOK:
            		case STRING_LENGTH_TOK:
            		case STRING_LITERAL:
            		case STRING_PREFIXOF_TOK:
            		case STRING_REPLACE_TOK:
            		case STRING_STOI_TOK:
            		case STRING_STOU16_TOK:
            		case STRING_STOU32_TOK:
            		case STRING_SUBSTR_TOK:
            		case STRING_SUFFIXOF_TOK:
            		case STRING_U16TOS_TOK:
            		case STRING_U32TOS_TOK:
            		case SX_TOK:
            		case TRANSCLOSURE_TOK:
            		case TRANSPOSE_TOK:
            		case TRUE_TOK:
            		case TUPLE_TOK:
            		case UNIVSET_TOK:
            			{
            				alt104=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 104;
            		    EXCEPTION->state        = 2;


            		    goto rulesimpleTermEx;

            		}

            	}
                break;
            case PARENHASH:
            	{
            		switch ( LA(2) )
            		{
            		case HASHPAREN:
            			{
            				alt104=4;
            			}
            		    break;
            		case IDENTIFIER:
            			{
            				alt104=16;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 104;
            		    EXCEPTION->state        = 3;


            		    goto rulesimpleTermEx;

            		}

            	}
                break;
            case LBRACE:
            	{
            		switch ( LA(2) )
            		{
            		case RBRACE:
            			{
            				alt104=5;
            			}
            		    break;
            		case ABS_TOK:
            		case ARRAY_TOK:
            		case BAR:
            		case BINARY_LITERAL:
            		case BVASHR_TOK:
            		case BVCOMP_TOK:
            		case BVGE_TOK:
            		case BVGT_TOK:
            		case BVLE_TOK:
            		case BVLSHR_TOK:
            		case BVLT_TOK:
            		case BVMULT_TOK:
            		case BVNAND_TOK:
            		case BVNEG_TOK:
            		case BVNOR_TOK:
            		case BVPLUS_TOK:
            		case BVREPEAT_TOK:
            		case BVROTL_TOK:
            		case BVROTR_TOK:
            		case BVSDIV_TOK:
            		case BVSGE_TOK:
            		case BVSGT_TOK:
            		case BVSHL_TOK:
            		case BVSLE_TOK:
            		case BVSLT_TOK:
            		case BVSMOD_TOK:
            		case BVSREM_TOK:
            		case BVSUB_TOK:
            		case BVUDIV_TOK:
            		case BVUMINUS_TOK:
            		case BVUREM_TOK:
            		case BVXNOR_TOK:
            		case BVXOR_TOK:
            		case BVZEROEXTEND_TOK:
            		case DECIMAL_LITERAL:
            		case DISTINCT_TOK:
            		case DIVISIBLE_TOK:
            		case EXISTS_TOK:
            		case FALSE_TOK:
            		case FLOOR_TOK:
            		case FORALL_TOK:
            		case HEX_LITERAL:
            		case IDENTIFIER:
            		case IF_TOK:
            		case INTEGER_LITERAL:
            		case IS_INTEGER_TOK:
            		case LAMBDA:
            		case LBRACE:
            		case LET_TOK:
            		case LPAREN:
            		case MINUS_TOK:
            		case NOT_TOK:
            		case PARENHASH:
            		case SETS_CARD_TOK:
            		case STRING_CONCAT_TOK:
            		case STRING_CONTAINS_TOK:
            		case STRING_INDEXOF_TOK:
            		case STRING_ITOS_TOK:
            		case STRING_LENGTH_TOK:
            		case STRING_LITERAL:
            		case STRING_PREFIXOF_TOK:
            		case STRING_REPLACE_TOK:
            		case STRING_STOI_TOK:
            		case STRING_STOU16_TOK:
            		case STRING_STOU32_TOK:
            		case STRING_SUBSTR_TOK:
            		case STRING_SUFFIXOF_TOK:
            		case STRING_U16TOS_TOK:
            		case STRING_U32TOS_TOK:
            		case SX_TOK:
            		case TRANSCLOSURE_TOK:
            		case TRANSPOSE_TOK:
            		case TRUE_TOK:
            		case TUPLE_TOK:
            		case UNIVSET_TOK:
            			{
            				alt104=7;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 104;
            		    EXCEPTION->state        = 4;


            		    goto rulesimpleTermEx;

            		}

            	}
                break;
            case UNIVSET_TOK:
            	{
            		alt104=6;
            	}
                break;
            case BAR:
            	{
            		alt104=8;
            	}
                break;
            case ARRAY_TOK:
            	{
            		alt104=9;
            	}
                break;
            case TRUE_TOK:
            	{
            		alt104=10;
            	}
                break;
            case FALSE_TOK:
            	{
            		alt104=11;
            	}
                break;
            case DECIMAL_LITERAL:
            	{
            		alt104=12;
            	}
                break;
            case INTEGER_LITERAL:
            	{
            		alt104=13;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt104=14;
            	}
                break;
            case BINARY_LITERAL:
            	{
            		alt104=15;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt104=17;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 104;
                EXCEPTION->state        = 0;


                goto rulesimpleTermEx;

            }

            switch (alt104)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2038:5: iteTerm[f]
        	    {
        	        FOLLOWPUSH(FOLLOW_iteTerm_in_simpleTerm7438);
        	        iteTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2041:5: LPAREN formula[f] ( COMMA formula[f] )* RPAREN
        	    {
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_simpleTerm7461);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_simpleTerm7463);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:2042:5: ( COMMA formula[f] )*

        	        for (;;)
        	        {
        	            int alt101=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt101=1;
        	            	}
        	                break;

        	            }

        	            switch (alt101)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:2042:7: COMMA formula[f]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_simpleTerm7474);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimpleTermEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_formula_in_simpleTerm7476);
        	        	        formula(ctx, f);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimpleTermEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             args.push_back(f); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop101;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop101: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_simpleTerm7484);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             if(args.size() > 1) {
        	                    /* If args has elements, we must be a tuple literal.
        	                     * Otherwise, f is already the sub-formula, and
        	                     * there's nothing to do */
        	                    std::vector<Type> types;
        	                    for(std::vector<Expr>::const_iterator i = args.begin(); i != args.end(); ++i) {
        	                      types.push_back((*i).getType());
        	                    }
        	                    DatatypeType t = EXPR_MANAGER->mkTupleType(types);
        	                    const Datatype& dt = t.getDatatype();
        	                    args.insert( args.begin(), dt[0].getConstructor() );
        	                    f = MK_EXPR(kind::APPLY_CONSTRUCTOR, args);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2059:5: LPAREN RPAREN
        	    {
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_simpleTerm7507);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_simpleTerm7509);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             std::vector<Type> types;
        	                  DatatypeType t = EXPR_MANAGER->mkTupleType(types);
        	                  const Datatype& dt = t.getDatatype();
        	                  f = MK_EXPR(kind::APPLY_CONSTRUCTOR, dt[0].getConstructor()); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2066:5: PARENHASH HASHPAREN
        	    {
        	         MATCHT(PARENHASH, &FOLLOW_PARENHASH_in_simpleTerm7553);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(HASHPAREN, &FOLLOW_HASHPAREN_in_simpleTerm7555);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             DatatypeType t = EXPR_MANAGER->mkRecordType(std::vector< std::pair<std::string, Type> >());
        	                  const Datatype& dt = t.getDatatype();
        	                  f = MK_EXPR(kind::APPLY_CONSTRUCTOR, dt[0].getConstructor());
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2072:5: LBRACE RBRACE
        	    {
        	         MATCHT(LBRACE, &FOLLOW_LBRACE_in_simpleTerm7573);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RBRACE, &FOLLOW_RBRACE_in_simpleTerm7575);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_CONST(EmptySet(Type())); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2074:5: UNIVSET_TOK
        	    {
        	         MATCHT(UNIVSET_TOK, &FOLLOW_UNIVSET_TOK_in_simpleTerm7587);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             //booleanType is placeholder
        	                  f = EXPR_MANAGER->mkUniqueVar(EXPR_MANAGER->booleanType(), kind::UNIVERSE_SET);
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2080:5: LBRACE formula[f] ( COMMA formula[f] )* RBRACE
        	    {
        	         MATCHT(LBRACE, &FOLLOW_LBRACE_in_simpleTerm7606);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_simpleTerm7608);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:2081:5: ( COMMA formula[f] )*

        	        for (;;)
        	        {
        	            int alt102=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt102=1;
        	            	}
        	                break;

        	            }

        	            switch (alt102)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:2081:7: COMMA formula[f]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_simpleTerm7619);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimpleTermEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_formula_in_simpleTerm7621);
        	        	        formula(ctx, f);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimpleTermEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             args.push_back(f); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop102;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop102: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RBRACE, &FOLLOW_RBRACE_in_simpleTerm7629);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(kind::SINGLETON, args[0]);
        	                  for(size_t i = 1; i < args.size(); ++i) {
        	                    f = MK_EXPR(kind::UNION, f, MK_EXPR(kind::SINGLETON, args[i]));
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2089:5: BAR BAR formula[f] BAR BAR
        	    {
        	         MATCHT(BAR, &FOLLOW_BAR_in_simpleTerm7648);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(BAR, &FOLLOW_BAR_in_simpleTerm7650);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_simpleTerm7652);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	         MATCHT(BAR, &FOLLOW_BAR_in_simpleTerm7657);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(BAR, &FOLLOW_BAR_in_simpleTerm7659);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(kind::CARD, args[0]);
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2094:5: ARRAY_TOK LPAREN restrictedType[t, CHECK_DECLARED] OF_TOK restrictedType[t2, CHECK_DECLARED] RPAREN COLON simpleTerm[f]
        	    {
        	         MATCHT(ARRAY_TOK, &FOLLOW_ARRAY_TOK_in_simpleTerm7678);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_simpleTerm7682);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_restrictedType_in_simpleTerm7688);
        	        restrictedType(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(OF_TOK, &FOLLOW_OF_TOK_in_simpleTerm7691);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_restrictedType_in_simpleTerm7693);
        	        restrictedType(ctx, t2, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_simpleTerm7700);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COLON, &FOLLOW_COLON_in_simpleTerm7702);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_simpleTerm_in_simpleTerm7704);
        	        simpleTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             /* Eventually if we support a bound var (like a lambda) for array
        	                   * literals, we can use the push/pop scope. */
        	                  /* PARSER_STATE->popScope(); */
        	                  t = EXPR_MANAGER->mkArrayType(t, t2);
        	                  if(!f.isConst()) {
        	                    std::stringstream ss;
        	                    ss << "expected constant term inside array constant, but found "
        	                       << "nonconstant term" << std::endl
        	                       << "the term: " << f;
        	                    PARSER_STATE->parseError(ss.str());
        	                  }
        	                  if(!t2.isComparableTo(f.getType())) {
        	                    std::stringstream ss;
        	                    ss << "type mismatch inside array constant term:" << std::endl
        	                       << "array type:          " << t << std::endl
        	                       << "expected const type: " << t2 << std::endl
        	                       << "computed const type: " << f.getType();
        	                    PARSER_STATE->parseError(ss.str());
        	                  }
        	                  f = MK_CONST( ArrayStoreAll(t, f) );
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2120:5: TRUE_TOK
        	    {
        	         MATCHT(TRUE_TOK, &FOLLOW_TRUE_TOK_in_simpleTerm7724);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_CONST(bool(true)); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2121:5: FALSE_TOK
        	    {
        	         MATCHT(FALSE_TOK, &FOLLOW_FALSE_TOK_in_simpleTerm7733);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_CONST(bool(false)); 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2126:5: DECIMAL_LITERAL
        	    {
        	        DECIMAL_LITERAL17 = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_simpleTerm7753);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_CONST(AntlrInput::tokenToRational(DECIMAL_LITERAL17)); 
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2127:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL18 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_simpleTerm7761);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_CONST(AntlrInput::tokenToInteger(INTEGER_LITERAL18)); 
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2129:5: HEX_LITERAL
        	    {
        	        HEX_LITERAL19 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_simpleTerm7775);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             assert( AntlrInput::tokenText(HEX_LITERAL19).find("0hex") == 0 );
        	                  std::string hexString = AntlrInput::tokenTextSubstr(HEX_LITERAL19, 4);
        	                  f = MK_CONST( BitVector(hexString, 16) ); 
        	        }


        	    }
        	    break;
        	case 15:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2133:5: BINARY_LITERAL
        	    {
        	        BINARY_LITERAL20 = (pANTLR3_COMMON_TOKEN) MATCHT(BINARY_LITERAL, &FOLLOW_BINARY_LITERAL_in_simpleTerm7787);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             assert( AntlrInput::tokenText(BINARY_LITERAL20).find("0bin") == 0 );
        	                  std::string binString = AntlrInput::tokenTextSubstr(BINARY_LITERAL20, 4);
        	                  f = MK_CONST( BitVector(binString, 2) ); 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2138:5: PARENHASH recordEntry[name,e] ( COMMA recordEntry[name,e] )* HASHPAREN
        	    {
        	         MATCHT(PARENHASH, &FOLLOW_PARENHASH_in_simpleTerm7805);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_recordEntry_in_simpleTerm7807);
        	        recordEntry(ctx, name, e);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             names.push_back(name); args.push_back(e); 
        	        }


        	        // ../../../../../../src/parser/cvc/Cvc.g:2139:5: ( COMMA recordEntry[name,e] )*

        	        for (;;)
        	        {
        	            int alt103=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt103=1;
        	            	}
        	                break;

        	            }

        	            switch (alt103)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/cvc/Cvc.g:2139:7: COMMA recordEntry[name,e]
        	        	    {
        	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_simpleTerm7818);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimpleTermEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_recordEntry_in_simpleTerm7820);
        	        	        recordEntry(ctx, name, e);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesimpleTermEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	             names.push_back(name); args.push_back(e); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop103;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop103: ; /* Jump out to here if this rule does not match */


        	         MATCHT(HASHPAREN, &FOLLOW_HASHPAREN_in_simpleTerm7828);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             std::vector< std::pair<std::string, Type> > typeIds;
        	                  assert(names.size() == args.size());
        	                  for(unsigned i = 0; i < names.size(); ++i) {
        	                    typeIds.push_back(std::make_pair(names[i], args[i].getType()));
        	                  }
        	                  DatatypeType t = EXPR_MANAGER->mkRecordType(typeIds);
        	                  const Datatype& dt = t.getDatatype();
        	                  args.insert( args.begin(), dt[0].getConstructor() );
        	                  f = MK_EXPR(kind::APPLY_CONSTRUCTOR, args);
        	                
        	        }


        	    }
        	    break;
        	case 17:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2152:5: identifier[name,CHECK_DECLARED,SYM_VARIABLE]
        	    {
        	        FOLLOWPUSH(FOLLOW_identifier_in_simpleTerm7847);
        	        identifier(ctx, name, CHECK_DECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = PARSER_STATE->getVariable(name); 
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             // datatypes: zero-ary constructors
        	                  Type t2 = PARSER_STATE->getType(name);
        	                  if(t2.isConstructor() && ConstructorType(t2).getArity() == 0) {
        	                    // don't require parentheses, immediately turn it into an apply
        	                    f = MK_EXPR(CVC4::kind::APPLY_CONSTRUCTOR, f);
        	                  }
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleTermEx; /* Prevent compiler warnings */
    rulesimpleTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleTerm */

/**
 * $ANTLR start typeAscription
 * ../../../../../../src/parser/cvc/Cvc.g:2168:1: typeAscription[const CVC4::Expr& f, CVC4::Type& t] : COLON COLON type[t,CHECK_DECLARED] ;
 */
static void
typeAscription(pCvcParser ctx, const CVC4::Expr& f, CVC4::Type& t)
{
    /* Initialize rule variables
     */



    {
        // ../../../../../../src/parser/cvc/Cvc.g:2171:3: ( COLON COLON type[t,CHECK_DECLARED] )
        // ../../../../../../src/parser/cvc/Cvc.g:2171:5: COLON COLON type[t,CHECK_DECLARED]
        {
             MATCHT(COLON, &FOLLOW_COLON_in_typeAscription7887);
            if  (HASEXCEPTION())
            {
                goto ruletypeAscriptionEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COLON, &FOLLOW_COLON_in_typeAscription7889);
            if  (HASEXCEPTION())
            {
                goto ruletypeAscriptionEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_type_in_typeAscription7891);
            type(ctx, t, CHECK_DECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeAscriptionEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletypeAscriptionEx; /* Prevent compiler warnings */
    ruletypeAscriptionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end typeAscription */

/**
 * $ANTLR start recordEntry
 * ../../../../../../src/parser/cvc/Cvc.g:2177:1: recordEntry[std::string& name, CVC4::Expr& ex] : identifier[name,CHECK_NONE,SYM_VARIABLE] ASSIGN_TOK formula[ex] ;
 */
static void
recordEntry(pCvcParser ctx, std::string& name, CVC4::Expr& ex)
{
    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/cvc/Cvc.g:2178:3: ( identifier[name,CHECK_NONE,SYM_VARIABLE] ASSIGN_TOK formula[ex] )
        // ../../../../../../src/parser/cvc/Cvc.g:2178:5: identifier[name,CHECK_NONE,SYM_VARIABLE] ASSIGN_TOK formula[ex]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_recordEntry7908);
            identifier(ctx, name, CHECK_NONE, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerecordEntryEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(ASSIGN_TOK, &FOLLOW_ASSIGN_TOK_in_recordEntry7911);
            if  (HASEXCEPTION())
            {
                goto rulerecordEntryEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_formula_in_recordEntry7913);
            formula(ctx, ex);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerecordEntryEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulerecordEntryEx; /* Prevent compiler warnings */
    rulerecordEntryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end recordEntry */

/**
 * $ANTLR start iteTerm
 * ../../../../../../src/parser/cvc/Cvc.g:2184:1: iteTerm[CVC4::Expr& f] : IF_TOK formula[f] THEN_TOK formula[f] iteElseTerm[f] ENDIF_TOK ;
 */
static void
iteTerm(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      std::vector<Expr> args;
      Debug("parser-extra") << "ite: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:2189:3: ( IF_TOK formula[f] THEN_TOK formula[f] iteElseTerm[f] ENDIF_TOK )
        // ../../../../../../src/parser/cvc/Cvc.g:2189:5: IF_TOK formula[f] THEN_TOK formula[f] iteElseTerm[f] ENDIF_TOK
        {
             MATCHT(IF_TOK, &FOLLOW_IF_TOK_in_iteTerm7935);
            if  (HASEXCEPTION())
            {
                goto ruleiteTermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_formula_in_iteTerm7937);
            formula(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleiteTermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 args.push_back(f); 
            }


             MATCHT(THEN_TOK, &FOLLOW_THEN_TOK_in_iteTerm7946);
            if  (HASEXCEPTION())
            {
                goto ruleiteTermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_formula_in_iteTerm7948);
            formula(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleiteTermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 args.push_back(f); 
            }


            FOLLOWPUSH(FOLLOW_iteElseTerm_in_iteTerm7957);
            iteElseTerm(ctx, f);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleiteTermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 args.push_back(f); 
            }


             MATCHT(ENDIF_TOK, &FOLLOW_ENDIF_TOK_in_iteTerm7966);
            if  (HASEXCEPTION())
            {
                goto ruleiteTermEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 f = MK_EXPR(CVC4::kind::ITE, args); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleiteTermEx; /* Prevent compiler warnings */
    ruleiteTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end iteTerm */

/**
 * $ANTLR start iteElseTerm
 * ../../../../../../src/parser/cvc/Cvc.g:2199:1: iteElseTerm[CVC4::Expr& f] : ( ELSE_TOK formula[f] | ELSEIF_TOK iteCondition= formula[f] THEN_TOK iteThen= formula[f] iteElse= iteElseTerm[f] );
 */
static void
iteElseTerm(pCvcParser ctx, CVC4::Expr& f)
{
    /* Initialize rule variables
     */


      std::vector<Expr> args;
      Debug("parser-extra") << "else: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:2204:3: ( ELSE_TOK formula[f] | ELSEIF_TOK iteCondition= formula[f] THEN_TOK iteThen= formula[f] iteElse= iteElseTerm[f] )

            ANTLR3_UINT32 alt105;

            alt105=2;

            switch ( LA(1) )
            {
            case ELSE_TOK:
            	{
            		alt105=1;
            	}
                break;
            case ELSEIF_TOK:
            	{
            		alt105=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 105;
                EXCEPTION->state        = 0;


                goto ruleiteElseTermEx;

            }

            switch (alt105)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2204:5: ELSE_TOK formula[f]
        	    {
        	         MATCHT(ELSE_TOK, &FOLLOW_ELSE_TOK_in_iteElseTerm7993);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteElseTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_iteElseTerm7995);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteElseTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2205:5: ELSEIF_TOK iteCondition= formula[f] THEN_TOK iteThen= formula[f] iteElse= iteElseTerm[f]
        	    {
        	         MATCHT(ELSEIF_TOK, &FOLLOW_ELSEIF_TOK_in_iteElseTerm8002);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteElseTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_iteElseTerm8008);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteElseTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	         MATCHT(THEN_TOK, &FOLLOW_THEN_TOK_in_iteElseTerm8017);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteElseTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_formula_in_iteElseTerm8023);
        	        formula(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteElseTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	        FOLLOWPUSH(FOLLOW_iteElseTerm_in_iteElseTerm8036);
        	        iteElseTerm(ctx, f);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteElseTermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             args.push_back(f); 
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             f = MK_EXPR(CVC4::kind::ITE, args); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleiteElseTermEx; /* Prevent compiler warnings */
    ruleiteElseTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end iteElseTerm */

/**
 * $ANTLR start datatypeDef
 * ../../../../../../src/parser/cvc/Cvc.g:2214:1: datatypeDef[std::vector<CVC4::Datatype>& datatypes] : identifier[id,CHECK_NONE,SYM_SORT] ( LBRACKET identifier[id2,CHECK_UNDECLARED,SYM_SORT] ( COMMA identifier[id2,CHECK_UNDECLARED,SYM_SORT] )* RBRACKET )? EQUAL_TOK constructorDef[datatypes.back()] ( BAR constructorDef[datatypes.back()] )* ;
 */
static void
datatypeDef(pCvcParser ctx, std::vector<CVC4::Datatype>& datatypes)
{
    /* Initialize rule variables
     */


      std::string id, id2;
      Type t;
      std::vector< Type > params;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:2224:3: ( identifier[id,CHECK_NONE,SYM_SORT] ( LBRACKET identifier[id2,CHECK_UNDECLARED,SYM_SORT] ( COMMA identifier[id2,CHECK_UNDECLARED,SYM_SORT] )* RBRACKET )? EQUAL_TOK constructorDef[datatypes.back()] ( BAR constructorDef[datatypes.back()] )* )
        // ../../../../../../src/parser/cvc/Cvc.g:2224:5: identifier[id,CHECK_NONE,SYM_SORT] ( LBRACKET identifier[id2,CHECK_UNDECLARED,SYM_SORT] ( COMMA identifier[id2,CHECK_UNDECLARED,SYM_SORT] )* RBRACKET )? EQUAL_TOK constructorDef[datatypes.back()] ( BAR constructorDef[datatypes.back()] )*
        {
            FOLLOWPUSH(FOLLOW_identifier_in_datatypeDef8072);
            identifier(ctx, id, CHECK_NONE, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledatatypeDefEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 PARSER_STATE->pushScope(); 
            }


            // ../../../../../../src/parser/cvc/Cvc.g:2225:5: ( LBRACKET identifier[id2,CHECK_UNDECLARED,SYM_SORT] ( COMMA identifier[id2,CHECK_UNDECLARED,SYM_SORT] )* RBRACKET )?
            {
                int alt107=2;
                switch ( LA(1) )
                {
                    case LBRACKET:
                    	{
                    		alt107=1;
                    	}
                        break;
                }

                switch (alt107)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:2225:7: LBRACKET identifier[id2,CHECK_UNDECLARED,SYM_SORT] ( COMMA identifier[id2,CHECK_UNDECLARED,SYM_SORT] )* RBRACKET
            	    {
            	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_datatypeDef8083);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypeDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_identifier_in_datatypeDef8085);
            	        identifier(ctx, id2, CHECK_UNDECLARED, SYM_SORT);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypeDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                    t = PARSER_STATE->mkSort(id2, ExprManager::SORT_FLAG_PLACEHOLDER);
            	                    params.push_back( t );
            	                  
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:2229:7: ( COMMA identifier[id2,CHECK_UNDECLARED,SYM_SORT] )*

            	        for (;;)
            	        {
            	            int alt106=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt106=1;
            	            	}
            	                break;

            	            }

            	            switch (alt106)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:2229:9: COMMA identifier[id2,CHECK_UNDECLARED,SYM_SORT]
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_datatypeDef8098);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledatatypeDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_identifier_in_datatypeDef8100);
            	        	        identifier(ctx, id2, CHECK_UNDECLARED, SYM_SORT);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledatatypeDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {

            	        	                    t = PARSER_STATE->mkSort(id2, ExprManager::SORT_FLAG_PLACEHOLDER);
            	        	                    params.push_back( t ); 
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop106;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop106: ; /* Jump out to here if this rule does not match */


            	         MATCHT(RBRACKET, &FOLLOW_RBRACKET_in_datatypeDef8114);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypeDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                 datatypes.push_back(Datatype(id, params, false));
                      if(!PARSER_STATE->isUnresolvedType(id)) {
                        // if not unresolved, must be undeclared
                        PARSER_STATE->checkDeclaration(id, CHECK_UNDECLARED, SYM_SORT);
                      }
                    
            }


             MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_datatypeDef8133);
            if  (HASEXCEPTION())
            {
                goto ruledatatypeDefEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_constructorDef_in_datatypeDef8135);
            constructorDef(ctx, datatypes.back());

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledatatypeDefEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // ../../../../../../src/parser/cvc/Cvc.g:2241:5: ( BAR constructorDef[datatypes.back()] )*

            for (;;)
            {
                int alt108=2;
                switch ( LA(1) )
                {
                case BAR:
                	{
                		alt108=1;
                	}
                    break;

                }

                switch (alt108)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:2241:7: BAR constructorDef[datatypes.back()]
            	    {
            	         MATCHT(BAR, &FOLLOW_BAR_in_datatypeDef8144);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypeDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_constructorDef_in_datatypeDef8146);
            	        constructorDef(ctx, datatypes.back());

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypeDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop108;	/* break out of the loop */
            	    break;
                }
            }
            loop108: ; /* Jump out to here if this rule does not match */


            if ( BACKTRACKING==0 )
            {
                 PARSER_STATE->popScope(); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledatatypeDefEx; /* Prevent compiler warnings */
    ruledatatypeDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end datatypeDef */

/**
 * $ANTLR start constructorDef
 * ../../../../../../src/parser/cvc/Cvc.g:2248:1: constructorDef[CVC4::Datatype& type] : identifier[id,CHECK_UNDECLARED,SYM_SORT] ( LPAREN selector[&ctor] ( COMMA selector[&ctor] )* RPAREN )? ;
 */
static void
constructorDef(pCvcParser ctx, CVC4::Datatype& type)
{
    /* Initialize rule variables
     */


      std::string id;
      CVC4::PtrCloser<CVC4::DatatypeConstructor> ctor;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:2253:3: ( identifier[id,CHECK_UNDECLARED,SYM_SORT] ( LPAREN selector[&ctor] ( COMMA selector[&ctor] )* RPAREN )? )
        // ../../../../../../src/parser/cvc/Cvc.g:2253:5: identifier[id,CHECK_UNDECLARED,SYM_SORT] ( LPAREN selector[&ctor] ( COMMA selector[&ctor] )* RPAREN )?
        {
            FOLLOWPUSH(FOLLOW_identifier_in_constructorDef8177);
            identifier(ctx, id, CHECK_UNDECLARED, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstructorDefEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 // make the tester
                      std::string testerId("is_");
                      testerId.append(id);
                      PARSER_STATE->checkDeclaration(testerId, CHECK_UNDECLARED, SYM_SORT);
                      ctor.reset(new CVC4::DatatypeConstructor(id, testerId));
                    
            }


            // ../../../../../../src/parser/cvc/Cvc.g:2260:5: ( LPAREN selector[&ctor] ( COMMA selector[&ctor] )* RPAREN )?
            {
                int alt110=2;
                switch ( LA(1) )
                {
                    case LPAREN:
                    	{
                    		alt110=1;
                    	}
                        break;
                }

                switch (alt110)
                {
            	case 1:
            	    // ../../../../../../src/parser/cvc/Cvc.g:2260:7: LPAREN selector[&ctor] ( COMMA selector[&ctor] )* RPAREN
            	    {
            	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_constructorDef8192);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_selector_in_constructorDef8200);
            	        selector(ctx, &ctor);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        // ../../../../../../src/parser/cvc/Cvc.g:2262:7: ( COMMA selector[&ctor] )*

            	        for (;;)
            	        {
            	            int alt109=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt109=1;
            	            	}
            	                break;

            	            }

            	            switch (alt109)
            	            {
            	        	case 1:
            	        	    // ../../../../../../src/parser/cvc/Cvc.g:2262:9: COMMA selector[&ctor]
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_constructorDef8211);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconstructorDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_selector_in_constructorDef8213);
            	        	        selector(ctx, &ctor);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconstructorDefEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop109;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop109: ; /* Jump out to here if this rule does not match */


            	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_constructorDef8225);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                 // make the constructor
                      type.addConstructor(*ctor.get());
                      Debug("parser-idt") << "constructor: " << id.c_str() << std::endl;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructorDefEx; /* Prevent compiler warnings */
    ruleconstructorDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end constructorDef */

/**
 * $ANTLR start selector
 * ../../../../../../src/parser/cvc/Cvc.g:2271:1: selector[CVC4::PtrCloser<CVC4::DatatypeConstructor>* ctor] : identifier[id,CHECK_UNDECLARED,SYM_SORT] COLON type[t,CHECK_NONE] ;
 */
static void
selector(pCvcParser ctx, CVC4::PtrCloser<CVC4::DatatypeConstructor>* ctor)
{
    /* Initialize rule variables
     */


      std::string id;
      Type t, t2;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:2276:3: ( identifier[id,CHECK_UNDECLARED,SYM_SORT] COLON type[t,CHECK_NONE] )
        // ../../../../../../src/parser/cvc/Cvc.g:2276:5: identifier[id,CHECK_UNDECLARED,SYM_SORT] COLON type[t,CHECK_NONE]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_selector8257);
            identifier(ctx, id, CHECK_UNDECLARED, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COLON, &FOLLOW_COLON_in_selector8260);
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_type_in_selector8262);
            type(ctx, t, CHECK_NONE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 (*ctor)->addArg(id, t);
                      Debug("parser-idt") << "selector: " << id.c_str() << std::endl;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectorEx; /* Prevent compiler warnings */
    ruleselectorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end selector */

/**
 * $ANTLR start numeral
 * ../../../../../../src/parser/cvc/Cvc.g:2294:1: numeral returns [unsigned k = 0] : INTEGER_LITERAL ;
 */
static unsigned
numeral(pCvcParser ctx)
{
    unsigned k;


    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL21;

    /* Initialize rule variables
     */
    k =  0;


    INTEGER_LITERAL21       = NULL;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:2295:3: ( INTEGER_LITERAL )
        // ../../../../../../src/parser/cvc/Cvc.g:2295:5: INTEGER_LITERAL
        {
            INTEGER_LITERAL21 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_numeral8337);
            if  (HASEXCEPTION())
            {
                goto rulenumeralEx;
            }
            if (HASFAILED())
            {
                return k;
            }


            if ( BACKTRACKING==0 )
            {
                 k= AntlrInput::tokenToUnsigned(INTEGER_LITERAL21);
                 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenumeralEx; /* Prevent compiler warnings */
    rulenumeralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return k;
}
/* $ANTLR end numeral */

/**
 * $ANTLR start integer
 * ../../../../../../src/parser/cvc/Cvc.g:2302:1: integer returns [CVC4::Rational k = 0] : ( INTEGER_LITERAL | MINUS_TOK INTEGER_LITERAL );
 */
static CVC4::Rational
integer(pCvcParser ctx)
{
    CVC4::Rational k;


    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL22;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL23;

    /* Initialize rule variables
     */
    k =  0;


    INTEGER_LITERAL22       = NULL;
    INTEGER_LITERAL23       = NULL;

    {
        {
            //  ../../../../../../src/parser/cvc/Cvc.g:2303:3: ( INTEGER_LITERAL | MINUS_TOK INTEGER_LITERAL )

            ANTLR3_UINT32 alt111;

            alt111=2;

            switch ( LA(1) )
            {
            case INTEGER_LITERAL:
            	{
            		alt111=1;
            	}
                break;
            case MINUS_TOK:
            	{
            		alt111=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return k;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 111;
                EXCEPTION->state        = 0;


                goto ruleintegerEx;

            }

            switch (alt111)
            {
        	case 1:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2303:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL22 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_integer8362);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return k;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             k= AntlrInput::tokenToInteger(INTEGER_LITERAL22);
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/cvc/Cvc.g:2305:5: MINUS_TOK INTEGER_LITERAL
        	    {
        	         MATCHT(MINUS_TOK, &FOLLOW_MINUS_TOK_in_integer8374);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return k;
        	        }


        	        INTEGER_LITERAL23 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_integer8376);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return k;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             k= -AntlrInput::tokenToInteger(INTEGER_LITERAL23);
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleintegerEx; /* Prevent compiler warnings */
    ruleintegerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return k;
}
/* $ANTLR end integer */

/**
 * $ANTLR start str
 * ../../../../../../src/parser/cvc/Cvc.g:2312:1: str[std::string& s] : STRING_LITERAL ;
 */
static void
str(pCvcParser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    STRING_LITERAL24;

    /* Initialize rule variables
     */

    STRING_LITERAL24       = NULL;

    {
        // ../../../../../../src/parser/cvc/Cvc.g:2313:3: ( STRING_LITERAL )
        // ../../../../../../src/parser/cvc/Cvc.g:2313:5: STRING_LITERAL
        {
            STRING_LITERAL24 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_str8398);
            if  (HASEXCEPTION())
            {
                goto rulestrEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 s = AntlrInput::tokenText(STRING_LITERAL24);
                      /* strip off the quotes */
                      s = s.substr(1, s.size() - 2);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestrEx; /* Prevent compiler warnings */
    rulestrEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end str */

// $ANTLR start synpred1_Cvc
static void synpred1_Cvc_fragment(pCvcParser ctx )
{
    // ../../../../../../src/parser/cvc/Cvc.g:711:5: ( letDecl )
    // ../../../../../../src/parser/cvc/Cvc.g:711:5: letDecl
    {
        FOLLOWPUSH(FOLLOW_letDecl_in_synpred1_Cvc1998);
        letDecl(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_CvcEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_CvcEx; /* Prevent compiler warnings */
rulesynpred1_CvcEx: ;

}
// $ANTLR end synpred1_Cvc
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_Cvc(pCvcParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_Cvc_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
