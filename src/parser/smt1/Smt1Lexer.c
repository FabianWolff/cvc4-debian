/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ../../../../../../src/parser/smt1/Smt1.g
 *     -                            On : 2017-03-16 01:03:01
 *     -                 for the lexer : Smt1LexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "Smt1Lexer.h"
/* ----------------------------------------- */


/** String literals used by Smt1Lexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x3A, 0x70, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x41, 0x72, 0x72, 0x61, 0x79, 0x5B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x3A, 0x61, 0x73, 0x73, 0x75, 0x6D, 0x70, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x62, 0x65, 0x6E, 0x63, 0x68, 0x6D, 0x61, 0x72, 0x6B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x3A, 0x65, 0x78, 0x74, 0x72, 0x61, 0x66, 0x75, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x3A, 0x65, 0x78, 0x74, 0x72, 0x61, 0x70, 0x72, 0x65, 0x64, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x3A, 0x65, 0x78, 0x74, 0x72, 0x61, 0x73, 0x6F, 0x72, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x66, 0x61, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x66, 0x6C, 0x65, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x3A, 0x66, 0x6F, 0x72, 0x6D, 0x75, 0x6C, 0x61,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x69, 0x74, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x69, 0x66, 0x5F, 0x74, 0x68, 0x65, 0x6E, 0x5F, 0x65, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x6C, 0x65, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x3A, 0x6C, 0x6F, 0x67, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x3A, 0x6E, 0x6F, 0x74, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x73, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x3A, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x74, 0x68, 0x65, 0x6F, 0x72, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x74, 0x72, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x75, 0x6E, 0x73, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x61, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x64, 0x69, 0x73, 0x74, 0x69, 0x6E, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x65, 0x78, 0x69, 0x73, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x66, 0x6F, 0x72, 0x61, 0x6C, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x69, 0x66, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x69, 0x6D, 0x70, 0x6C, 0x69, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x6E, 0x6F, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x73, 0x74, 0x6F, 0x72, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x78, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x42, 0x69, 0x74, 0x56, 0x65, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x62, 0x76, 0x61, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x62, 0x76, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x62, 0x76, 0x78, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x62, 0x76, 0x6E, 0x6F, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x62, 0x76, 0x6E, 0x61, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x62, 0x76, 0x6E, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x62, 0x76, 0x78, 0x6E, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x62, 0x76, 0x63, 0x6F, 0x6D, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x62, 0x76, 0x6D, 0x75, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x62, 0x76, 0x61, 0x64, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x62, 0x76, 0x73, 0x75, 0x62,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x62, 0x76, 0x6E, 0x65, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x62, 0x76, 0x75, 0x64, 0x69, 0x76,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x62, 0x76, 0x75, 0x72, 0x65, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x62, 0x76, 0x73, 0x64, 0x69, 0x76,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x62, 0x76, 0x73, 0x72, 0x65, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x62, 0x76, 0x73, 0x6D, 0x6F, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x62, 0x76, 0x73, 0x68, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x62, 0x76, 0x6C, 0x73, 0x68, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x62, 0x76, 0x61, 0x73, 0x68, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x62, 0x76, 0x75, 0x6C, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x62, 0x76, 0x75, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x62, 0x76, 0x75, 0x67, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x62, 0x76, 0x75, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x62, 0x76, 0x73, 0x6C, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x62, 0x76, 0x73, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x62, 0x76, 0x73, 0x67, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x62, 0x76, 0x73, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x72, 0x65, 0x70, 0x65, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x7A, 0x65, 0x72, 0x6F, 0x5F, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x73, 0x69, 0x67, 0x6E, 0x5F, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x72, 0x6F, 0x74, 0x61, 0x74, 0x65, 0x5F, 0x6C, 0x65, 0x66, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_68[]  = { 0x72, 0x6F, 0x74, 0x61, 0x74, 0x65, 0x5F, 0x72, 0x69, 0x67, 0x68, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_69[]  = { 0x62, 0x76,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_70[]  = { 0x62, 0x69, 0x74, 0x30,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_71[]  = { 0x62, 0x69, 0x74, 0x31,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_72[]  = { 0x5C, 0x7B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_73[]  = { 0x5C, 0x7D,  ANTLR3_STRING_TERMINATOR};





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSmt1Lexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSmt1Lexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSmt1Lexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSmt1Lexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER
#undef	    RULEMEMO
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define	    NEXTCHAR	((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR	((pANTLR3_UINT16)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()   INPUT->istream->consume(INPUT->istream)
#define	    LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE 
 void
	mT__100    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mT__101    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mT__102    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mT__103    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mT__104    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mT__105    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mASSUMPTION_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBENCHMARK_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mEXTRAFUNS_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mEXTRAPREDS_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mEXTRASORTS_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mFALSE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mFLET_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mFORMULA_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mITE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mLET_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mLOGIC_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mLPAREN_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mNOTES_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mRPAREN_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mSAT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mSTATUS_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mTHEORY_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mTRUE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mUNKNOWN_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mUNSAT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mAMPERSAND_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mAND_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mAT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mDISTINCT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mDIV_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mEQUAL_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mEXISTS_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mFORALL_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mGREATER_THAN_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mIFF_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mIMPLIES_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mLESS_THAN_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mMINUS_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mNOT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mOR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mPERCENT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mPIPE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mPLUS_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mPOUND_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mSELECT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mSTAR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mSTORE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mTILDE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mXOR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBITVECTOR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mCONCAT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mEXTRACT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVAND_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVOR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVXOR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVNOT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVNAND_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVNOR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVXNOR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVCOMP_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVMUL_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVADD_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSUB_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVNEG_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVUDIV_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVUREM_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSDIV_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSREM_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSMOD_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSHL_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVLSHR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVASHR_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVULT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVULE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVUGT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVUGE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSLT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSLE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSGT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBVSGE_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mREPEAT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mZERO_EXTEND_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mSIGN_EXTEND_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mROTATE_LEFT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mROTATE_RIGHT_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBITVECTOR_BV_CONST    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mBITVECTOR1_BV_CONST    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mIDENTIFIER    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mATTR_IDENTIFIER    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mLET_IDENTIFIER    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mFLET_IDENTIFIER    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mPATTERN_ANNOTATION_BEGIN    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mUSER_VALUE    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mWHITESPACE    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mNUMERAL_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mRATIONAL_TOK    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mSTRING_LITERAL    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mCOMMENT    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mALPHA    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mDIGIT    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mESCAPE    (pSmt1Lexer ctx);
static ANTLR3_INLINE 
 void
	mTokens    (pSmt1Lexer ctx);
static void	Smt1LexerFree(pSmt1Lexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
Smt1LexerFree  (pSmt1Lexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

static void
Smt1LexerReset (pSmt1Lexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "../../../../../../src/parser/smt1/Smt1.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called Smt1Lexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSmt1Lexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSmt1Lexer Smt1LexerNew
(
pANTLR3_INPUT_STREAM
 instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return Smt1LexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called Smt1Lexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSmt1Lexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSmt1Lexer Smt1LexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSmt1Lexer ctx; // Context structure we will build and return

    ctx = (pSmt1Lexer) ANTLR3_CALLOC(1, sizeof(Smt1Lexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in Smt1Lexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our Smt1Lexer interface
     */
    ctx->mT__100	= mT__100;
    ctx->mT__101	= mT__101;
    ctx->mT__102	= mT__102;
    ctx->mT__103	= mT__103;
    ctx->mT__104	= mT__104;
    ctx->mT__105	= mT__105;
    ctx->mASSUMPTION_TOK	= mASSUMPTION_TOK;
    ctx->mBENCHMARK_TOK	= mBENCHMARK_TOK;
    ctx->mEXTRAFUNS_TOK	= mEXTRAFUNS_TOK;
    ctx->mEXTRAPREDS_TOK	= mEXTRAPREDS_TOK;
    ctx->mEXTRASORTS_TOK	= mEXTRASORTS_TOK;
    ctx->mFALSE_TOK	= mFALSE_TOK;
    ctx->mFLET_TOK	= mFLET_TOK;
    ctx->mFORMULA_TOK	= mFORMULA_TOK;
    ctx->mITE_TOK	= mITE_TOK;
    ctx->mLET_TOK	= mLET_TOK;
    ctx->mLOGIC_TOK	= mLOGIC_TOK;
    ctx->mLPAREN_TOK	= mLPAREN_TOK;
    ctx->mNOTES_TOK	= mNOTES_TOK;
    ctx->mRPAREN_TOK	= mRPAREN_TOK;
    ctx->mSAT_TOK	= mSAT_TOK;
    ctx->mSTATUS_TOK	= mSTATUS_TOK;
    ctx->mTHEORY_TOK	= mTHEORY_TOK;
    ctx->mTRUE_TOK	= mTRUE_TOK;
    ctx->mUNKNOWN_TOK	= mUNKNOWN_TOK;
    ctx->mUNSAT_TOK	= mUNSAT_TOK;
    ctx->mAMPERSAND_TOK	= mAMPERSAND_TOK;
    ctx->mAND_TOK	= mAND_TOK;
    ctx->mAT_TOK	= mAT_TOK;
    ctx->mDISTINCT_TOK	= mDISTINCT_TOK;
    ctx->mDIV_TOK	= mDIV_TOK;
    ctx->mEQUAL_TOK	= mEQUAL_TOK;
    ctx->mEXISTS_TOK	= mEXISTS_TOK;
    ctx->mFORALL_TOK	= mFORALL_TOK;
    ctx->mGREATER_THAN_TOK	= mGREATER_THAN_TOK;
    ctx->mIFF_TOK	= mIFF_TOK;
    ctx->mIMPLIES_TOK	= mIMPLIES_TOK;
    ctx->mLESS_THAN_TOK	= mLESS_THAN_TOK;
    ctx->mMINUS_TOK	= mMINUS_TOK;
    ctx->mNOT_TOK	= mNOT_TOK;
    ctx->mOR_TOK	= mOR_TOK;
    ctx->mPERCENT_TOK	= mPERCENT_TOK;
    ctx->mPIPE_TOK	= mPIPE_TOK;
    ctx->mPLUS_TOK	= mPLUS_TOK;
    ctx->mPOUND_TOK	= mPOUND_TOK;
    ctx->mSELECT_TOK	= mSELECT_TOK;
    ctx->mSTAR_TOK	= mSTAR_TOK;
    ctx->mSTORE_TOK	= mSTORE_TOK;
    ctx->mTILDE_TOK	= mTILDE_TOK;
    ctx->mXOR_TOK	= mXOR_TOK;
    ctx->mBITVECTOR_TOK	= mBITVECTOR_TOK;
    ctx->mCONCAT_TOK	= mCONCAT_TOK;
    ctx->mEXTRACT_TOK	= mEXTRACT_TOK;
    ctx->mBVAND_TOK	= mBVAND_TOK;
    ctx->mBVOR_TOK	= mBVOR_TOK;
    ctx->mBVXOR_TOK	= mBVXOR_TOK;
    ctx->mBVNOT_TOK	= mBVNOT_TOK;
    ctx->mBVNAND_TOK	= mBVNAND_TOK;
    ctx->mBVNOR_TOK	= mBVNOR_TOK;
    ctx->mBVXNOR_TOK	= mBVXNOR_TOK;
    ctx->mBVCOMP_TOK	= mBVCOMP_TOK;
    ctx->mBVMUL_TOK	= mBVMUL_TOK;
    ctx->mBVADD_TOK	= mBVADD_TOK;
    ctx->mBVSUB_TOK	= mBVSUB_TOK;
    ctx->mBVNEG_TOK	= mBVNEG_TOK;
    ctx->mBVUDIV_TOK	= mBVUDIV_TOK;
    ctx->mBVUREM_TOK	= mBVUREM_TOK;
    ctx->mBVSDIV_TOK	= mBVSDIV_TOK;
    ctx->mBVSREM_TOK	= mBVSREM_TOK;
    ctx->mBVSMOD_TOK	= mBVSMOD_TOK;
    ctx->mBVSHL_TOK	= mBVSHL_TOK;
    ctx->mBVLSHR_TOK	= mBVLSHR_TOK;
    ctx->mBVASHR_TOK	= mBVASHR_TOK;
    ctx->mBVULT_TOK	= mBVULT_TOK;
    ctx->mBVULE_TOK	= mBVULE_TOK;
    ctx->mBVUGT_TOK	= mBVUGT_TOK;
    ctx->mBVUGE_TOK	= mBVUGE_TOK;
    ctx->mBVSLT_TOK	= mBVSLT_TOK;
    ctx->mBVSLE_TOK	= mBVSLE_TOK;
    ctx->mBVSGT_TOK	= mBVSGT_TOK;
    ctx->mBVSGE_TOK	= mBVSGE_TOK;
    ctx->mREPEAT_TOK	= mREPEAT_TOK;
    ctx->mZERO_EXTEND_TOK	= mZERO_EXTEND_TOK;
    ctx->mSIGN_EXTEND_TOK	= mSIGN_EXTEND_TOK;
    ctx->mROTATE_LEFT_TOK	= mROTATE_LEFT_TOK;
    ctx->mROTATE_RIGHT_TOK	= mROTATE_RIGHT_TOK;
    ctx->mBITVECTOR_BV_CONST	= mBITVECTOR_BV_CONST;
    ctx->mBITVECTOR1_BV_CONST	= mBITVECTOR1_BV_CONST;
    ctx->mIDENTIFIER	= mIDENTIFIER;
    ctx->mATTR_IDENTIFIER	= mATTR_IDENTIFIER;
    ctx->mLET_IDENTIFIER	= mLET_IDENTIFIER;
    ctx->mFLET_IDENTIFIER	= mFLET_IDENTIFIER;
    ctx->mPATTERN_ANNOTATION_BEGIN	= mPATTERN_ANNOTATION_BEGIN;
    ctx->mUSER_VALUE	= mUSER_VALUE;
    ctx->mWHITESPACE	= mWHITESPACE;
    ctx->mNUMERAL_TOK	= mNUMERAL_TOK;
    ctx->mRATIONAL_TOK	= mRATIONAL_TOK;
    ctx->mSTRING_LITERAL	= mSTRING_LITERAL;
    ctx->mCOMMENT	= mCOMMENT;
    ctx->mALPHA	= mALPHA;
    ctx->mDIGIT	= mDIGIT;
    ctx->mESCAPE	= mESCAPE;
    ctx->mTokens	= mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= Smt1LexerFree;
    ctx->reset          = Smt1LexerReset;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | ASSUMPTION_TOK | BENCHMARK_TOK | EXTRAFUNS_TOK | EXTRAPREDS_TOK | EXTRASORTS_TOK | FALSE_TOK | FLET_TOK | FORMULA_TOK | ITE_TOK | LET_TOK | LOGIC_TOK | LPAREN_TOK | NOTES_TOK | RPAREN_TOK | SAT_TOK | STATUS_TOK | THEORY_TOK | TRUE_TOK | UNKNOWN_TOK | UNSAT_TOK | AMPERSAND_TOK | AND_TOK | AT_TOK | DISTINCT_TOK | DIV_TOK | EQUAL_TOK | EXISTS_TOK | FORALL_TOK | GREATER_THAN_TOK | IFF_TOK | IMPLIES_TOK | LESS_THAN_TOK | MINUS_TOK | NOT_TOK | OR_TOK | PERCENT_TOK | PIPE_TOK | PLUS_TOK | POUND_TOK | SELECT_TOK | STAR_TOK | STORE_TOK | TILDE_TOK | XOR_TOK | BITVECTOR_TOK | CONCAT_TOK | EXTRACT_TOK | BVAND_TOK | BVOR_TOK | BVXOR_TOK | BVNOT_TOK | BVNAND_TOK | BVNOR_TOK | BVXNOR_TOK | BVCOMP_TOK | BVMUL_TOK | BVADD_TOK | BVSUB_TOK | BVNEG_TOK | BVUDIV_TOK | BVUREM_TOK | BVSDIV_TOK | BVSREM_TOK | BVSMOD_TOK | BVSHL_TOK | BVLSHR_TOK | BVASHR_TOK | BVULT_TOK | BVULE_TOK | BVUGT_TOK | BVUGE_TOK | BVSLT_TOK | BVSLE_TOK | BVSGT_TOK | BVSGE_TOK | REPEAT_TOK | ZERO_EXTEND_TOK | SIGN_EXTEND_TOK | ROTATE_LEFT_TOK | ROTATE_RIGHT_TOK | BITVECTOR_BV_CONST | BITVECTOR1_BV_CONST | IDENTIFIER | ATTR_IDENTIFIER | LET_IDENTIFIER | FLET_IDENTIFIER | PATTERN_ANNOTATION_BEGIN | USER_VALUE | WHITESPACE | NUMERAL_TOK | RATIONAL_TOK | STRING_LITERAL | COMMENT );
 */
static const ANTLR3_INT32 dfa13_eot[398] =
    {
	-1, 53, 38, -1, -1, -1, 38, 38, 38, 38, -1, -1, 38, 38, 38, -1, 38, -1, 
	38, -1, -1, 38, -1, -1, -1, 38, 38, -1, -1, -1, -1, -1, -1, 38, 38, 38, 
	38, 38, -1, -1, -1, -1, -1, 84, -1, -1, 54, 54, 54, 54, 54, 54, 54, -1, 
	-1, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 127, 38, 38, 38, 38, 38, 38, -1, -1, 54, 54, 54, 54, 
	54, 54, 54, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 166, 38, 38, 38, 
	38, 172, 38, 174, 38, 176, 177, 38, 38, 38, 38, 38, 38, 38, 185, 38, 38, 
	38, 189, -1, 190, 38, 38, 38, 38, 38, 196, 54, 54, 54, 54, 54, 54, 38, 
	38, 38, 38, 38, 209, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, -1, 234, 234, 38, 236, 38, -1, 38, -1, 38, -1, 
	-1, 38, 38, 38, 38, 244, 38, 38, -1, 38, 38, 38, -1, -1, 38, 38, 38, 38, 
	38, -1, -1, 54, 54, 54, 54, 54, 54, 38, 38, 263, 264, 38, -1, 266, 38, 
	268, 269, 38, 271, 38, 273, 274, 38, 38, 38, 278, 279, 280, 281, 282, 38, 
	38, 285, 286, 287, 288, 38, -1, 290, -1, 38, 38, 38, 38, 295, 38, 38, -1, 
	38, 299, 38, 38, 38, 38, 38, 38, 38, 38, 54, 54, 54, 313, 314, 54, -1, 
	38, -1, -1, 317, -1, 318, -1, -1, 319, -1, 320, -1, -1, 321, 322, 323, 
	-1, -1, -1, -1, -1, 324, 325, -1, -1, -1, -1, 326, -1, 327, 38, 38, 330, 
	-1, 38, 332, 38, -1, 38, 335, 38, 337, 338, 339, 38, 38, 54, 54, 54, 54, 
	54, -1, -1, 347, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, 350, 
	-1, 38, -1, 352, 38, -1, 354, -1, -1, -1, 38, 38, 54, 54, 54, 54, 362, 
	-1, 38, 38, -1, 38, -1, 366, -1, 38, 38, 38, 54, 54, 54, 54, -1, 374, 38, 
	38, -1, 38, 38, 38, 54, 381, 54, 54, -1, 38, 38, 38, 38, 38, 389, -1, 390, 
	391, 38, 393, 394, 38, 396, -1, -1, -1, 172, -1, -1, 397, -1, -1
    };
static const ANTLR3_INT32 dfa13_eof[398] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR3_INT32 dfa13_min[398] =
    {
	9, 65, 114, -1, -1, -1, 101, 97, 102, 101, -1, -1, 97, 104, 110, -1, 110, 
	-1, 105, -1, -1, 120, -1, -1, -1, 111, 114, -1, -1, -1, -1, -1, -1, 111, 
	105, 111, 101, 101, -1, -1, -1, -1, -1, 46, -1, -1, 97, 115, 120, 111, 
	111, 111, 116, -1, -1, 114, 110, 48, 116, 108, 101, 114, 101, 95, 112, 
	116, 116, 108, 111, 103, 101, 117, 107, 100, 115, 105, 116, 39, 114, 116, 
	110, 112, 116, 114, -1, -1, 116, 115, 116, 114, 103, 116, 97, 97, 99, 100, 
	114, 110, 97, 111, 117, 100, 100, 115, 39, 48, 115, 116, 97, 39, 116, 39, 
	108, 39, 39, 101, 114, 110, 111, 101, 110, 97, 39, 116, 115, 114, 39, -1, 
	39, 86, 99, 101, 97, 111, 9, 117, 114, 109, 105, 101, 116, 121, 104, 100, 
	100, 104, 39, 114, 111, 114, 110, 103, 109, 108, 98, 105, 101, 111, 108, 
	101, 101, 105, 101, 101, 101, 104, -1, 39, 39, 101, 39, 108, -1, 104, -1, 
	105, -1, -1, 99, 101, 95, 114, 39, 111, 116, -1, 105, 116, 97, -1, -1, 
	101, 97, 97, 116, 95, -1, -1, 109, 97, 117, 99, 115, 117, 91, 109, 39, 
	39, 114, -1, 39, 114, 39, 39, 100, 39, 112, 39, 39, 118, 109, 100, 39, 
	39, 39, 39, 39, 118, 109, 39, 39, 39, 39, 114, -1, 39, -1, 108, 101, 101, 
	116, 39, 101, 121, -1, 119, 39, 110, 115, 99, 99, 116, 116, 101, 101, 112, 
	102, 108, 39, 39, 115, -1, 97, -1, -1, 39, -1, 39, -1, -1, 39, -1, 39, 
	-1, -1, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, -1, -1, -1, -1, 39, -1, 
	39, 110, 115, 39, -1, 120, 39, 110, -1, 99, 39, 116, 39, 39, 39, 95, 120, 
	116, 117, 114, 111, 97, -1, -1, 39, 114, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 95, 39, -1, 116, -1, 39, 116, -1, 39, -1, -1, -1, 108, 116, 
	105, 110, 101, 114, 39, -1, 107, 101, -1, 101, -1, 39, -1, 101, 105, 101, 
	111, 115, 100, 116, -1, 39, 108, 110, -1, 102, 103, 110, 110, 39, 115, 
	115, -1, 115, 100, 116, 104, 100, 39, -1, 39, 39, 101, 39, 39, 116, 39, 
	-1, -1, -1, 39, -1, -1, 39, -1, -1
    };
static const ANTLR3_INT32 dfa13_max[398] =
    {
	126, 122, 114, -1, -1, -1, 118, 111, 116, 101, -1, -1, 116, 114, 110, -1, 
	110, -1, 105, -1, -1, 120, -1, -1, -1, 111, 114, -1, -1, -1, -1, -1, -1, 
	111, 105, 111, 111, 101, -1, -1, -1, -1, -1, 57, -1, -1, 97, 115, 120, 
	111, 111, 111, 116, -1, -1, 114, 110, 120, 116, 108, 101, 114, 101, 102, 
	112, 116, 116, 108, 111, 103, 101, 117, 115, 100, 115, 116, 116, 122, 114, 
	116, 110, 112, 116, 114, -1, -1, 116, 115, 116, 114, 103, 116, 97, 97, 
	99, 115, 114, 111, 111, 111, 117, 117, 114, 115, 122, 49, 115, 116, 97, 
	122, 116, 122, 108, 122, 122, 101, 114, 110, 111, 101, 110, 97, 122, 116, 
	115, 114, 122, -1, 122, 86, 99, 101, 97, 111, 123, 117, 114, 109, 105, 
	101, 116, 121, 104, 100, 100, 104, 122, 114, 111, 116, 110, 103, 109, 108, 
	98, 105, 101, 111, 108, 116, 116, 105, 101, 116, 116, 104, -1, 122, 122, 
	101, 122, 108, -1, 104, -1, 105, -1, -1, 99, 101, 95, 114, 122, 111, 116, 
	-1, 105, 116, 97, -1, -1, 101, 97, 97, 116, 95, -1, -1, 109, 97, 117, 99, 
	115, 117, 91, 109, 122, 122, 114, -1, 122, 114, 122, 122, 100, 122, 112, 
	122, 122, 118, 109, 100, 122, 122, 122, 122, 122, 118, 109, 122, 122, 122, 
	122, 114, -1, 122, -1, 108, 101, 101, 116, 122, 101, 121, -1, 119, 122, 
	110, 115, 99, 99, 116, 116, 101, 101, 112, 115, 108, 122, 122, 115, -1, 
	97, -1, -1, 122, -1, 122, -1, -1, 122, -1, 122, -1, -1, 122, 122, 122, 
	-1, -1, -1, -1, -1, 122, 122, -1, -1, -1, -1, 122, -1, 122, 110, 115, 122, 
	-1, 120, 122, 110, -1, 99, 122, 116, 122, 122, 122, 95, 120, 116, 117, 
	114, 111, 97, -1, -1, 122, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 95, 122, -1, 116, -1, 122, 116, -1, 122, -1, -1, -1, 114, 116, 105, 
	110, 101, 114, 122, -1, 107, 101, -1, 101, -1, 122, -1, 101, 105, 101, 
	111, 115, 100, 116, -1, 122, 108, 110, -1, 102, 103, 110, 110, 122, 115, 
	115, -1, 115, 100, 116, 104, 100, 122, -1, 122, 122, 101, 122, 122, 116, 
	122, -1, -1, -1, 122, -1, -1, 122, -1, -1
    };
static const ANTLR3_INT32 dfa13_accept[398] =
    {
	-1, -1, -1, 4, 5, 6, -1, -1, -1, -1, 18, 20, -1, -1, -1, 27, -1, 29, -1, 
	31, 32, -1, 35, 38, 39, -1, -1, 42, 43, 44, 45, 47, 49, -1, -1, -1, -1, 
	-1, 89, 91, 92, 94, 95, -1, 98, 99, -1, -1, -1, -1, -1, -1, -1, 1, 90, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 96, 97, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 87, -1, -1, -1, -1, -1, 15, -1, 36, -1, 16, 21, -1, -1, -1, 
	-1, -1, -1, -1, 28, -1, -1, -1, 40, 50, -1, -1, -1, -1, -1, 2, 93, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, 
	-1, 13, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 3, -1, 54, 63, -1, 56, -1, 57, 59, -1, 
	65, -1, 62, 64, -1, -1, -1, 71, 78, 79, 80, 81, -1, -1, 74, 75, 76, 77, 
	-1, 12, -1, -1, -1, -1, 48, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 17, 19, -1, -1, 73, 60, 58, 61, 68, 69, 70, 66, 
	67, 72, 34, -1, -1, 46, -1, 23, -1, -1, 33, -1, 51, 52, 82, -1, -1, -1, 
	-1, -1, -1, -1, 22, -1, -1, 37, -1, 25, -1, 53, -1, -1, -1, -1, -1, -1, 
	-1, 14, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, 
	-1, -1, 9, -1, -1, -1, -1, -1, -1, -1, 7, 10, 11, -1, 84, 85, -1, 83, 86
    };
static const ANTLR3_INT32 dfa13_special[398] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa13_T_empty	    NULL

static const ANTLR3_INT32 dfa13_T0[] =
    {
	333
    };

static const ANTLR3_INT32 dfa13_T1[] =
    {
	184
    };

static const ANTLR3_INT32 dfa13_T2[] =
    {
	246
    };

static const ANTLR3_INT32 dfa13_T3[] =
    {
	135
    };

static const ANTLR3_INT32 dfa13_T4[] =
    {
	198
    };

static const ANTLR3_INT32 dfa13_T5[] =
    {
	255
    };

static const ANTLR3_INT32 dfa13_T6[] =
    {
	38, -1, -1, -1, -1, -1, -1, 38, -1, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, -1, -1, -1, -1, -1, -1, -1, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, -1, -1, 
	-1, -1, 38, -1, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
    };

static const ANTLR3_INT32 dfa13_T7[] =
    {
	308
    };

static const ANTLR3_INT32 dfa13_T8[] =
    {
	342
    };

static const ANTLR3_INT32 dfa13_T9[] =
    {
	358
    };

static const ANTLR3_INT32 dfa13_T10[] =
    {
	370
    };

static const ANTLR3_INT32 dfa13_T11[] =
    {
	380
    };

static const ANTLR3_INT32 dfa13_T12[] =
    {
	122
    };

static const ANTLR3_INT32 dfa13_T13[] =
    {
	86
    };

static const ANTLR3_INT32 dfa13_T14[] =
    {
	123
    };

static const ANTLR3_INT32 dfa13_T15[] =
    {
	161, -1, -1, 164, -1, -1, -1, -1, 163, -1, -1, -1, -1, -1, 162
    };

static const ANTLR3_INT32 dfa13_T16[] =
    {
	186
    };

static const ANTLR3_INT32 dfa13_T17[] =
    {
	247
    };

static const ANTLR3_INT32 dfa13_T18[] =
    {
	300
    };

static const ANTLR3_INT32 dfa13_T19[] =
    {
	334
    };

static const ANTLR3_INT32 dfa13_T20[] =
    {
	353
    };

static const ANTLR3_INT32 dfa13_T21[] =
    {
	343
    };

static const ANTLR3_INT32 dfa13_T22[] =
    {
	359
    };

static const ANTLR3_INT32 dfa13_T23[] =
    {
	371
    };

static const ANTLR3_INT32 dfa13_T24[] =
    {
	65
    };

static const ANTLR3_INT32 dfa13_T25[] =
    {
	187
    };

static const ANTLR3_INT32 dfa13_T26[] =
    {
	248
    };

static const ANTLR3_INT32 dfa13_T27[] =
    {
	301
    };

static const ANTLR3_INT32 dfa13_T28[] =
    {
	344
    };

static const ANTLR3_INT32 dfa13_T29[] =
    {
	360
    };

static const ANTLR3_INT32 dfa13_T30[] =
    {
	372
    };

static const ANTLR3_INT32 dfa13_T31[] =
    {
	108
    };

static const ANTLR3_INT32 dfa13_T32[] =
    {
	382
    };

static const ANTLR3_INT32 dfa13_T33[] =
    {
	171
    };

static const ANTLR3_INT32 dfa13_T34[] =
    {
	237
    };

static const ANTLR3_INT32 dfa13_T35[] =
    {
	291
    };

static const ANTLR3_INT32 dfa13_T36[] =
    {
	345
    };

static const ANTLR3_INT32 dfa13_T37[] =
    {
	361
    };

static const ANTLR3_INT32 dfa13_T38[] =
    {
	38, -1, -1, -1, -1, -1, -1, 38, -1, 104, 104, 104, 104, 104, 104, 104, 
	104, 104, 104, -1, -1, -1, -1, -1, -1, -1, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, -1, -1, -1, -1, 38, -1, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
    };

static const ANTLR3_INT32 dfa13_T39[] =
    {
	373
    };

static const ANTLR3_INT32 dfa13_T40[] =
    {
	383
    };

static const ANTLR3_INT32 dfa13_T41[] =
    {
	112
    };

static const ANTLR3_INT32 dfa13_T42[] =
    {
	175
    };

static const ANTLR3_INT32 dfa13_T43[] =
    {
	239
    };

static const ANTLR3_INT32 dfa13_T44[] =
    {
	293
    };

static const ANTLR3_INT32 dfa13_T45[] =
    {
	329
    };

static const ANTLR3_INT32 dfa13_T46[] =
    {
	137
    };

static const ANTLR3_INT32 dfa13_T47[] =
    {
	126
    };

static const ANTLR3_INT32 dfa13_T48[] =
    {
	200
    };

static const ANTLR3_INT32 dfa13_T49[] =
    {
	257
    };

static const ANTLR3_INT32 dfa13_T50[] =
    {
	312
    };

static const ANTLR3_INT32 dfa13_T51[] =
    {
	346
    };

static const ANTLR3_INT32 dfa13_T52[] =
    {
	230, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 229
    };

static const ANTLR3_INT32 dfa13_T53[] =
    {
	56, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57
    };

static const ANTLR3_INT32 dfa13_T54[] =
    {
	115
    };

static const ANTLR3_INT32 dfa13_T55[] =
    {
	178
    };

static const ANTLR3_INT32 dfa13_T56[] =
    {
	240
    };

static const ANTLR3_INT32 dfa13_T57[] =
    {
	294
    };

static const ANTLR3_INT32 dfa13_T58[] =
    {
	87
    };

static const ANTLR3_INT32 dfa13_T59[] =
    {
	150, -1, -1, -1, 151, -1, -1, -1, -1, -1, -1, -1, -1, -1, 149
    };

static const ANTLR3_INT32 dfa13_T60[] =
    {
	73
    };

static const ANTLR3_INT32 dfa13_T61[] =
    {
	138
    };

static const ANTLR3_INT32 dfa13_T62[] =
    {
	201
    };

static const ANTLR3_INT32 dfa13_T63[] =
    {
	258
    };

static const ANTLR3_INT32 dfa13_T64[] =
    {
	116
    };

static const ANTLR3_INT32 dfa13_T65[] =
    {
	179
    };

static const ANTLR3_INT32 dfa13_T66[] =
    {
	241
    };

static const ANTLR3_INT32 dfa13_T67[] =
    {
	74
    };

static const ANTLR3_INT32 dfa13_T68[] =
    {
	232, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 231
    };

static const ANTLR3_INT32 dfa13_T69[] =
    {
	139
    };

static const ANTLR3_INT32 dfa13_T70[] =
    {
	202
    };

static const ANTLR3_INT32 dfa13_T71[] =
    {
	128
    };

static const ANTLR3_INT32 dfa13_T72[] =
    {
	259
    };

static const ANTLR3_INT32 dfa13_T73[] =
    {
	129
    };

static const ANTLR3_INT32 dfa13_T74[] =
    {
	191
    };

static const ANTLR3_INT32 dfa13_T75[] =
    {
	250
    };

static const ANTLR3_INT32 dfa13_T76[] =
    {
	303
    };

static const ANTLR3_INT32 dfa13_T77[] =
    {
	130
    };

static const ANTLR3_INT32 dfa13_T78[] =
    {
	192
    };

static const ANTLR3_INT32 dfa13_T79[] =
    {
	140
    };

static const ANTLR3_INT32 dfa13_T80[] =
    {
	251
    };

static const ANTLR3_INT32 dfa13_T81[] =
    {
	203
    };

static const ANTLR3_INT32 dfa13_T82[] =
    {
	304
    };

static const ANTLR3_INT32 dfa13_T83[] =
    {
	260
    };

static const ANTLR3_INT32 dfa13_T84[] =
    {
	315
    };

static const ANTLR3_INT32 dfa13_T85[] =
    {
	188
    };

static const ANTLR3_INT32 dfa13_T86[] =
    {
	224, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 223
    };

static const ANTLR3_INT32 dfa13_T87[] =
    {
	249
    };

static const ANTLR3_INT32 dfa13_T88[] =
    {
	302
    };

static const ANTLR3_INT32 dfa13_T89[] =
    {
	336
    };

static const ANTLR3_INT32 dfa13_T90[] =
    {
	206
    };

static const ANTLR3_INT32 dfa13_T91[] =
    {
	146
    };

static const ANTLR3_INT32 dfa13_T92[] =
    {
	210
    };

static const ANTLR3_INT32 dfa13_T93[] =
    {
	226, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 225
    };

static const ANTLR3_INT32 dfa13_T94[] =
    {
	76
    };

static const ANTLR3_INT32 dfa13_T95[] =
    {
	89
    };

static const ANTLR3_INT32 dfa13_T96[] =
    {
	77
    };

static const ANTLR3_INT32 dfa13_T97[] =
    {
	214
    };

static const ANTLR3_INT32 dfa13_T98[] =
    {
	270
    };

static const ANTLR3_INT32 dfa13_T99[] =
    {
	211
    };

static const ANTLR3_INT32 dfa13_T100[] =
    {
	267
    };

static const ANTLR3_INT32 dfa13_T101[] =
    {
	81, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82
    };

static const ANTLR3_INT32 dfa13_T102[] =
    {
	152
    };

static const ANTLR3_INT32 dfa13_T103[] =
    {
	216
    };

static const ANTLR3_INT32 dfa13_T104[] =
    {
	272
    };

static const ANTLR3_INT32 dfa13_T105[] =
    {
	90
    };

static const ANTLR3_INT32 dfa13_T106[] =
    {
	153
    };

static const ANTLR3_INT32 dfa13_T107[] =
    {
	217
    };

static const ANTLR3_INT32 dfa13_T108[] =
    {
	207
    };

static const ANTLR3_INT32 dfa13_T109[] =
    {
	78
    };

static const ANTLR3_INT32 dfa13_T110[] =
    {
	91
    };

static const ANTLR3_INT32 dfa13_T111[] =
    {
	79
    };

static const ANTLR3_INT32 dfa13_T112[] =
    {
	218
    };

static const ANTLR3_INT32 dfa13_T113[] =
    {
	80
    };

static const ANTLR3_INT32 dfa13_T114[] =
    {
	215
    };

static const ANTLR3_INT32 dfa13_T115[] =
    {
	92
    };

static const ANTLR3_INT32 dfa13_T116[] =
    {
	227
    };

static const ANTLR3_INT32 dfa13_T117[] =
    {
	283
    };

static const ANTLR3_INT32 dfa13_T118[] =
    {
	228
    };

static const ANTLR3_INT32 dfa13_T119[] =
    {
	284
    };

static const ANTLR3_INT32 dfa13_T120[] =
    {
	219
    };

static const ANTLR3_INT32 dfa13_T121[] =
    {
	275
    };

static const ANTLR3_INT32 dfa13_T122[] =
    {
	220
    };

static const ANTLR3_INT32 dfa13_T123[] =
    {
	276
    };

static const ANTLR3_INT32 dfa13_T124[] =
    {
	132
    };

static const ANTLR3_INT32 dfa13_T125[] =
    {
	155, -1, -1, 160, 158, -1, -1, -1, 159, 157, -1, -1, -1, -1, 156, -1, -1, 
	154
    };

static const ANTLR3_INT32 dfa13_T126[] =
    {
	194
    };

static const ANTLR3_INT32 dfa13_T127[] =
    {
	221
    };

static const ANTLR3_INT32 dfa13_T128[] =
    {
	253
    };

static const ANTLR3_INT32 dfa13_T129[] =
    {
	277
    };

static const ANTLR3_INT32 dfa13_T130[] =
    {
	306
    };

static const ANTLR3_INT32 dfa13_T131[] =
    {
	340
    };

static const ANTLR3_INT32 dfa13_T132[] =
    {
	355, -1, -1, -1, -1, -1, 356
    };

static const ANTLR3_INT32 dfa13_T133[] =
    {
	63, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, 62
    };

static const ANTLR3_INT32 dfa13_T134[] =
    {
	222
    };

static const ANTLR3_INT32 dfa13_T135[] =
    {
	165
    };

static const ANTLR3_INT32 dfa13_T136[] =
    {
	233
    };

static const ANTLR3_INT32 dfa13_T137[] =
    {
	289
    };

static const ANTLR3_INT32 dfa13_T138[] =
    {
	208
    };

static const ANTLR3_INT32 dfa13_T139[] =
    {
	265
    };

static const ANTLR3_INT32 dfa13_T140[] =
    {
	54, -1, -1, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, -1, -1, -1, -1, -1, -1, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, 
	-1, -1, 54, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54
    };

static const ANTLR3_INT32 dfa13_T141[] =
    {
	105
    };

static const ANTLR3_INT32 dfa13_T142[] =
    {
	167, 168
    };

static const ANTLR3_INT32 dfa13_T143[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, 47, 54, 54, 54, 
	48, 49, 54, 54, 54, 54, 54, 50, 54, 51, 54, 46, 54, 54, 52, 54, 54, 54, 
	54, 54, 54, 54
    };

static const ANTLR3_INT32 dfa13_T144[] =
    {
	110, -1, -1, -1, -1, -1, -1, 111
    };

static const ANTLR3_INT32 dfa13_T145[] =
    {
	131
    };

static const ANTLR3_INT32 dfa13_T146[] =
    {
	193
    };

static const ANTLR3_INT32 dfa13_T147[] =
    {
	252
    };

static const ANTLR3_INT32 dfa13_T148[] =
    {
	305
    };

static const ANTLR3_INT32 dfa13_T149[] =
    {
	133
    };

static const ANTLR3_INT32 dfa13_T150[] =
    {
	195
    };

static const ANTLR3_INT32 dfa13_T151[] =
    {
	254
    };

static const ANTLR3_INT32 dfa13_T152[] =
    {
	307
    };

static const ANTLR3_INT32 dfa13_T153[] =
    {
	120, -1, -1, -1, -1, -1, -1, -1, 121
    };

static const ANTLR3_INT32 dfa13_T154[] =
    {
	341
    };

static const ANTLR3_INT32 dfa13_T155[] =
    {
	357
    };

static const ANTLR3_INT32 dfa13_T156[] =
    {
	369
    };

static const ANTLR3_INT32 dfa13_T157[] =
    {
	379
    };

static const ANTLR3_INT32 dfa13_T158[] =
    {
	388
    };

static const ANTLR3_INT32 dfa13_T159[] =
    {
	117
    };

static const ANTLR3_INT32 dfa13_T160[] =
    {
	180
    };

static const ANTLR3_INT32 dfa13_T161[] =
    {
	242
    };

static const ANTLR3_INT32 dfa13_T162[] =
    {
	296
    };

static const ANTLR3_INT32 dfa13_T163[] =
    {
	331
    };

static const ANTLR3_INT32 dfa13_T164[] =
    {
	351
    };

static const ANTLR3_INT32 dfa13_T165[] =
    {
	365
    };

static const ANTLR3_INT32 dfa13_T166[] =
    {
	376
    };

static const ANTLR3_INT32 dfa13_T167[] =
    {
	385
    };

static const ANTLR3_INT32 dfa13_T168[] =
    {
	367
    };

static const ANTLR3_INT32 dfa13_T169[] =
    {
	377
    };

static const ANTLR3_INT32 dfa13_T170[] =
    {
	386
    };

static const ANTLR3_INT32 dfa13_T171[] =
    {
	368
    };

static const ANTLR3_INT32 dfa13_T172[] =
    {
	378
    };

static const ANTLR3_INT32 dfa13_T173[] =
    {
	387
    };

static const ANTLR3_INT32 dfa13_T174[] =
    {
	395
    };

static const ANTLR3_INT32 dfa13_T175[] =
    {
	70, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71
    };

static const ANTLR3_INT32 dfa13_T176[] =
    {
	83
    };

static const ANTLR3_INT32 dfa13_T177[] =
    {
	72
    };

static const ANTLR3_INT32 dfa13_T178[] =
    {
	144, -1, -1, -1, -1, -1, -1, -1, -1, -1, 143, -1, -1, -1, -1, 145
    };

static const ANTLR3_INT32 dfa13_T179[] =
    {
	136
    };

static const ANTLR3_INT32 dfa13_T180[] =
    {
	199
    };

static const ANTLR3_INT32 dfa13_T181[] =
    {
	256
    };

static const ANTLR3_INT32 dfa13_T182[] =
    {
	42, 42, -1, 42, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 42, -1, 44, 30, 40, 27, 15, -1, 10, 11, 31, 29, -1, 
	24, -1, 19, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 45, 23, 20, 22, 
	39, 17, 2, 34, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 3, -1, 4, -1, -1, -1, 16, 6, 35, 
	18, 21, 7, 38, 38, 8, 38, 38, 9, 38, 25, 26, 38, 38, 36, 12, 13, 14, 38, 
	38, 33, 38, 37, 41, 28, 5, 32
    };

static const ANTLR3_INT32 dfa13_T183[] =
    {
	309, -1, -1, -1, -1, -1, -1, -1, -1, -1, 310, -1, -1, 311
    };

static const ANTLR3_INT32 dfa13_T184[] =
    {
	124, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 125
    };

static const ANTLR3_INT32 dfa13_T185[] =
    {
	88
    };

static const ANTLR3_INT32 dfa13_T186[] =
    {
	75
    };

static const ANTLR3_INT32 dfa13_T187[] =
    {
	104, 104, 104, 104, 104, 104, 104, 104, 104, 104, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, -1, 99, 
	-1, -1, -1, -1, -1, -1, -1, -1, 103, 100, 98, 96, -1, -1, -1, 101, -1, 
	102, -1, -1, 97
    };

static const ANTLR3_INT32 dfa13_T188[] =
    {
	59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, 61
    };

static const ANTLR3_INT32 dfa13_T189[] =
    {
	93
    };

static const ANTLR3_INT32 dfa13_T190[] =
    {
	141
    };

static const ANTLR3_INT32 dfa13_T191[] =
    {
	204
    };

static const ANTLR3_INT32 dfa13_T192[] =
    {
	261
    };

static const ANTLR3_INT32 dfa13_T193[] =
    {
	148, 147
    };

static const ANTLR3_INT32 dfa13_T194[] =
    {
	213, -1, 212
    };

static const ANTLR3_INT32 dfa13_T195[] =
    {
	94
    };

static const ANTLR3_INT32 dfa13_T196[] =
    {
	142
    };

static const ANTLR3_INT32 dfa13_T197[] =
    {
	205
    };

static const ANTLR3_INT32 dfa13_T198[] =
    {
	262
    };

static const ANTLR3_INT32 dfa13_T199[] =
    {
	316
    };

static const ANTLR3_INT32 dfa13_T200[] =
    {
	348
    };

static const ANTLR3_INT32 dfa13_T201[] =
    {
	363
    };

static const ANTLR3_INT32 dfa13_T202[] =
    {
	85, -1, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43
    };

static const ANTLR3_INT32 dfa13_T203[] =
    {
	197, 197, -1, 197, 197, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 197, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, 
	-1, -1, 54, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 
	-1, -1, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 197
    };

static const ANTLR3_INT32 dfa13_T204[] =
    {
	106
    };

static const ANTLR3_INT32 dfa13_T205[] =
    {
	169
    };

static const ANTLR3_INT32 dfa13_T206[] =
    {
	235
    };

static const ANTLR3_INT32 dfa13_T207[] =
    {
	107
    };

static const ANTLR3_INT32 dfa13_T208[] =
    {
	170
    };

static const ANTLR3_INT32 dfa13_T209[] =
    {
	55
    };

static const ANTLR3_INT32 dfa13_T210[] =
    {
	109
    };

static const ANTLR3_INT32 dfa13_T211[] =
    {
	134
    };

static const ANTLR3_INT32 dfa13_T212[] =
    {
	173
    };

static const ANTLR3_INT32 dfa13_T213[] =
    {
	238
    };

static const ANTLR3_INT32 dfa13_T214[] =
    {
	292
    };

static const ANTLR3_INT32 dfa13_T215[] =
    {
	328
    };

static const ANTLR3_INT32 dfa13_T216[] =
    {
	349
    };

static const ANTLR3_INT32 dfa13_T217[] =
    {
	364
    };

static const ANTLR3_INT32 dfa13_T218[] =
    {
	375
    };

static const ANTLR3_INT32 dfa13_T219[] =
    {
	384
    };

static const ANTLR3_INT32 dfa13_T220[] =
    {
	392
    };

static const ANTLR3_INT32 dfa13_T221[] =
    {
	113
    };

static const ANTLR3_INT32 dfa13_T222[] =
    {
	114
    };

static const ANTLR3_INT32 dfa13_T223[] =
    {
	118
    };

static const ANTLR3_INT32 dfa13_T224[] =
    {
	66, -1, -1, -1, 67, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 68
    };

static const ANTLR3_INT32 dfa13_T225[] =
    {
	181
    };

static const ANTLR3_INT32 dfa13_T226[] =
    {
	243
    };

static const ANTLR3_INT32 dfa13_T227[] =
    {
	297
    };

static const ANTLR3_INT32 dfa13_T228[] =
    {
	119
    };

static const ANTLR3_INT32 dfa13_T229[] =
    {
	182
    };

static const ANTLR3_INT32 dfa13_T230[] =
    {
	183
    };

static const ANTLR3_INT32 dfa13_T231[] =
    {
	245
    };

static const ANTLR3_INT32 dfa13_T232[] =
    {
	298
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa13_transitions[] =
{
    dfa13_T182, dfa13_T143, dfa13_T209, NULL, NULL, NULL, dfa13_T53, dfa13_T188, 
    dfa13_T133, dfa13_T24, NULL, NULL, dfa13_T224, dfa13_T175, dfa13_T177, 
    NULL, dfa13_T60, NULL, dfa13_T67, NULL, NULL, dfa13_T186, NULL, NULL, 
    NULL, dfa13_T94, dfa13_T96, NULL, NULL, NULL, NULL, NULL, NULL, dfa13_T109, 
    dfa13_T111, dfa13_T113, dfa13_T101, dfa13_T176, NULL, NULL, NULL, NULL, 
    NULL, dfa13_T202, NULL, NULL, dfa13_T13, dfa13_T58, dfa13_T185, dfa13_T95, 
    dfa13_T105, dfa13_T110, dfa13_T115, NULL, NULL, dfa13_T189, dfa13_T195, 
    dfa13_T187, dfa13_T141, dfa13_T204, dfa13_T207, dfa13_T31, dfa13_T210, 
    dfa13_T144, dfa13_T41, dfa13_T221, dfa13_T222, dfa13_T54, dfa13_T64, 
    dfa13_T159, dfa13_T223, dfa13_T228, dfa13_T153, dfa13_T12, dfa13_T14, 
    dfa13_T184, dfa13_T47, dfa13_T6, dfa13_T71, dfa13_T73, dfa13_T77, dfa13_T145, 
    dfa13_T124, dfa13_T149, NULL, NULL, dfa13_T211, dfa13_T3, dfa13_T179, 
    dfa13_T46, dfa13_T61, dfa13_T69, dfa13_T79, dfa13_T190, dfa13_T196, 
    dfa13_T178, dfa13_T91, dfa13_T193, dfa13_T59, dfa13_T102, dfa13_T106, 
    dfa13_T125, dfa13_T15, dfa13_T135, dfa13_T38, dfa13_T142, dfa13_T205, 
    dfa13_T208, dfa13_T33, dfa13_T6, dfa13_T212, dfa13_T6, dfa13_T42, dfa13_T6, 
    dfa13_T6, dfa13_T55, dfa13_T65, dfa13_T160, dfa13_T225, dfa13_T229, 
    dfa13_T230, dfa13_T1, dfa13_T6, dfa13_T16, dfa13_T25, dfa13_T85, dfa13_T6, 
    NULL, dfa13_T6, dfa13_T74, dfa13_T78, dfa13_T146, dfa13_T126, dfa13_T150, 
    dfa13_T203, dfa13_T4, dfa13_T180, dfa13_T48, dfa13_T62, dfa13_T70, dfa13_T81, 
    dfa13_T191, dfa13_T197, dfa13_T90, dfa13_T108, dfa13_T138, dfa13_T6, 
    dfa13_T92, dfa13_T99, dfa13_T194, dfa13_T97, dfa13_T114, dfa13_T103, 
    dfa13_T107, dfa13_T112, dfa13_T120, dfa13_T122, dfa13_T127, dfa13_T134, 
    dfa13_T86, dfa13_T93, dfa13_T116, dfa13_T118, dfa13_T52, dfa13_T68, 
    dfa13_T136, NULL, dfa13_T6, dfa13_T6, dfa13_T206, dfa13_T6, dfa13_T34, 
    NULL, dfa13_T213, NULL, dfa13_T43, NULL, NULL, dfa13_T56, dfa13_T66, 
    dfa13_T161, dfa13_T226, dfa13_T6, dfa13_T231, dfa13_T2, NULL, dfa13_T17, 
    dfa13_T26, dfa13_T87, NULL, NULL, dfa13_T75, dfa13_T80, dfa13_T147, 
    dfa13_T128, dfa13_T151, NULL, NULL, dfa13_T5, dfa13_T181, dfa13_T49, 
    dfa13_T63, dfa13_T72, dfa13_T83, dfa13_T192, dfa13_T198, dfa13_T6, dfa13_T6, 
    dfa13_T139, NULL, dfa13_T6, dfa13_T100, dfa13_T6, dfa13_T6, dfa13_T98, 
    dfa13_T6, dfa13_T104, dfa13_T6, dfa13_T6, dfa13_T121, dfa13_T123, dfa13_T129, 
    dfa13_T6, dfa13_T6, dfa13_T6, dfa13_T6, dfa13_T6, dfa13_T117, dfa13_T119, 
    dfa13_T6, dfa13_T6, dfa13_T6, dfa13_T6, dfa13_T137, NULL, dfa13_T6, 
    NULL, dfa13_T35, dfa13_T214, dfa13_T44, dfa13_T57, dfa13_T6, dfa13_T162, 
    dfa13_T227, NULL, dfa13_T232, dfa13_T6, dfa13_T18, dfa13_T27, dfa13_T88, 
    dfa13_T76, dfa13_T82, dfa13_T148, dfa13_T130, dfa13_T152, dfa13_T7, 
    dfa13_T183, dfa13_T50, dfa13_T140, dfa13_T140, dfa13_T84, NULL, dfa13_T199, 
    NULL, NULL, dfa13_T6, NULL, dfa13_T6, NULL, NULL, dfa13_T6, NULL, dfa13_T6, 
    NULL, NULL, dfa13_T6, dfa13_T6, dfa13_T6, NULL, NULL, NULL, NULL, NULL, 
    dfa13_T6, dfa13_T6, NULL, NULL, NULL, NULL, dfa13_T6, NULL, dfa13_T6, 
    dfa13_T215, dfa13_T45, dfa13_T6, NULL, dfa13_T163, dfa13_T6, dfa13_T0, 
    NULL, dfa13_T19, dfa13_T6, dfa13_T89, dfa13_T6, dfa13_T6, dfa13_T6, 
    dfa13_T131, dfa13_T154, dfa13_T8, dfa13_T21, dfa13_T28, dfa13_T36, dfa13_T51, 
    NULL, NULL, dfa13_T140, dfa13_T200, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, dfa13_T216, dfa13_T6, NULL, dfa13_T164, 
    NULL, dfa13_T6, dfa13_T20, NULL, dfa13_T6, NULL, NULL, NULL, dfa13_T132, 
    dfa13_T155, dfa13_T9, dfa13_T22, dfa13_T29, dfa13_T37, dfa13_T140, NULL, 
    dfa13_T201, dfa13_T217, NULL, dfa13_T165, NULL, dfa13_T6, NULL, dfa13_T168, 
    dfa13_T171, dfa13_T156, dfa13_T10, dfa13_T23, dfa13_T30, dfa13_T39, 
    NULL, dfa13_T6, dfa13_T218, dfa13_T166, NULL, dfa13_T169, dfa13_T172, 
    dfa13_T157, dfa13_T11, dfa13_T140, dfa13_T32, dfa13_T40, NULL, dfa13_T219, 
    dfa13_T167, dfa13_T170, dfa13_T173, dfa13_T158, dfa13_T140, NULL, dfa13_T140, 
    dfa13_T140, dfa13_T220, dfa13_T6, dfa13_T6, dfa13_T174, dfa13_T6, NULL, 
    NULL, NULL, dfa13_T6, NULL, NULL, dfa13_T6, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 13
 */
static
ANTLR3_CYCLIC_DFA cdfa13
    =	{
	    13,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | ASSUMPTION_TOK | BENCHMARK_TOK | EXTRAFUNS_TOK | EXTRAPREDS_TOK | EXTRASORTS_TOK | FALSE_TOK | FLET_TOK | FORMULA_TOK | ITE_TOK | LET_TOK | LOGIC_TOK | LPAREN_TOK | NOTES_TOK | RPAREN_TOK | SAT_TOK | STATUS_TOK | THEORY_TOK | TRUE_TOK | UNKNOWN_TOK | UNSAT_TOK | AMPERSAND_TOK | AND_TOK | AT_TOK | DISTINCT_TOK | DIV_TOK | EQUAL_TOK | EXISTS_TOK | FORALL_TOK | GREATER_THAN_TOK | IFF_TOK | IMPLIES_TOK | LESS_THAN_TOK | MINUS_TOK | NOT_TOK | OR_TOK | PERCENT_TOK | PIPE_TOK | PLUS_TOK | POUND_TOK | SELECT_TOK | STAR_TOK | STORE_TOK | TILDE_TOK | XOR_TOK | BITVECTOR_TOK | CONCAT_TOK | EXTRACT_TOK | BVAND_TOK | BVOR_TOK | BVXOR_TOK | BVNOT_TOK | BVNAND_TOK | BVNOR_TOK | BVXNOR_TOK | BVCOMP_TOK | BVMUL_TOK | BVADD_TOK | BVSUB_TOK | BVNEG_TOK | BVUDIV_TOK | BVUREM_TOK | BVSDIV_TOK | BVSREM_TOK | BVSMOD_TOK | BVSHL_TOK | BVLSHR_TOK | BVASHR_TOK | BVULT_TOK | BVULE_TOK | BVUGT_TOK | BVUGE_TOK | BVSLT_TOK | BVSLE_TOK | BVSGT_TOK | BVSGE_TOK | REPEAT_TOK | ZERO_EXTEND_TOK | SIGN_EXTEND_TOK | ROTATE_LEFT_TOK | ROTATE_RIGHT_TOK | BITVECTOR_BV_CONST | BITVECTOR1_BV_CONST | IDENTIFIER | ATTR_IDENTIFIER | LET_IDENTIFIER | FLET_IDENTIFIER | PATTERN_ANNOTATION_BEGIN | USER_VALUE | WHITESPACE | NUMERAL_TOK | RATIONAL_TOK | STRING_LITERAL | COMMENT );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa13_eot,	    /* EOT table			    */
	    dfa13_eof,	    /* EOF table			    */
	    dfa13_min,	    /* Minimum tokens for each state    */
	    dfa13_max,	    /* Maximum tokens for each state    */
	    dfa13_accept,	/* Accept table			    */
	    dfa13_special,	/* Special transition states	    */
	    dfa13_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 13
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 33:8: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__100
 *
 * Looks to match the characters the constitute the token T__100
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__100(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__100;


    // ../../../../../../src/parser/smt1/Smt1.g:33:8: ( ':' )
    // ../../../../../../src/parser/smt1/Smt1.g:33:10: ':'
    {
        MATCHC(':');
        if  (HASEXCEPTION())
        {
            goto ruleT__100Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__100Ex; /* Prevent compiler warnings */
    ruleT__100Ex: ;

}
// $ANTLR end T__100

//   Comes from: 34:8: ( ':pat' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__101
 *
 * Looks to match the characters the constitute the token T__101
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__101(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__101;


    // ../../../../../../src/parser/smt1/Smt1.g:34:8: ( ':pat' )
    // ../../../../../../src/parser/smt1/Smt1.g:34:10: ':pat'
    {
        MATCHS(lit_1);
        if  (HASEXCEPTION())
        {
            goto ruleT__101Ex;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__101Ex; /* Prevent compiler warnings */
    ruleT__101Ex: ;

}
// $ANTLR end T__101

//   Comes from: 35:8: ( 'Array[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__102
 *
 * Looks to match the characters the constitute the token T__102
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__102(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__102;


    // ../../../../../../src/parser/smt1/Smt1.g:35:8: ( 'Array[' )
    // ../../../../../../src/parser/smt1/Smt1.g:35:10: 'Array['
    {
        MATCHS(lit_2);
        if  (HASEXCEPTION())
        {
            goto ruleT__102Ex;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__102Ex; /* Prevent compiler warnings */
    ruleT__102Ex: ;

}
// $ANTLR end T__102

//   Comes from: 36:8: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__103
 *
 * Looks to match the characters the constitute the token T__103
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__103(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__103;


    // ../../../../../../src/parser/smt1/Smt1.g:36:8: ( '[' )
    // ../../../../../../src/parser/smt1/Smt1.g:36:10: '['
    {
        MATCHC('[');
        if  (HASEXCEPTION())
        {
            goto ruleT__103Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__103Ex; /* Prevent compiler warnings */
    ruleT__103Ex: ;

}
// $ANTLR end T__103

//   Comes from: 37:8: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__104
 *
 * Looks to match the characters the constitute the token T__104
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__104(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__104;


    // ../../../../../../src/parser/smt1/Smt1.g:37:8: ( ']' )
    // ../../../../../../src/parser/smt1/Smt1.g:37:10: ']'
    {
        MATCHC(']');
        if  (HASEXCEPTION())
        {
            goto ruleT__104Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__104Ex; /* Prevent compiler warnings */
    ruleT__104Ex: ;

}
// $ANTLR end T__104

//   Comes from: 38:8: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__105
 *
 * Looks to match the characters the constitute the token T__105
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__105(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__105;


    // ../../../../../../src/parser/smt1/Smt1.g:38:8: ( '}' )
    // ../../../../../../src/parser/smt1/Smt1.g:38:10: '}'
    {
        MATCHC('}');
        if  (HASEXCEPTION())
        {
            goto ruleT__105Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__105Ex; /* Prevent compiler warnings */
    ruleT__105Ex: ;

}
// $ANTLR end T__105

//   Comes from: 689:17: ( ':assumption' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSUMPTION_TOK
 *
 * Looks to match the characters the constitute the token ASSUMPTION_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mASSUMPTION_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ASSUMPTION_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:689:17: ( ':assumption' )
    // ../../../../../../src/parser/smt1/Smt1.g:689:19: ':assumption'
    {
        MATCHS(lit_3);
        if  (HASEXCEPTION())
        {
            goto ruleASSUMPTION_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASSUMPTION_TOKEx; /* Prevent compiler warnings */
    ruleASSUMPTION_TOKEx: ;

}
// $ANTLR end ASSUMPTION_TOK

//   Comes from: 690:17: ( 'benchmark' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BENCHMARK_TOK
 *
 * Looks to match the characters the constitute the token BENCHMARK_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBENCHMARK_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BENCHMARK_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:690:17: ( 'benchmark' )
    // ../../../../../../src/parser/smt1/Smt1.g:690:19: 'benchmark'
    {
        MATCHS(lit_4);
        if  (HASEXCEPTION())
        {
            goto ruleBENCHMARK_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBENCHMARK_TOKEx; /* Prevent compiler warnings */
    ruleBENCHMARK_TOKEx: ;

}
// $ANTLR end BENCHMARK_TOK

//   Comes from: 691:17: ( ':extrafuns' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTRAFUNS_TOK
 *
 * Looks to match the characters the constitute the token EXTRAFUNS_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTRAFUNS_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTRAFUNS_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:691:17: ( ':extrafuns' )
    // ../../../../../../src/parser/smt1/Smt1.g:691:19: ':extrafuns'
    {
        MATCHS(lit_5);
        if  (HASEXCEPTION())
        {
            goto ruleEXTRAFUNS_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEXTRAFUNS_TOKEx; /* Prevent compiler warnings */
    ruleEXTRAFUNS_TOKEx: ;

}
// $ANTLR end EXTRAFUNS_TOK

//   Comes from: 692:17: ( ':extrapreds' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTRAPREDS_TOK
 *
 * Looks to match the characters the constitute the token EXTRAPREDS_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTRAPREDS_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTRAPREDS_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:692:17: ( ':extrapreds' )
    // ../../../../../../src/parser/smt1/Smt1.g:692:19: ':extrapreds'
    {
        MATCHS(lit_6);
        if  (HASEXCEPTION())
        {
            goto ruleEXTRAPREDS_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEXTRAPREDS_TOKEx; /* Prevent compiler warnings */
    ruleEXTRAPREDS_TOKEx: ;

}
// $ANTLR end EXTRAPREDS_TOK

//   Comes from: 693:17: ( ':extrasorts' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTRASORTS_TOK
 *
 * Looks to match the characters the constitute the token EXTRASORTS_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTRASORTS_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTRASORTS_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:693:17: ( ':extrasorts' )
    // ../../../../../../src/parser/smt1/Smt1.g:693:19: ':extrasorts'
    {
        MATCHS(lit_7);
        if  (HASEXCEPTION())
        {
            goto ruleEXTRASORTS_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEXTRASORTS_TOKEx; /* Prevent compiler warnings */
    ruleEXTRASORTS_TOKEx: ;

}
// $ANTLR end EXTRASORTS_TOK

//   Comes from: 694:17: ( 'false' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FALSE_TOK
 *
 * Looks to match the characters the constitute the token FALSE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFALSE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FALSE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:694:17: ( 'false' )
    // ../../../../../../src/parser/smt1/Smt1.g:694:19: 'false'
    {
        MATCHS(lit_8);
        if  (HASEXCEPTION())
        {
            goto ruleFALSE_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFALSE_TOKEx; /* Prevent compiler warnings */
    ruleFALSE_TOKEx: ;

}
// $ANTLR end FALSE_TOK

//   Comes from: 695:17: ( 'flet' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLET_TOK
 *
 * Looks to match the characters the constitute the token FLET_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLET_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLET_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:695:17: ( 'flet' )
    // ../../../../../../src/parser/smt1/Smt1.g:695:19: 'flet'
    {
        MATCHS(lit_9);
        if  (HASEXCEPTION())
        {
            goto ruleFLET_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFLET_TOKEx; /* Prevent compiler warnings */
    ruleFLET_TOKEx: ;

}
// $ANTLR end FLET_TOK

//   Comes from: 696:17: ( ':formula' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FORMULA_TOK
 *
 * Looks to match the characters the constitute the token FORMULA_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFORMULA_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FORMULA_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:696:17: ( ':formula' )
    // ../../../../../../src/parser/smt1/Smt1.g:696:19: ':formula'
    {
        MATCHS(lit_10);
        if  (HASEXCEPTION())
        {
            goto ruleFORMULA_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFORMULA_TOKEx; /* Prevent compiler warnings */
    ruleFORMULA_TOKEx: ;

}
// $ANTLR end FORMULA_TOK

//   Comes from: 697:17: ( 'ite' | 'if_then_else' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ITE_TOK
 *
 * Looks to match the characters the constitute the token ITE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mITE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ITE_TOK;


    {
        //  ../../../../../../src/parser/smt1/Smt1.g:697:17: ( 'ite' | 'if_then_else' )

        ANTLR3_UINT32 alt1;

        alt1=2;

        switch ( LA(1) )
        {
        case 'i':
        	{
        		switch ( LA(2) )
        		{
        		case 't':
        			{
        				alt1=1;
        			}
        		    break;
        		case 'f':
        			{
        				alt1=2;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 1;
        		    EXCEPTION->state        = 1;


        		    goto ruleITE_TOKEx;

        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 1;
            EXCEPTION->state        = 0;


            goto ruleITE_TOKEx;

        }

        switch (alt1)
        {
    	case 1:
    	    // ../../../../../../src/parser/smt1/Smt1.g:697:19: 'ite'
    	    {
    	        MATCHS(lit_11);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleITE_TOKEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // ../../../../../../src/parser/smt1/Smt1.g:697:27: 'if_then_else'
    	    {
    	        MATCHS(lit_12);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleITE_TOKEx;
    	        }




    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleITE_TOKEx; /* Prevent compiler warnings */
    ruleITE_TOKEx: ;

}
// $ANTLR end ITE_TOK

//   Comes from: 698:17: ( 'let' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LET_TOK
 *
 * Looks to match the characters the constitute the token LET_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLET_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LET_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:698:17: ( 'let' )
    // ../../../../../../src/parser/smt1/Smt1.g:698:19: 'let'
    {
        MATCHS(lit_13);
        if  (HASEXCEPTION())
        {
            goto ruleLET_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLET_TOKEx; /* Prevent compiler warnings */
    ruleLET_TOKEx: ;

}
// $ANTLR end LET_TOK

//   Comes from: 699:17: ( ':logic' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LOGIC_TOK
 *
 * Looks to match the characters the constitute the token LOGIC_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLOGIC_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LOGIC_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:699:17: ( ':logic' )
    // ../../../../../../src/parser/smt1/Smt1.g:699:19: ':logic'
    {
        MATCHS(lit_14);
        if  (HASEXCEPTION())
        {
            goto ruleLOGIC_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLOGIC_TOKEx; /* Prevent compiler warnings */
    ruleLOGIC_TOKEx: ;

}
// $ANTLR end LOGIC_TOK

//   Comes from: 700:17: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAREN_TOK
 *
 * Looks to match the characters the constitute the token LPAREN_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLPAREN_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LPAREN_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:700:17: ( '(' )
    // ../../../../../../src/parser/smt1/Smt1.g:700:19: '('
    {
        MATCHC('(');
        if  (HASEXCEPTION())
        {
            goto ruleLPAREN_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLPAREN_TOKEx; /* Prevent compiler warnings */
    ruleLPAREN_TOKEx: ;

}
// $ANTLR end LPAREN_TOK

//   Comes from: 701:17: ( ':notes' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOTES_TOK
 *
 * Looks to match the characters the constitute the token NOTES_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOTES_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOTES_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:701:17: ( ':notes' )
    // ../../../../../../src/parser/smt1/Smt1.g:701:19: ':notes'
    {
        MATCHS(lit_15);
        if  (HASEXCEPTION())
        {
            goto ruleNOTES_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNOTES_TOKEx; /* Prevent compiler warnings */
    ruleNOTES_TOKEx: ;

}
// $ANTLR end NOTES_TOK

//   Comes from: 702:17: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAREN_TOK
 *
 * Looks to match the characters the constitute the token RPAREN_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRPAREN_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RPAREN_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:702:17: ( ')' )
    // ../../../../../../src/parser/smt1/Smt1.g:702:19: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION())
        {
            goto ruleRPAREN_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleRPAREN_TOKEx; /* Prevent compiler warnings */
    ruleRPAREN_TOKEx: ;

}
// $ANTLR end RPAREN_TOK

//   Comes from: 703:17: ( 'sat' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAT_TOK
 *
 * Looks to match the characters the constitute the token SAT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SAT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:703:17: ( 'sat' )
    // ../../../../../../src/parser/smt1/Smt1.g:703:19: 'sat'
    {
        MATCHS(lit_16);
        if  (HASEXCEPTION())
        {
            goto ruleSAT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSAT_TOKEx; /* Prevent compiler warnings */
    ruleSAT_TOKEx: ;

}
// $ANTLR end SAT_TOK

//   Comes from: 704:17: ( ':status' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STATUS_TOK
 *
 * Looks to match the characters the constitute the token STATUS_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTATUS_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STATUS_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:704:17: ( ':status' )
    // ../../../../../../src/parser/smt1/Smt1.g:704:19: ':status'
    {
        MATCHS(lit_17);
        if  (HASEXCEPTION())
        {
            goto ruleSTATUS_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTATUS_TOKEx; /* Prevent compiler warnings */
    ruleSTATUS_TOKEx: ;

}
// $ANTLR end STATUS_TOK

//   Comes from: 705:17: ( 'theory' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start THEORY_TOK
 *
 * Looks to match the characters the constitute the token THEORY_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTHEORY_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = THEORY_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:705:17: ( 'theory' )
    // ../../../../../../src/parser/smt1/Smt1.g:705:19: 'theory'
    {
        MATCHS(lit_18);
        if  (HASEXCEPTION())
        {
            goto ruleTHEORY_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTHEORY_TOKEx; /* Prevent compiler warnings */
    ruleTHEORY_TOKEx: ;

}
// $ANTLR end THEORY_TOK

//   Comes from: 706:17: ( 'true' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRUE_TOK
 *
 * Looks to match the characters the constitute the token TRUE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTRUE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TRUE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:706:17: ( 'true' )
    // ../../../../../../src/parser/smt1/Smt1.g:706:19: 'true'
    {
        MATCHS(lit_19);
        if  (HASEXCEPTION())
        {
            goto ruleTRUE_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTRUE_TOKEx; /* Prevent compiler warnings */
    ruleTRUE_TOKEx: ;

}
// $ANTLR end TRUE_TOK

//   Comes from: 707:17: ( 'unknown' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNKNOWN_TOK
 *
 * Looks to match the characters the constitute the token UNKNOWN_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNKNOWN_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UNKNOWN_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:707:17: ( 'unknown' )
    // ../../../../../../src/parser/smt1/Smt1.g:707:19: 'unknown'
    {
        MATCHS(lit_20);
        if  (HASEXCEPTION())
        {
            goto ruleUNKNOWN_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUNKNOWN_TOKEx; /* Prevent compiler warnings */
    ruleUNKNOWN_TOKEx: ;

}
// $ANTLR end UNKNOWN_TOK

//   Comes from: 708:17: ( 'unsat' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNSAT_TOK
 *
 * Looks to match the characters the constitute the token UNSAT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNSAT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UNSAT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:708:17: ( 'unsat' )
    // ../../../../../../src/parser/smt1/Smt1.g:708:19: 'unsat'
    {
        MATCHS(lit_21);
        if  (HASEXCEPTION())
        {
            goto ruleUNSAT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUNSAT_TOKEx; /* Prevent compiler warnings */
    ruleUNSAT_TOKEx: ;

}
// $ANTLR end UNSAT_TOK

//   Comes from: 711:19: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AMPERSAND_TOK
 *
 * Looks to match the characters the constitute the token AMPERSAND_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAMPERSAND_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AMPERSAND_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:711:19: ( '&' )
    // ../../../../../../src/parser/smt1/Smt1.g:711:21: '&'
    {
        MATCHC('&');
        if  (HASEXCEPTION())
        {
            goto ruleAMPERSAND_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAMPERSAND_TOKEx; /* Prevent compiler warnings */
    ruleAMPERSAND_TOKEx: ;

}
// $ANTLR end AMPERSAND_TOK

//   Comes from: 712:19: ( 'and' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AND_TOK
 *
 * Looks to match the characters the constitute the token AND_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAND_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AND_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:712:19: ( 'and' )
    // ../../../../../../src/parser/smt1/Smt1.g:712:21: 'and'
    {
        MATCHS(lit_22);
        if  (HASEXCEPTION())
        {
            goto ruleAND_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAND_TOKEx; /* Prevent compiler warnings */
    ruleAND_TOKEx: ;

}
// $ANTLR end AND_TOK

//   Comes from: 713:19: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AT_TOK
 *
 * Looks to match the characters the constitute the token AT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:713:19: ( '@' )
    // ../../../../../../src/parser/smt1/Smt1.g:713:21: '@'
    {
        MATCHC('@');
        if  (HASEXCEPTION())
        {
            goto ruleAT_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAT_TOKEx; /* Prevent compiler warnings */
    ruleAT_TOKEx: ;

}
// $ANTLR end AT_TOK

//   Comes from: 714:19: ( 'distinct' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DISTINCT_TOK
 *
 * Looks to match the characters the constitute the token DISTINCT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDISTINCT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DISTINCT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:714:19: ( 'distinct' )
    // ../../../../../../src/parser/smt1/Smt1.g:714:21: 'distinct'
    {
        MATCHS(lit_23);
        if  (HASEXCEPTION())
        {
            goto ruleDISTINCT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDISTINCT_TOKEx; /* Prevent compiler warnings */
    ruleDISTINCT_TOKEx: ;

}
// $ANTLR end DISTINCT_TOK

//   Comes from: 715:19: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIV_TOK
 *
 * Looks to match the characters the constitute the token DIV_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIV_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DIV_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:715:19: ( '/' )
    // ../../../../../../src/parser/smt1/Smt1.g:715:21: '/'
    {
        MATCHC('/');
        if  (HASEXCEPTION())
        {
            goto ruleDIV_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDIV_TOKEx; /* Prevent compiler warnings */
    ruleDIV_TOKEx: ;

}
// $ANTLR end DIV_TOK

//   Comes from: 716:19: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUAL_TOK
 *
 * Looks to match the characters the constitute the token EQUAL_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEQUAL_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EQUAL_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:716:19: ( '=' )
    // ../../../../../../src/parser/smt1/Smt1.g:716:21: '='
    {
        MATCHC('=');
        if  (HASEXCEPTION())
        {
            goto ruleEQUAL_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEQUAL_TOKEx; /* Prevent compiler warnings */
    ruleEQUAL_TOKEx: ;

}
// $ANTLR end EQUAL_TOK

//   Comes from: 717:19: ( 'exists' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXISTS_TOK
 *
 * Looks to match the characters the constitute the token EXISTS_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXISTS_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXISTS_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:717:19: ( 'exists' )
    // ../../../../../../src/parser/smt1/Smt1.g:717:21: 'exists'
    {
        MATCHS(lit_24);
        if  (HASEXCEPTION())
        {
            goto ruleEXISTS_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEXISTS_TOKEx; /* Prevent compiler warnings */
    ruleEXISTS_TOKEx: ;

}
// $ANTLR end EXISTS_TOK

//   Comes from: 718:19: ( 'forall' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FORALL_TOK
 *
 * Looks to match the characters the constitute the token FORALL_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFORALL_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FORALL_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:718:19: ( 'forall' )
    // ../../../../../../src/parser/smt1/Smt1.g:718:21: 'forall'
    {
        MATCHS(lit_25);
        if  (HASEXCEPTION())
        {
            goto ruleFORALL_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFORALL_TOKEx; /* Prevent compiler warnings */
    ruleFORALL_TOKEx: ;

}
// $ANTLR end FORALL_TOK

//   Comes from: 719:19: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN_TOK
 *
 * Looks to match the characters the constitute the token GREATER_THAN_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGREATER_THAN_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GREATER_THAN_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:719:19: ( '>' )
    // ../../../../../../src/parser/smt1/Smt1.g:719:21: '>'
    {
        MATCHC('>');
        if  (HASEXCEPTION())
        {
            goto ruleGREATER_THAN_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGREATER_THAN_TOKEx; /* Prevent compiler warnings */
    ruleGREATER_THAN_TOKEx: ;

}
// $ANTLR end GREATER_THAN_TOK

//   Comes from: 720:19: ( 'iff' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IFF_TOK
 *
 * Looks to match the characters the constitute the token IFF_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIFF_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IFF_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:720:19: ( 'iff' )
    // ../../../../../../src/parser/smt1/Smt1.g:720:21: 'iff'
    {
        MATCHS(lit_26);
        if  (HASEXCEPTION())
        {
            goto ruleIFF_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIFF_TOKEx; /* Prevent compiler warnings */
    ruleIFF_TOKEx: ;

}
// $ANTLR end IFF_TOK

//   Comes from: 721:19: ( 'implies' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IMPLIES_TOK
 *
 * Looks to match the characters the constitute the token IMPLIES_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIMPLIES_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IMPLIES_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:721:19: ( 'implies' )
    // ../../../../../../src/parser/smt1/Smt1.g:721:21: 'implies'
    {
        MATCHS(lit_27);
        if  (HASEXCEPTION())
        {
            goto ruleIMPLIES_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIMPLIES_TOKEx; /* Prevent compiler warnings */
    ruleIMPLIES_TOKEx: ;

}
// $ANTLR end IMPLIES_TOK

//   Comes from: 722:19: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN_TOK
 *
 * Looks to match the characters the constitute the token LESS_THAN_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLESS_THAN_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LESS_THAN_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:722:19: ( '<' )
    // ../../../../../../src/parser/smt1/Smt1.g:722:21: '<'
    {
        MATCHC('<');
        if  (HASEXCEPTION())
        {
            goto ruleLESS_THAN_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLESS_THAN_TOKEx; /* Prevent compiler warnings */
    ruleLESS_THAN_TOKEx: ;

}
// $ANTLR end LESS_THAN_TOK

//   Comes from: 723:19: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS_TOK
 *
 * Looks to match the characters the constitute the token MINUS_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMINUS_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MINUS_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:723:19: ( '-' )
    // ../../../../../../src/parser/smt1/Smt1.g:723:21: '-'
    {
        MATCHC('-');
        if  (HASEXCEPTION())
        {
            goto ruleMINUS_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMINUS_TOKEx; /* Prevent compiler warnings */
    ruleMINUS_TOKEx: ;

}
// $ANTLR end MINUS_TOK

//   Comes from: 724:19: ( 'not' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT_TOK
 *
 * Looks to match the characters the constitute the token NOT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:724:19: ( 'not' )
    // ../../../../../../src/parser/smt1/Smt1.g:724:21: 'not'
    {
        MATCHS(lit_28);
        if  (HASEXCEPTION())
        {
            goto ruleNOT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNOT_TOKEx; /* Prevent compiler warnings */
    ruleNOT_TOKEx: ;

}
// $ANTLR end NOT_TOK

//   Comes from: 725:19: ( 'or' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OR_TOK
 *
 * Looks to match the characters the constitute the token OR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:725:19: ( 'or' )
    // ../../../../../../src/parser/smt1/Smt1.g:725:21: 'or'
    {
        MATCHS(lit_29);
        if  (HASEXCEPTION())
        {
            goto ruleOR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOR_TOKEx; /* Prevent compiler warnings */
    ruleOR_TOKEx: ;

}
// $ANTLR end OR_TOK

//   Comes from: 726:19: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERCENT_TOK
 *
 * Looks to match the characters the constitute the token PERCENT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPERCENT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PERCENT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:726:19: ( '%' )
    // ../../../../../../src/parser/smt1/Smt1.g:726:21: '%'
    {
        MATCHC('%');
        if  (HASEXCEPTION())
        {
            goto rulePERCENT_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePERCENT_TOKEx; /* Prevent compiler warnings */
    rulePERCENT_TOKEx: ;

}
// $ANTLR end PERCENT_TOK

//   Comes from: 727:19: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PIPE_TOK
 *
 * Looks to match the characters the constitute the token PIPE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPIPE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PIPE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:727:19: ( '|' )
    // ../../../../../../src/parser/smt1/Smt1.g:727:21: '|'
    {
        MATCHC('|');
        if  (HASEXCEPTION())
        {
            goto rulePIPE_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePIPE_TOKEx; /* Prevent compiler warnings */
    rulePIPE_TOKEx: ;

}
// $ANTLR end PIPE_TOK

//   Comes from: 728:19: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS_TOK
 *
 * Looks to match the characters the constitute the token PLUS_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPLUS_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PLUS_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:728:19: ( '+' )
    // ../../../../../../src/parser/smt1/Smt1.g:728:21: '+'
    {
        MATCHC('+');
        if  (HASEXCEPTION())
        {
            goto rulePLUS_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePLUS_TOKEx; /* Prevent compiler warnings */
    rulePLUS_TOKEx: ;

}
// $ANTLR end PLUS_TOK

//   Comes from: 729:19: ( '#' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start POUND_TOK
 *
 * Looks to match the characters the constitute the token POUND_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPOUND_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = POUND_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:729:19: ( '#' )
    // ../../../../../../src/parser/smt1/Smt1.g:729:21: '#'
    {
        MATCHC('#');
        if  (HASEXCEPTION())
        {
            goto rulePOUND_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePOUND_TOKEx; /* Prevent compiler warnings */
    rulePOUND_TOKEx: ;

}
// $ANTLR end POUND_TOK

//   Comes from: 730:19: ( 'select' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SELECT_TOK
 *
 * Looks to match the characters the constitute the token SELECT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSELECT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SELECT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:730:19: ( 'select' )
    // ../../../../../../src/parser/smt1/Smt1.g:730:21: 'select'
    {
        MATCHS(lit_30);
        if  (HASEXCEPTION())
        {
            goto ruleSELECT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSELECT_TOKEx; /* Prevent compiler warnings */
    ruleSELECT_TOKEx: ;

}
// $ANTLR end SELECT_TOK

//   Comes from: 731:19: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STAR_TOK
 *
 * Looks to match the characters the constitute the token STAR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTAR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STAR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:731:19: ( '*' )
    // ../../../../../../src/parser/smt1/Smt1.g:731:21: '*'
    {
        MATCHC('*');
        if  (HASEXCEPTION())
        {
            goto ruleSTAR_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTAR_TOKEx; /* Prevent compiler warnings */
    ruleSTAR_TOKEx: ;

}
// $ANTLR end STAR_TOK

//   Comes from: 732:19: ( 'store' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STORE_TOK
 *
 * Looks to match the characters the constitute the token STORE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTORE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STORE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:732:19: ( 'store' )
    // ../../../../../../src/parser/smt1/Smt1.g:732:21: 'store'
    {
        MATCHS(lit_31);
        if  (HASEXCEPTION())
        {
            goto ruleSTORE_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTORE_TOKEx; /* Prevent compiler warnings */
    ruleSTORE_TOKEx: ;

}
// $ANTLR end STORE_TOK

//   Comes from: 733:19: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TILDE_TOK
 *
 * Looks to match the characters the constitute the token TILDE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTILDE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TILDE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:733:19: ( '~' )
    // ../../../../../../src/parser/smt1/Smt1.g:733:21: '~'
    {
        MATCHC('~');
        if  (HASEXCEPTION())
        {
            goto ruleTILDE_TOKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTILDE_TOKEx; /* Prevent compiler warnings */
    ruleTILDE_TOKEx: ;

}
// $ANTLR end TILDE_TOK

//   Comes from: 734:19: ( 'xor' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start XOR_TOK
 *
 * Looks to match the characters the constitute the token XOR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mXOR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = XOR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:734:19: ( 'xor' )
    // ../../../../../../src/parser/smt1/Smt1.g:734:21: 'xor'
    {
        MATCHS(lit_32);
        if  (HASEXCEPTION())
        {
            goto ruleXOR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleXOR_TOKEx; /* Prevent compiler warnings */
    ruleXOR_TOKEx: ;

}
// $ANTLR end XOR_TOK

//   Comes from: 737:19: ( 'BitVec' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITVECTOR_TOK
 *
 * Looks to match the characters the constitute the token BITVECTOR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITVECTOR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITVECTOR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:737:19: ( 'BitVec' )
    // ../../../../../../src/parser/smt1/Smt1.g:737:21: 'BitVec'
    {
        MATCHS(lit_33);
        if  (HASEXCEPTION())
        {
            goto ruleBITVECTOR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITVECTOR_TOKEx; /* Prevent compiler warnings */
    ruleBITVECTOR_TOKEx: ;

}
// $ANTLR end BITVECTOR_TOK

//   Comes from: 738:19: ( 'concat' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONCAT_TOK
 *
 * Looks to match the characters the constitute the token CONCAT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCONCAT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CONCAT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:738:19: ( 'concat' )
    // ../../../../../../src/parser/smt1/Smt1.g:738:21: 'concat'
    {
        MATCHS(lit_34);
        if  (HASEXCEPTION())
        {
            goto ruleCONCAT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCONCAT_TOKEx; /* Prevent compiler warnings */
    ruleCONCAT_TOKEx: ;

}
// $ANTLR end CONCAT_TOK

//   Comes from: 739:19: ( 'extract' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTRACT_TOK
 *
 * Looks to match the characters the constitute the token EXTRACT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTRACT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTRACT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:739:19: ( 'extract' )
    // ../../../../../../src/parser/smt1/Smt1.g:739:21: 'extract'
    {
        MATCHS(lit_35);
        if  (HASEXCEPTION())
        {
            goto ruleEXTRACT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEXTRACT_TOKEx; /* Prevent compiler warnings */
    ruleEXTRACT_TOKEx: ;

}
// $ANTLR end EXTRACT_TOK

//   Comes from: 740:19: ( 'bvand' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVAND_TOK
 *
 * Looks to match the characters the constitute the token BVAND_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVAND_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVAND_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:740:19: ( 'bvand' )
    // ../../../../../../src/parser/smt1/Smt1.g:740:21: 'bvand'
    {
        MATCHS(lit_36);
        if  (HASEXCEPTION())
        {
            goto ruleBVAND_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVAND_TOKEx; /* Prevent compiler warnings */
    ruleBVAND_TOKEx: ;

}
// $ANTLR end BVAND_TOK

//   Comes from: 741:19: ( 'bvor' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVOR_TOK
 *
 * Looks to match the characters the constitute the token BVOR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVOR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVOR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:741:19: ( 'bvor' )
    // ../../../../../../src/parser/smt1/Smt1.g:741:21: 'bvor'
    {
        MATCHS(lit_37);
        if  (HASEXCEPTION())
        {
            goto ruleBVOR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVOR_TOKEx; /* Prevent compiler warnings */
    ruleBVOR_TOKEx: ;

}
// $ANTLR end BVOR_TOK

//   Comes from: 742:19: ( 'bvxor' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVXOR_TOK
 *
 * Looks to match the characters the constitute the token BVXOR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVXOR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVXOR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:742:19: ( 'bvxor' )
    // ../../../../../../src/parser/smt1/Smt1.g:742:21: 'bvxor'
    {
        MATCHS(lit_38);
        if  (HASEXCEPTION())
        {
            goto ruleBVXOR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVXOR_TOKEx; /* Prevent compiler warnings */
    ruleBVXOR_TOKEx: ;

}
// $ANTLR end BVXOR_TOK

//   Comes from: 743:19: ( 'bvnot' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVNOT_TOK
 *
 * Looks to match the characters the constitute the token BVNOT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVNOT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVNOT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:743:19: ( 'bvnot' )
    // ../../../../../../src/parser/smt1/Smt1.g:743:21: 'bvnot'
    {
        MATCHS(lit_39);
        if  (HASEXCEPTION())
        {
            goto ruleBVNOT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVNOT_TOKEx; /* Prevent compiler warnings */
    ruleBVNOT_TOKEx: ;

}
// $ANTLR end BVNOT_TOK

//   Comes from: 744:19: ( 'bvnand' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVNAND_TOK
 *
 * Looks to match the characters the constitute the token BVNAND_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVNAND_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVNAND_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:744:19: ( 'bvnand' )
    // ../../../../../../src/parser/smt1/Smt1.g:744:21: 'bvnand'
    {
        MATCHS(lit_40);
        if  (HASEXCEPTION())
        {
            goto ruleBVNAND_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVNAND_TOKEx; /* Prevent compiler warnings */
    ruleBVNAND_TOKEx: ;

}
// $ANTLR end BVNAND_TOK

//   Comes from: 745:19: ( 'bvnor' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVNOR_TOK
 *
 * Looks to match the characters the constitute the token BVNOR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVNOR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVNOR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:745:19: ( 'bvnor' )
    // ../../../../../../src/parser/smt1/Smt1.g:745:21: 'bvnor'
    {
        MATCHS(lit_41);
        if  (HASEXCEPTION())
        {
            goto ruleBVNOR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVNOR_TOKEx; /* Prevent compiler warnings */
    ruleBVNOR_TOKEx: ;

}
// $ANTLR end BVNOR_TOK

//   Comes from: 746:19: ( 'bvxnor' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVXNOR_TOK
 *
 * Looks to match the characters the constitute the token BVXNOR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVXNOR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVXNOR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:746:19: ( 'bvxnor' )
    // ../../../../../../src/parser/smt1/Smt1.g:746:21: 'bvxnor'
    {
        MATCHS(lit_42);
        if  (HASEXCEPTION())
        {
            goto ruleBVXNOR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVXNOR_TOKEx; /* Prevent compiler warnings */
    ruleBVXNOR_TOKEx: ;

}
// $ANTLR end BVXNOR_TOK

//   Comes from: 747:19: ( 'bvcomp' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVCOMP_TOK
 *
 * Looks to match the characters the constitute the token BVCOMP_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVCOMP_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVCOMP_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:747:19: ( 'bvcomp' )
    // ../../../../../../src/parser/smt1/Smt1.g:747:21: 'bvcomp'
    {
        MATCHS(lit_43);
        if  (HASEXCEPTION())
        {
            goto ruleBVCOMP_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVCOMP_TOKEx; /* Prevent compiler warnings */
    ruleBVCOMP_TOKEx: ;

}
// $ANTLR end BVCOMP_TOK

//   Comes from: 748:19: ( 'bvmul' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVMUL_TOK
 *
 * Looks to match the characters the constitute the token BVMUL_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVMUL_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVMUL_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:748:19: ( 'bvmul' )
    // ../../../../../../src/parser/smt1/Smt1.g:748:21: 'bvmul'
    {
        MATCHS(lit_44);
        if  (HASEXCEPTION())
        {
            goto ruleBVMUL_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVMUL_TOKEx; /* Prevent compiler warnings */
    ruleBVMUL_TOKEx: ;

}
// $ANTLR end BVMUL_TOK

//   Comes from: 749:19: ( 'bvadd' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVADD_TOK
 *
 * Looks to match the characters the constitute the token BVADD_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVADD_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVADD_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:749:19: ( 'bvadd' )
    // ../../../../../../src/parser/smt1/Smt1.g:749:21: 'bvadd'
    {
        MATCHS(lit_45);
        if  (HASEXCEPTION())
        {
            goto ruleBVADD_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVADD_TOKEx; /* Prevent compiler warnings */
    ruleBVADD_TOKEx: ;

}
// $ANTLR end BVADD_TOK

//   Comes from: 750:19: ( 'bvsub' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSUB_TOK
 *
 * Looks to match the characters the constitute the token BVSUB_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSUB_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSUB_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:750:19: ( 'bvsub' )
    // ../../../../../../src/parser/smt1/Smt1.g:750:21: 'bvsub'
    {
        MATCHS(lit_46);
        if  (HASEXCEPTION())
        {
            goto ruleBVSUB_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSUB_TOKEx; /* Prevent compiler warnings */
    ruleBVSUB_TOKEx: ;

}
// $ANTLR end BVSUB_TOK

//   Comes from: 751:19: ( 'bvneg' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVNEG_TOK
 *
 * Looks to match the characters the constitute the token BVNEG_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVNEG_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVNEG_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:751:19: ( 'bvneg' )
    // ../../../../../../src/parser/smt1/Smt1.g:751:21: 'bvneg'
    {
        MATCHS(lit_47);
        if  (HASEXCEPTION())
        {
            goto ruleBVNEG_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVNEG_TOKEx; /* Prevent compiler warnings */
    ruleBVNEG_TOKEx: ;

}
// $ANTLR end BVNEG_TOK

//   Comes from: 752:19: ( 'bvudiv' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVUDIV_TOK
 *
 * Looks to match the characters the constitute the token BVUDIV_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVUDIV_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVUDIV_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:752:19: ( 'bvudiv' )
    // ../../../../../../src/parser/smt1/Smt1.g:752:21: 'bvudiv'
    {
        MATCHS(lit_48);
        if  (HASEXCEPTION())
        {
            goto ruleBVUDIV_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVUDIV_TOKEx; /* Prevent compiler warnings */
    ruleBVUDIV_TOKEx: ;

}
// $ANTLR end BVUDIV_TOK

//   Comes from: 753:19: ( 'bvurem' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVUREM_TOK
 *
 * Looks to match the characters the constitute the token BVUREM_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVUREM_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVUREM_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:753:19: ( 'bvurem' )
    // ../../../../../../src/parser/smt1/Smt1.g:753:21: 'bvurem'
    {
        MATCHS(lit_49);
        if  (HASEXCEPTION())
        {
            goto ruleBVUREM_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVUREM_TOKEx; /* Prevent compiler warnings */
    ruleBVUREM_TOKEx: ;

}
// $ANTLR end BVUREM_TOK

//   Comes from: 754:19: ( 'bvsdiv' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSDIV_TOK
 *
 * Looks to match the characters the constitute the token BVSDIV_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSDIV_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSDIV_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:754:19: ( 'bvsdiv' )
    // ../../../../../../src/parser/smt1/Smt1.g:754:21: 'bvsdiv'
    {
        MATCHS(lit_50);
        if  (HASEXCEPTION())
        {
            goto ruleBVSDIV_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSDIV_TOKEx; /* Prevent compiler warnings */
    ruleBVSDIV_TOKEx: ;

}
// $ANTLR end BVSDIV_TOK

//   Comes from: 755:19: ( 'bvsrem' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSREM_TOK
 *
 * Looks to match the characters the constitute the token BVSREM_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSREM_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSREM_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:755:19: ( 'bvsrem' )
    // ../../../../../../src/parser/smt1/Smt1.g:755:21: 'bvsrem'
    {
        MATCHS(lit_51);
        if  (HASEXCEPTION())
        {
            goto ruleBVSREM_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSREM_TOKEx; /* Prevent compiler warnings */
    ruleBVSREM_TOKEx: ;

}
// $ANTLR end BVSREM_TOK

//   Comes from: 756:19: ( 'bvsmod' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSMOD_TOK
 *
 * Looks to match the characters the constitute the token BVSMOD_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSMOD_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSMOD_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:756:19: ( 'bvsmod' )
    // ../../../../../../src/parser/smt1/Smt1.g:756:21: 'bvsmod'
    {
        MATCHS(lit_52);
        if  (HASEXCEPTION())
        {
            goto ruleBVSMOD_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSMOD_TOKEx; /* Prevent compiler warnings */
    ruleBVSMOD_TOKEx: ;

}
// $ANTLR end BVSMOD_TOK

//   Comes from: 757:19: ( 'bvshl' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSHL_TOK
 *
 * Looks to match the characters the constitute the token BVSHL_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSHL_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSHL_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:757:19: ( 'bvshl' )
    // ../../../../../../src/parser/smt1/Smt1.g:757:21: 'bvshl'
    {
        MATCHS(lit_53);
        if  (HASEXCEPTION())
        {
            goto ruleBVSHL_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSHL_TOKEx; /* Prevent compiler warnings */
    ruleBVSHL_TOKEx: ;

}
// $ANTLR end BVSHL_TOK

//   Comes from: 758:19: ( 'bvlshr' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVLSHR_TOK
 *
 * Looks to match the characters the constitute the token BVLSHR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVLSHR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVLSHR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:758:19: ( 'bvlshr' )
    // ../../../../../../src/parser/smt1/Smt1.g:758:21: 'bvlshr'
    {
        MATCHS(lit_54);
        if  (HASEXCEPTION())
        {
            goto ruleBVLSHR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVLSHR_TOKEx; /* Prevent compiler warnings */
    ruleBVLSHR_TOKEx: ;

}
// $ANTLR end BVLSHR_TOK

//   Comes from: 759:19: ( 'bvashr' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVASHR_TOK
 *
 * Looks to match the characters the constitute the token BVASHR_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVASHR_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVASHR_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:759:19: ( 'bvashr' )
    // ../../../../../../src/parser/smt1/Smt1.g:759:21: 'bvashr'
    {
        MATCHS(lit_55);
        if  (HASEXCEPTION())
        {
            goto ruleBVASHR_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVASHR_TOKEx; /* Prevent compiler warnings */
    ruleBVASHR_TOKEx: ;

}
// $ANTLR end BVASHR_TOK

//   Comes from: 760:19: ( 'bvult' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVULT_TOK
 *
 * Looks to match the characters the constitute the token BVULT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVULT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVULT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:760:19: ( 'bvult' )
    // ../../../../../../src/parser/smt1/Smt1.g:760:21: 'bvult'
    {
        MATCHS(lit_56);
        if  (HASEXCEPTION())
        {
            goto ruleBVULT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVULT_TOKEx; /* Prevent compiler warnings */
    ruleBVULT_TOKEx: ;

}
// $ANTLR end BVULT_TOK

//   Comes from: 761:19: ( 'bvule' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVULE_TOK
 *
 * Looks to match the characters the constitute the token BVULE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVULE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVULE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:761:19: ( 'bvule' )
    // ../../../../../../src/parser/smt1/Smt1.g:761:21: 'bvule'
    {
        MATCHS(lit_57);
        if  (HASEXCEPTION())
        {
            goto ruleBVULE_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVULE_TOKEx; /* Prevent compiler warnings */
    ruleBVULE_TOKEx: ;

}
// $ANTLR end BVULE_TOK

//   Comes from: 762:19: ( 'bvugt' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVUGT_TOK
 *
 * Looks to match the characters the constitute the token BVUGT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVUGT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVUGT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:762:19: ( 'bvugt' )
    // ../../../../../../src/parser/smt1/Smt1.g:762:21: 'bvugt'
    {
        MATCHS(lit_58);
        if  (HASEXCEPTION())
        {
            goto ruleBVUGT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVUGT_TOKEx; /* Prevent compiler warnings */
    ruleBVUGT_TOKEx: ;

}
// $ANTLR end BVUGT_TOK

//   Comes from: 763:19: ( 'bvuge' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVUGE_TOK
 *
 * Looks to match the characters the constitute the token BVUGE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVUGE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVUGE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:763:19: ( 'bvuge' )
    // ../../../../../../src/parser/smt1/Smt1.g:763:21: 'bvuge'
    {
        MATCHS(lit_59);
        if  (HASEXCEPTION())
        {
            goto ruleBVUGE_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVUGE_TOKEx; /* Prevent compiler warnings */
    ruleBVUGE_TOKEx: ;

}
// $ANTLR end BVUGE_TOK

//   Comes from: 764:19: ( 'bvslt' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSLT_TOK
 *
 * Looks to match the characters the constitute the token BVSLT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSLT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSLT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:764:19: ( 'bvslt' )
    // ../../../../../../src/parser/smt1/Smt1.g:764:21: 'bvslt'
    {
        MATCHS(lit_60);
        if  (HASEXCEPTION())
        {
            goto ruleBVSLT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSLT_TOKEx; /* Prevent compiler warnings */
    ruleBVSLT_TOKEx: ;

}
// $ANTLR end BVSLT_TOK

//   Comes from: 765:19: ( 'bvsle' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSLE_TOK
 *
 * Looks to match the characters the constitute the token BVSLE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSLE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSLE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:765:19: ( 'bvsle' )
    // ../../../../../../src/parser/smt1/Smt1.g:765:21: 'bvsle'
    {
        MATCHS(lit_61);
        if  (HASEXCEPTION())
        {
            goto ruleBVSLE_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSLE_TOKEx; /* Prevent compiler warnings */
    ruleBVSLE_TOKEx: ;

}
// $ANTLR end BVSLE_TOK

//   Comes from: 766:19: ( 'bvsgt' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSGT_TOK
 *
 * Looks to match the characters the constitute the token BVSGT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSGT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSGT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:766:19: ( 'bvsgt' )
    // ../../../../../../src/parser/smt1/Smt1.g:766:21: 'bvsgt'
    {
        MATCHS(lit_62);
        if  (HASEXCEPTION())
        {
            goto ruleBVSGT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSGT_TOKEx; /* Prevent compiler warnings */
    ruleBVSGT_TOKEx: ;

}
// $ANTLR end BVSGT_TOK

//   Comes from: 767:19: ( 'bvsge' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BVSGE_TOK
 *
 * Looks to match the characters the constitute the token BVSGE_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBVSGE_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BVSGE_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:767:19: ( 'bvsge' )
    // ../../../../../../src/parser/smt1/Smt1.g:767:21: 'bvsge'
    {
        MATCHS(lit_63);
        if  (HASEXCEPTION())
        {
            goto ruleBVSGE_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBVSGE_TOKEx; /* Prevent compiler warnings */
    ruleBVSGE_TOKEx: ;

}
// $ANTLR end BVSGE_TOK

//   Comes from: 768:19: ( 'repeat' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REPEAT_TOK
 *
 * Looks to match the characters the constitute the token REPEAT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREPEAT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REPEAT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:768:19: ( 'repeat' )
    // ../../../../../../src/parser/smt1/Smt1.g:768:21: 'repeat'
    {
        MATCHS(lit_64);
        if  (HASEXCEPTION())
        {
            goto ruleREPEAT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleREPEAT_TOKEx; /* Prevent compiler warnings */
    ruleREPEAT_TOKEx: ;

}
// $ANTLR end REPEAT_TOK

//   Comes from: 769:19: ( 'zero_extend' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ZERO_EXTEND_TOK
 *
 * Looks to match the characters the constitute the token ZERO_EXTEND_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mZERO_EXTEND_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ZERO_EXTEND_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:769:19: ( 'zero_extend' )
    // ../../../../../../src/parser/smt1/Smt1.g:769:21: 'zero_extend'
    {
        MATCHS(lit_65);
        if  (HASEXCEPTION())
        {
            goto ruleZERO_EXTEND_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleZERO_EXTEND_TOKEx; /* Prevent compiler warnings */
    ruleZERO_EXTEND_TOKEx: ;

}
// $ANTLR end ZERO_EXTEND_TOK

//   Comes from: 770:19: ( 'sign_extend' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SIGN_EXTEND_TOK
 *
 * Looks to match the characters the constitute the token SIGN_EXTEND_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSIGN_EXTEND_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SIGN_EXTEND_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:770:19: ( 'sign_extend' )
    // ../../../../../../src/parser/smt1/Smt1.g:770:21: 'sign_extend'
    {
        MATCHS(lit_66);
        if  (HASEXCEPTION())
        {
            goto ruleSIGN_EXTEND_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSIGN_EXTEND_TOKEx; /* Prevent compiler warnings */
    ruleSIGN_EXTEND_TOKEx: ;

}
// $ANTLR end SIGN_EXTEND_TOK

//   Comes from: 771:19: ( 'rotate_left' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ROTATE_LEFT_TOK
 *
 * Looks to match the characters the constitute the token ROTATE_LEFT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mROTATE_LEFT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ROTATE_LEFT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:771:19: ( 'rotate_left' )
    // ../../../../../../src/parser/smt1/Smt1.g:771:21: 'rotate_left'
    {
        MATCHS(lit_67);
        if  (HASEXCEPTION())
        {
            goto ruleROTATE_LEFT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleROTATE_LEFT_TOKEx; /* Prevent compiler warnings */
    ruleROTATE_LEFT_TOKEx: ;

}
// $ANTLR end ROTATE_LEFT_TOK

//   Comes from: 772:19: ( 'rotate_right' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ROTATE_RIGHT_TOK
 *
 * Looks to match the characters the constitute the token ROTATE_RIGHT_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mROTATE_RIGHT_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ROTATE_RIGHT_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:772:19: ( 'rotate_right' )
    // ../../../../../../src/parser/smt1/Smt1.g:772:21: 'rotate_right'
    {
        MATCHS(lit_68);
        if  (HASEXCEPTION())
        {
            goto ruleROTATE_RIGHT_TOKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleROTATE_RIGHT_TOKEx; /* Prevent compiler warnings */
    ruleROTATE_RIGHT_TOKEx: ;

}
// $ANTLR end ROTATE_RIGHT_TOK

//   Comes from: 781:3: ( 'bv' ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITVECTOR_BV_CONST
 *
 * Looks to match the characters the constitute the token BITVECTOR_BV_CONST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITVECTOR_BV_CONST(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITVECTOR_BV_CONST;


    // ../../../../../../src/parser/smt1/Smt1.g:781:3: ( 'bv' ( DIGIT )+ )
    // ../../../../../../src/parser/smt1/Smt1.g:781:5: 'bv' ( DIGIT )+
    {
        MATCHS(lit_69);
        if  (HASEXCEPTION())
        {
            goto ruleBITVECTOR_BV_CONSTEx;
        }




        // ../../../../../../src/parser/smt1/Smt1.g:781:10: ( DIGIT )+
        {
            int cnt2=0;

            for (;;)
            {
                int alt2=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt2=1;
        		}
        	    break;

        	}

        	switch (alt2)
        	{
        	    case 1:
        	        // ../../../../../../src/parser/smt1/Smt1.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleBITVECTOR_BV_CONSTEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt2 >= 1 )
        		{
        		    goto loop2;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleBITVECTOR_BV_CONSTEx;
        	}
        	cnt2++;
            }
            loop2: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITVECTOR_BV_CONSTEx; /* Prevent compiler warnings */
    ruleBITVECTOR_BV_CONSTEx: ;

}
// $ANTLR end BITVECTOR_BV_CONST

//   Comes from: 788:3: ( 'bit0' | 'bit1' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITVECTOR1_BV_CONST
 *
 * Looks to match the characters the constitute the token BITVECTOR1_BV_CONST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITVECTOR1_BV_CONST(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITVECTOR1_BV_CONST;


    {
        //  ../../../../../../src/parser/smt1/Smt1.g:788:3: ( 'bit0' | 'bit1' )

        ANTLR3_UINT32 alt3;

        alt3=2;

        switch ( LA(1) )
        {
        case 'b':
        	{
        		switch ( LA(2) )
        		{
        		case 'i':
        			{
        				switch ( LA(3) )
        				{
        				case 't':
        					{
        						switch ( LA(4) )
        						{
        						case '0':
        							{
        								alt3=1;
        							}
        						    break;
        						case '1':
        							{
        								alt3=2;
        							}
        						    break;

        						default:
        						    CONSTRUCTEX();
        						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        						    EXCEPTION->message      = (void *)"";
        						    EXCEPTION->decisionNum  = 3;
        						    EXCEPTION->state        = 3;


        						    goto ruleBITVECTOR1_BV_CONSTEx;

        						}

        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 3;
        				    EXCEPTION->state        = 2;


        				    goto ruleBITVECTOR1_BV_CONSTEx;

        				}

        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 3;
        		    EXCEPTION->state        = 1;


        		    goto ruleBITVECTOR1_BV_CONSTEx;

        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 3;
            EXCEPTION->state        = 0;


            goto ruleBITVECTOR1_BV_CONSTEx;

        }

        switch (alt3)
        {
    	case 1:
    	    // ../../../../../../src/parser/smt1/Smt1.g:788:5: 'bit0'
    	    {
    	        MATCHS(lit_70);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleBITVECTOR1_BV_CONSTEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // ../../../../../../src/parser/smt1/Smt1.g:788:14: 'bit1'
    	    {
    	        MATCHS(lit_71);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleBITVECTOR1_BV_CONSTEx;
    	        }




    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITVECTOR1_BV_CONSTEx; /* Prevent compiler warnings */
    ruleBITVECTOR1_BV_CONSTEx: ;

}
// $ANTLR end BITVECTOR1_BV_CONST

//   Comes from: 798:3: ( ALPHA ( ALPHA | DIGIT | '_' | '\\'' | '.' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDENTIFIER
 *
 * Looks to match the characters the constitute the token IDENTIFIER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIDENTIFIER(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IDENTIFIER;


    // ../../../../../../src/parser/smt1/Smt1.g:798:3: ( ALPHA ( ALPHA | DIGIT | '_' | '\\'' | '.' )* )
    // ../../../../../../src/parser/smt1/Smt1.g:798:6: ALPHA ( ALPHA | DIGIT | '_' | '\\'' | '.' )*
    {
        /* 798:6: ALPHA ( ALPHA | DIGIT | '_' | '\\'' | '.' )* */
        mALPHA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleIDENTIFIEREx;
        }



        // ../../../../../../src/parser/smt1/Smt1.g:798:12: ( ALPHA | DIGIT | '_' | '\\'' | '.' )*

        for (;;)
        {
            int alt4=2;
            switch ( LA(1) )
            {
            case '\'':
            case '.':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt4=1;
            	}
                break;

            }

            switch (alt4)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt1/Smt1.g:
        	    {
        	        if ( LA(1) == '\'' || LA(1) == '.' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleIDENTIFIEREx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop4;	/* break out of the loop */
        	    break;
            }
        }
        loop4: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIDENTIFIEREx; /* Prevent compiler warnings */
    ruleIDENTIFIEREx: ;

}
// $ANTLR end IDENTIFIER

//   Comes from: 804:3: ( ':' IDENTIFIER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ATTR_IDENTIFIER
 *
 * Looks to match the characters the constitute the token ATTR_IDENTIFIER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mATTR_IDENTIFIER(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ATTR_IDENTIFIER;


    // ../../../../../../src/parser/smt1/Smt1.g:804:3: ( ':' IDENTIFIER )
    // ../../../../../../src/parser/smt1/Smt1.g:804:6: ':' IDENTIFIER
    {
        MATCHC(':');
        if  (HASEXCEPTION())
        {
            goto ruleATTR_IDENTIFIEREx;
        }


        /* 804:6: ':' IDENTIFIER */
        mIDENTIFIER(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleATTR_IDENTIFIEREx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleATTR_IDENTIFIEREx; /* Prevent compiler warnings */
    ruleATTR_IDENTIFIEREx: ;

}
// $ANTLR end ATTR_IDENTIFIER

//   Comes from: 811:3: ( '?' IDENTIFIER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LET_IDENTIFIER
 *
 * Looks to match the characters the constitute the token LET_IDENTIFIER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLET_IDENTIFIER(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LET_IDENTIFIER;


    // ../../../../../../src/parser/smt1/Smt1.g:811:3: ( '?' IDENTIFIER )
    // ../../../../../../src/parser/smt1/Smt1.g:811:5: '?' IDENTIFIER
    {
        MATCHC('?');
        if  (HASEXCEPTION())
        {
            goto ruleLET_IDENTIFIEREx;
        }


        /* 811:5: '?' IDENTIFIER */
        mIDENTIFIER(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleLET_IDENTIFIEREx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLET_IDENTIFIEREx; /* Prevent compiler warnings */
    ruleLET_IDENTIFIEREx: ;

}
// $ANTLR end LET_IDENTIFIER

//   Comes from: 818:3: ( '$' IDENTIFIER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLET_IDENTIFIER
 *
 * Looks to match the characters the constitute the token FLET_IDENTIFIER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLET_IDENTIFIER(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLET_IDENTIFIER;


    // ../../../../../../src/parser/smt1/Smt1.g:818:3: ( '$' IDENTIFIER )
    // ../../../../../../src/parser/smt1/Smt1.g:818:5: '$' IDENTIFIER
    {
        MATCHC('$');
        if  (HASEXCEPTION())
        {
            goto ruleFLET_IDENTIFIEREx;
        }


        /* 818:5: '$' IDENTIFIER */
        mIDENTIFIER(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleFLET_IDENTIFIEREx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFLET_IDENTIFIEREx; /* Prevent compiler warnings */
    ruleFLET_IDENTIFIEREx: ;

}
// $ANTLR end FLET_IDENTIFIER

//   Comes from: 837:3: ( ':pat' ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )* '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PATTERN_ANNOTATION_BEGIN
 *
 * Looks to match the characters the constitute the token PATTERN_ANNOTATION_BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPATTERN_ANNOTATION_BEGIN(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PATTERN_ANNOTATION_BEGIN;


    // ../../../../../../src/parser/smt1/Smt1.g:837:3: ( ':pat' ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )* '{' )
    // ../../../../../../src/parser/smt1/Smt1.g:837:5: ':pat' ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )* '{'
    {
        MATCHS(lit_1);
        if  (HASEXCEPTION())
        {
            goto rulePATTERN_ANNOTATION_BEGINEx;
        }




        // ../../../../../../src/parser/smt1/Smt1.g:837:12: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )*

        for (;;)
        {
            int alt5=2;
            switch ( LA(1) )
            {
            case '\t':
            case '\n':
            case '\f':
            case '\r':
            case ' ':
            	{
            		alt5=1;
            	}
                break;

            }

            switch (alt5)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt1/Smt1.g:
        	    {
        	        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto rulePATTERN_ANNOTATION_BEGINEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop5;	/* break out of the loop */
        	    break;
            }
        }
        loop5: ; /* Jump out to here if this rule does not match */


        MATCHC('{');
        if  (HASEXCEPTION())
        {
            goto rulePATTERN_ANNOTATION_BEGINEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePATTERN_ANNOTATION_BEGINEx; /* Prevent compiler warnings */
    rulePATTERN_ANNOTATION_BEGINEx: ;

}
// $ANTLR end PATTERN_ANNOTATION_BEGIN

//   Comes from: 841:3: ( '{' ( '\\\\{' | '\\\\}' |~ ( '{' | '}' ) )* '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start USER_VALUE
 *
 * Looks to match the characters the constitute the token USER_VALUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUSER_VALUE(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = USER_VALUE;


    // ../../../../../../src/parser/smt1/Smt1.g:841:3: ( '{' ( '\\\\{' | '\\\\}' |~ ( '{' | '}' ) )* '}' )
    // ../../../../../../src/parser/smt1/Smt1.g:841:5: '{' ( '\\\\{' | '\\\\}' |~ ( '{' | '}' ) )* '}'
    {
        MATCHC('{');
        if  (HASEXCEPTION())
        {
            goto ruleUSER_VALUEEx;
        }


        // ../../../../../../src/parser/smt1/Smt1.g:841:9: ( '\\\\{' | '\\\\}' |~ ( '{' | '}' ) )*

        for (;;)
        {
            int alt6=4;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA6_0 = LA(1);
                if ( (LA6_0 == '\\'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA6_2 = LA(2);
                        if ( (LA6_2 == '{'))
                        {
                            alt6=1;
                        }
                        else if ( (LA6_2 == '}'))
                        {
                            {
                               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                */
                                int LA6_5 = LA(3);
                                if ( (((LA6_5 >= 0x0000) && (LA6_5 <= 'z')) || ((LA6_5 >= '|') && (LA6_5 <= 0xFFFF))))
                                {
                                    alt6=2;
                                }

                                else
                                {
                            	alt6=3;
                                }

                            }
                        }
                        else if ( (((LA6_2 >= 0x0000) && (LA6_2 <= 'z')) || LA6_2 == '|' || ((LA6_2 >= '~') && (LA6_2 <= 0xFFFF))))
                        {
                            alt6=3;
                        }

                    }
                }
                else if ( (((LA6_0 >= 0x0000) && (LA6_0 <= '[')) || ((LA6_0 >= ']') && (LA6_0 <= 'z')) || LA6_0 == '|' || ((LA6_0 >= '~') && (LA6_0 <= 0xFFFF))))
                {
                    alt6=3;
                }

            }
            switch (alt6)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt1/Smt1.g:841:10: '\\\\{'
        	    {
        	        MATCHS(lit_72);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleUSER_VALUEEx;
        	        }




        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt1/Smt1.g:841:18: '\\\\}'
        	    {
        	        MATCHS(lit_73);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleUSER_VALUEEx;
        	        }




        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt1/Smt1.g:841:26: ~ ( '{' | '}' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= 'z')) || LA(1) == '|' || ((LA(1) >= '~') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleUSER_VALUEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop6;	/* break out of the loop */
        	    break;
            }
        }
        loop6: ; /* Jump out to here if this rule does not match */


        MATCHC('}');
        if  (HASEXCEPTION())
        {
            goto ruleUSER_VALUEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUSER_VALUEEx; /* Prevent compiler warnings */
    ruleUSER_VALUEEx: ;

}
// $ANTLR end USER_VALUE

//   Comes from: 851:3: ( ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITESPACE(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHITESPACE;


    // ../../../../../../src/parser/smt1/Smt1.g:851:3: ( ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+ )
    // ../../../../../../src/parser/smt1/Smt1.g:851:5: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+
    {
        // ../../../../../../src/parser/smt1/Smt1.g:851:5: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+
        {
            int cnt7=0;

            for (;;)
            {
                int alt7=2;
        	switch ( LA(1) )
        	{
        	case '\t':
        	case '\n':
        	case '\f':
        	case '\r':
        	case ' ':
        		{
        			alt7=1;
        		}
        	    break;

        	}

        	switch (alt7)
        	{
        	    case 1:
        	        // ../../../../../../src/parser/smt1/Smt1.g:
        	        {
        	            if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleWHITESPACEEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt7 >= 1 )
        		{
        		    goto loop7;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWHITESPACEEx;
        	}
        	cnt7++;
            }
            loop7: ;	/* Jump to here if this rule does not match */
        }

        {
             SKIP(); 
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

//   Comes from: 859:3: ( ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NUMERAL_TOK
 *
 * Looks to match the characters the constitute the token NUMERAL_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNUMERAL_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NUMERAL_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:859:3: ( ( DIGIT )+ )
    // ../../../../../../src/parser/smt1/Smt1.g:859:5: ( DIGIT )+
    {
        // ../../../../../../src/parser/smt1/Smt1.g:859:5: ( DIGIT )+
        {
            int cnt8=0;

            for (;;)
            {
                int alt8=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt8=1;
        		}
        	    break;

        	}

        	switch (alt8)
        	{
        	    case 1:
        	        // ../../../../../../src/parser/smt1/Smt1.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleNUMERAL_TOKEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt8 >= 1 )
        		{
        		    goto loop8;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleNUMERAL_TOKEx;
        	}
        	cnt8++;
            }
            loop8: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNUMERAL_TOKEx; /* Prevent compiler warnings */
    ruleNUMERAL_TOKEx: ;

}
// $ANTLR end NUMERAL_TOK

//   Comes from: 860:3: ( ( DIGIT )+ '.' ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RATIONAL_TOK
 *
 * Looks to match the characters the constitute the token RATIONAL_TOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRATIONAL_TOK(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RATIONAL_TOK;


    // ../../../../../../src/parser/smt1/Smt1.g:860:3: ( ( DIGIT )+ '.' ( DIGIT )+ )
    // ../../../../../../src/parser/smt1/Smt1.g:860:5: ( DIGIT )+ '.' ( DIGIT )+
    {
        // ../../../../../../src/parser/smt1/Smt1.g:860:5: ( DIGIT )+
        {
            int cnt9=0;

            for (;;)
            {
                int alt9=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt9=1;
        		}
        	    break;

        	}

        	switch (alt9)
        	{
        	    case 1:
        	        // ../../../../../../src/parser/smt1/Smt1.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleRATIONAL_TOKEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt9 >= 1 )
        		{
        		    goto loop9;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleRATIONAL_TOKEx;
        	}
        	cnt9++;
            }
            loop9: ;	/* Jump to here if this rule does not match */
        }

        MATCHC('.');
        if  (HASEXCEPTION())
        {
            goto ruleRATIONAL_TOKEx;
        }


        // ../../../../../../src/parser/smt1/Smt1.g:860:16: ( DIGIT )+
        {
            int cnt10=0;

            for (;;)
            {
                int alt10=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt10=1;
        		}
        	    break;

        	}

        	switch (alt10)
        	{
        	    case 1:
        	        // ../../../../../../src/parser/smt1/Smt1.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleRATIONAL_TOKEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt10 >= 1 )
        		{
        		    goto loop10;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleRATIONAL_TOKEx;
        	}
        	cnt10++;
            }
            loop10: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleRATIONAL_TOKEx; /* Prevent compiler warnings */
    ruleRATIONAL_TOKEx: ;

}
// $ANTLR end RATIONAL_TOK

//   Comes from: 872:3: ( '\"' ( ESCAPE |~ ( '\"' | '\\\\' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL
 *
 * Looks to match the characters the constitute the token STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL;


    // ../../../../../../src/parser/smt1/Smt1.g:872:3: ( '\"' ( ESCAPE |~ ( '\"' | '\\\\' ) )* '\"' )
    // ../../../../../../src/parser/smt1/Smt1.g:872:6: '\"' ( ESCAPE |~ ( '\"' | '\\\\' ) )* '\"'
    {
        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }


        // ../../../../../../src/parser/smt1/Smt1.g:872:10: ( ESCAPE |~ ( '\"' | '\\\\' ) )*

        for (;;)
        {
            int alt11=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA11_0 = LA(1);
                if ( (LA11_0 == '\\'))
                {
                    alt11=1;
                }
                else if ( (((LA11_0 >= 0x0000) && (LA11_0 <= '!')) || ((LA11_0 >= '#') && (LA11_0 <= '[')) || ((LA11_0 >= ']') && (LA11_0 <= 0xFFFF))))
                {
                    alt11=2;
                }

            }
            switch (alt11)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt1/Smt1.g:872:11: ESCAPE
        	    {
        	        /* 872:11: ESCAPE */
        	        mESCAPE(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRING_LITERALEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt1/Smt1.g:872:20: ~ ( '\"' | '\\\\' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleSTRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop11;	/* break out of the loop */
        	    break;
            }
        }
        loop11: ; /* Jump out to here if this rule does not match */


        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleSTRING_LITERALEx: ;

}
// $ANTLR end STRING_LITERAL

//   Comes from: 878:3: ( ';' (~ ( '\\n' | '\\r' ) )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMENT;


    // ../../../../../../src/parser/smt1/Smt1.g:878:3: ( ';' (~ ( '\\n' | '\\r' ) )* )
    // ../../../../../../src/parser/smt1/Smt1.g:878:5: ';' (~ ( '\\n' | '\\r' ) )*
    {
        MATCHC(';');
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }


        // ../../../../../../src/parser/smt1/Smt1.g:878:9: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt12=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA12_0 = LA(1);
                if ( (((LA12_0 >= 0x0000) && (LA12_0 <= '\t')) || ((LA12_0 >= 0x000B) && (LA12_0 <= '\f')) || ((LA12_0 >= 0x000E) && (LA12_0 <= 0xFFFF))))
                {
                    alt12=1;
                }

            }
            switch (alt12)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt1/Smt1.g:
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop12;	/* break out of the loop */
        	    break;
            }
        }
        loop12: ; /* Jump out to here if this rule does not match */


        {
             SKIP(); 
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 889:3: ( 'a' .. 'z' | 'A' .. 'Z' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALPHA
 *
 * Looks to match the characters the constitute the token ALPHA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALPHA(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // ../../../../../../src/parser/smt1/Smt1.g:889:3: ( 'a' .. 'z' | 'A' .. 'Z' )
    // ../../../../../../src/parser/smt1/Smt1.g:
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleALPHAEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleALPHAEx; /* Prevent compiler warnings */
    ruleALPHAEx: ;

}
// $ANTLR end ALPHA

//   Comes from: 895:16: ( '0' .. '9' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIGIT(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // ../../../../../../src/parser/smt1/Smt1.g:895:16: ( '0' .. '9' )
    // ../../../../../../src/parser/smt1/Smt1.g:
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDIGITEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

//   Comes from: 902:17: ( '\\\\' ( '\"' | '\\\\' | 'n' | 't' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESCAPE
 *
 * Looks to match the characters the constitute the token ESCAPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESCAPE(pSmt1Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // ../../../../../../src/parser/smt1/Smt1.g:902:17: ( '\\\\' ( '\"' | '\\\\' | 'n' | 't' | 'r' ) )
    // ../../../../../../src/parser/smt1/Smt1.g:902:19: '\\\\' ( '\"' | '\\\\' | 'n' | 't' | 'r' )
    {
        MATCHC('\\');
        if  (HASEXCEPTION())
        {
            goto ruleESCAPEEx;
        }


        if ( LA(1) == '"' || LA(1) == '\\' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleESCAPEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleESCAPEEx; /* Prevent compiler warnings */
    ruleESCAPEEx: ;

}
// $ANTLR end ESCAPE

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pSmt1Lexer ctx)
{
    {
        //  ../../../../../../src/parser/smt1/Smt1.g:1:8: ( T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | ASSUMPTION_TOK | BENCHMARK_TOK | EXTRAFUNS_TOK | EXTRAPREDS_TOK | EXTRASORTS_TOK | FALSE_TOK | FLET_TOK | FORMULA_TOK | ITE_TOK | LET_TOK | LOGIC_TOK | LPAREN_TOK | NOTES_TOK | RPAREN_TOK | SAT_TOK | STATUS_TOK | THEORY_TOK | TRUE_TOK | UNKNOWN_TOK | UNSAT_TOK | AMPERSAND_TOK | AND_TOK | AT_TOK | DISTINCT_TOK | DIV_TOK | EQUAL_TOK | EXISTS_TOK | FORALL_TOK | GREATER_THAN_TOK | IFF_TOK | IMPLIES_TOK | LESS_THAN_TOK | MINUS_TOK | NOT_TOK | OR_TOK | PERCENT_TOK | PIPE_TOK | PLUS_TOK | POUND_TOK | SELECT_TOK | STAR_TOK | STORE_TOK | TILDE_TOK | XOR_TOK | BITVECTOR_TOK | CONCAT_TOK | EXTRACT_TOK | BVAND_TOK | BVOR_TOK | BVXOR_TOK | BVNOT_TOK | BVNAND_TOK | BVNOR_TOK | BVXNOR_TOK | BVCOMP_TOK | BVMUL_TOK | BVADD_TOK | BVSUB_TOK | BVNEG_TOK | BVUDIV_TOK | BVUREM_TOK | BVSDIV_TOK | BVSREM_TOK | BVSMOD_TOK | BVSHL_TOK | BVLSHR_TOK | BVASHR_TOK | BVULT_TOK | BVULE_TOK | BVUGT_TOK | BVUGE_TOK | BVSLT_TOK | BVSLE_TOK | BVSGT_TOK | BVSGE_TOK | REPEAT_TOK | ZERO_EXTEND_TOK | SIGN_EXTEND_TOK | ROTATE_LEFT_TOK | ROTATE_RIGHT_TOK | BITVECTOR_BV_CONST | BITVECTOR1_BV_CONST | IDENTIFIER | ATTR_IDENTIFIER | LET_IDENTIFIER | FLET_IDENTIFIER | PATTERN_ANNOTATION_BEGIN | USER_VALUE | WHITESPACE | NUMERAL_TOK | RATIONAL_TOK | STRING_LITERAL | COMMENT )

        ANTLR3_UINT32 alt13;

        alt13=99;

        alt13 = cdfa13.predict(ctx, RECOGNIZER, ISTREAM, &cdfa13);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt13)
        {
    	case 1:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:10: T__100
    	    {
    	        /* 1:10: T__100 */
    	        mT__100(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:17: T__101
    	    {
    	        /* 1:17: T__101 */
    	        mT__101(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:24: T__102
    	    {
    	        /* 1:24: T__102 */
    	        mT__102(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:31: T__103
    	    {
    	        /* 1:31: T__103 */
    	        mT__103(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:38: T__104
    	    {
    	        /* 1:38: T__104 */
    	        mT__104(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:45: T__105
    	    {
    	        /* 1:45: T__105 */
    	        mT__105(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:52: ASSUMPTION_TOK
    	    {
    	        /* 1:52: ASSUMPTION_TOK */
    	        mASSUMPTION_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:67: BENCHMARK_TOK
    	    {
    	        /* 1:67: BENCHMARK_TOK */
    	        mBENCHMARK_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:81: EXTRAFUNS_TOK
    	    {
    	        /* 1:81: EXTRAFUNS_TOK */
    	        mEXTRAFUNS_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:95: EXTRAPREDS_TOK
    	    {
    	        /* 1:95: EXTRAPREDS_TOK */
    	        mEXTRAPREDS_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:110: EXTRASORTS_TOK
    	    {
    	        /* 1:110: EXTRASORTS_TOK */
    	        mEXTRASORTS_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:125: FALSE_TOK
    	    {
    	        /* 1:125: FALSE_TOK */
    	        mFALSE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:135: FLET_TOK
    	    {
    	        /* 1:135: FLET_TOK */
    	        mFLET_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:144: FORMULA_TOK
    	    {
    	        /* 1:144: FORMULA_TOK */
    	        mFORMULA_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:156: ITE_TOK
    	    {
    	        /* 1:156: ITE_TOK */
    	        mITE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:164: LET_TOK
    	    {
    	        /* 1:164: LET_TOK */
    	        mLET_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:172: LOGIC_TOK
    	    {
    	        /* 1:172: LOGIC_TOK */
    	        mLOGIC_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:182: LPAREN_TOK
    	    {
    	        /* 1:182: LPAREN_TOK */
    	        mLPAREN_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:193: NOTES_TOK
    	    {
    	        /* 1:193: NOTES_TOK */
    	        mNOTES_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:203: RPAREN_TOK
    	    {
    	        /* 1:203: RPAREN_TOK */
    	        mRPAREN_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:214: SAT_TOK
    	    {
    	        /* 1:214: SAT_TOK */
    	        mSAT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:222: STATUS_TOK
    	    {
    	        /* 1:222: STATUS_TOK */
    	        mSTATUS_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:233: THEORY_TOK
    	    {
    	        /* 1:233: THEORY_TOK */
    	        mTHEORY_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:244: TRUE_TOK
    	    {
    	        /* 1:244: TRUE_TOK */
    	        mTRUE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:253: UNKNOWN_TOK
    	    {
    	        /* 1:253: UNKNOWN_TOK */
    	        mUNKNOWN_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:265: UNSAT_TOK
    	    {
    	        /* 1:265: UNSAT_TOK */
    	        mUNSAT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:275: AMPERSAND_TOK
    	    {
    	        /* 1:275: AMPERSAND_TOK */
    	        mAMPERSAND_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:289: AND_TOK
    	    {
    	        /* 1:289: AND_TOK */
    	        mAND_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:297: AT_TOK
    	    {
    	        /* 1:297: AT_TOK */
    	        mAT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:304: DISTINCT_TOK
    	    {
    	        /* 1:304: DISTINCT_TOK */
    	        mDISTINCT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 31:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:317: DIV_TOK
    	    {
    	        /* 1:317: DIV_TOK */
    	        mDIV_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 32:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:325: EQUAL_TOK
    	    {
    	        /* 1:325: EQUAL_TOK */
    	        mEQUAL_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 33:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:335: EXISTS_TOK
    	    {
    	        /* 1:335: EXISTS_TOK */
    	        mEXISTS_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 34:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:346: FORALL_TOK
    	    {
    	        /* 1:346: FORALL_TOK */
    	        mFORALL_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 35:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:357: GREATER_THAN_TOK
    	    {
    	        /* 1:357: GREATER_THAN_TOK */
    	        mGREATER_THAN_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 36:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:374: IFF_TOK
    	    {
    	        /* 1:374: IFF_TOK */
    	        mIFF_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 37:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:382: IMPLIES_TOK
    	    {
    	        /* 1:382: IMPLIES_TOK */
    	        mIMPLIES_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 38:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:394: LESS_THAN_TOK
    	    {
    	        /* 1:394: LESS_THAN_TOK */
    	        mLESS_THAN_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 39:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:408: MINUS_TOK
    	    {
    	        /* 1:408: MINUS_TOK */
    	        mMINUS_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 40:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:418: NOT_TOK
    	    {
    	        /* 1:418: NOT_TOK */
    	        mNOT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 41:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:426: OR_TOK
    	    {
    	        /* 1:426: OR_TOK */
    	        mOR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 42:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:433: PERCENT_TOK
    	    {
    	        /* 1:433: PERCENT_TOK */
    	        mPERCENT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 43:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:445: PIPE_TOK
    	    {
    	        /* 1:445: PIPE_TOK */
    	        mPIPE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 44:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:454: PLUS_TOK
    	    {
    	        /* 1:454: PLUS_TOK */
    	        mPLUS_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 45:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:463: POUND_TOK
    	    {
    	        /* 1:463: POUND_TOK */
    	        mPOUND_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 46:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:473: SELECT_TOK
    	    {
    	        /* 1:473: SELECT_TOK */
    	        mSELECT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 47:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:484: STAR_TOK
    	    {
    	        /* 1:484: STAR_TOK */
    	        mSTAR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 48:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:493: STORE_TOK
    	    {
    	        /* 1:493: STORE_TOK */
    	        mSTORE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 49:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:503: TILDE_TOK
    	    {
    	        /* 1:503: TILDE_TOK */
    	        mTILDE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 50:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:513: XOR_TOK
    	    {
    	        /* 1:513: XOR_TOK */
    	        mXOR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 51:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:521: BITVECTOR_TOK
    	    {
    	        /* 1:521: BITVECTOR_TOK */
    	        mBITVECTOR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 52:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:535: CONCAT_TOK
    	    {
    	        /* 1:535: CONCAT_TOK */
    	        mCONCAT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 53:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:546: EXTRACT_TOK
    	    {
    	        /* 1:546: EXTRACT_TOK */
    	        mEXTRACT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 54:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:558: BVAND_TOK
    	    {
    	        /* 1:558: BVAND_TOK */
    	        mBVAND_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 55:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:568: BVOR_TOK
    	    {
    	        /* 1:568: BVOR_TOK */
    	        mBVOR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 56:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:577: BVXOR_TOK
    	    {
    	        /* 1:577: BVXOR_TOK */
    	        mBVXOR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 57:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:587: BVNOT_TOK
    	    {
    	        /* 1:587: BVNOT_TOK */
    	        mBVNOT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 58:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:597: BVNAND_TOK
    	    {
    	        /* 1:597: BVNAND_TOK */
    	        mBVNAND_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 59:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:608: BVNOR_TOK
    	    {
    	        /* 1:608: BVNOR_TOK */
    	        mBVNOR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 60:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:618: BVXNOR_TOK
    	    {
    	        /* 1:618: BVXNOR_TOK */
    	        mBVXNOR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 61:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:629: BVCOMP_TOK
    	    {
    	        /* 1:629: BVCOMP_TOK */
    	        mBVCOMP_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 62:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:640: BVMUL_TOK
    	    {
    	        /* 1:640: BVMUL_TOK */
    	        mBVMUL_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 63:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:650: BVADD_TOK
    	    {
    	        /* 1:650: BVADD_TOK */
    	        mBVADD_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 64:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:660: BVSUB_TOK
    	    {
    	        /* 1:660: BVSUB_TOK */
    	        mBVSUB_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 65:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:670: BVNEG_TOK
    	    {
    	        /* 1:670: BVNEG_TOK */
    	        mBVNEG_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 66:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:680: BVUDIV_TOK
    	    {
    	        /* 1:680: BVUDIV_TOK */
    	        mBVUDIV_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 67:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:691: BVUREM_TOK
    	    {
    	        /* 1:691: BVUREM_TOK */
    	        mBVUREM_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 68:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:702: BVSDIV_TOK
    	    {
    	        /* 1:702: BVSDIV_TOK */
    	        mBVSDIV_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 69:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:713: BVSREM_TOK
    	    {
    	        /* 1:713: BVSREM_TOK */
    	        mBVSREM_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 70:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:724: BVSMOD_TOK
    	    {
    	        /* 1:724: BVSMOD_TOK */
    	        mBVSMOD_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 71:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:735: BVSHL_TOK
    	    {
    	        /* 1:735: BVSHL_TOK */
    	        mBVSHL_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 72:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:745: BVLSHR_TOK
    	    {
    	        /* 1:745: BVLSHR_TOK */
    	        mBVLSHR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 73:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:756: BVASHR_TOK
    	    {
    	        /* 1:756: BVASHR_TOK */
    	        mBVASHR_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 74:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:767: BVULT_TOK
    	    {
    	        /* 1:767: BVULT_TOK */
    	        mBVULT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 75:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:777: BVULE_TOK
    	    {
    	        /* 1:777: BVULE_TOK */
    	        mBVULE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 76:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:787: BVUGT_TOK
    	    {
    	        /* 1:787: BVUGT_TOK */
    	        mBVUGT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 77:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:797: BVUGE_TOK
    	    {
    	        /* 1:797: BVUGE_TOK */
    	        mBVUGE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 78:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:807: BVSLT_TOK
    	    {
    	        /* 1:807: BVSLT_TOK */
    	        mBVSLT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 79:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:817: BVSLE_TOK
    	    {
    	        /* 1:817: BVSLE_TOK */
    	        mBVSLE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 80:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:827: BVSGT_TOK
    	    {
    	        /* 1:827: BVSGT_TOK */
    	        mBVSGT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 81:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:837: BVSGE_TOK
    	    {
    	        /* 1:837: BVSGE_TOK */
    	        mBVSGE_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 82:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:847: REPEAT_TOK
    	    {
    	        /* 1:847: REPEAT_TOK */
    	        mREPEAT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 83:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:858: ZERO_EXTEND_TOK
    	    {
    	        /* 1:858: ZERO_EXTEND_TOK */
    	        mZERO_EXTEND_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 84:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:874: SIGN_EXTEND_TOK
    	    {
    	        /* 1:874: SIGN_EXTEND_TOK */
    	        mSIGN_EXTEND_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 85:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:890: ROTATE_LEFT_TOK
    	    {
    	        /* 1:890: ROTATE_LEFT_TOK */
    	        mROTATE_LEFT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 86:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:906: ROTATE_RIGHT_TOK
    	    {
    	        /* 1:906: ROTATE_RIGHT_TOK */
    	        mROTATE_RIGHT_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 87:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:923: BITVECTOR_BV_CONST
    	    {
    	        /* 1:923: BITVECTOR_BV_CONST */
    	        mBITVECTOR_BV_CONST(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 88:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:942: BITVECTOR1_BV_CONST
    	    {
    	        /* 1:942: BITVECTOR1_BV_CONST */
    	        mBITVECTOR1_BV_CONST(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 89:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:962: IDENTIFIER
    	    {
    	        /* 1:962: IDENTIFIER */
    	        mIDENTIFIER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 90:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:973: ATTR_IDENTIFIER
    	    {
    	        /* 1:973: ATTR_IDENTIFIER */
    	        mATTR_IDENTIFIER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 91:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:989: LET_IDENTIFIER
    	    {
    	        /* 1:989: LET_IDENTIFIER */
    	        mLET_IDENTIFIER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 92:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1004: FLET_IDENTIFIER
    	    {
    	        /* 1:1004: FLET_IDENTIFIER */
    	        mFLET_IDENTIFIER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 93:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1020: PATTERN_ANNOTATION_BEGIN
    	    {
    	        /* 1:1020: PATTERN_ANNOTATION_BEGIN */
    	        mPATTERN_ANNOTATION_BEGIN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 94:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1045: USER_VALUE
    	    {
    	        /* 1:1045: USER_VALUE */
    	        mUSER_VALUE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 95:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1056: WHITESPACE
    	    {
    	        /* 1:1056: WHITESPACE */
    	        mWHITESPACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 96:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1067: NUMERAL_TOK
    	    {
    	        /* 1:1067: NUMERAL_TOK */
    	        mNUMERAL_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 97:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1079: RATIONAL_TOK
    	    {
    	        /* 1:1079: RATIONAL_TOK */
    	        mRATIONAL_TOK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 98:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1092: STRING_LITERAL
    	    {
    	        /* 1:1092: STRING_LITERAL */
    	        mSTRING_LITERAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 99:
    	    // ../../../../../../src/parser/smt1/Smt1.g:1:1107: COMMENT
    	    {
    	        /* 1:1107: COMMENT */
    	        mCOMMENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
