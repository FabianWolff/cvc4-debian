/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ../../../../../../src/parser/smt2/Smt2.g
 *     -                            On : 2017-03-16 01:03:01
 *     -                for the parser : Smt2ParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 ** This file is part of CVC4.
 ** Copyright (c) 2009-2014  New York University and The University of Iowa
 ** See the file COPYING in the top-level source directory for licensing
 ** information.
 **/

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "Smt2Parser.h"


#include <set>
#include <sstream>
#include <string>
#include <vector>

#include "base/output.h"
#include "expr/expr.h"
#include "expr/kind.h"
#include "expr/type.h"
#include "options/set_language.h"
#include "parser/antlr_input.h"
#include "parser/parser.h"
#include "parser/smt2/smt2.h"
#include "util/floatingpoint.h"
#include "util/hash.h"
#include "util/integer.h"
#include "util/rational.h"
// \todo Review the need for this header
#include "math.h"

using namespace CVC4;
using namespace CVC4::parser;

/* These need to be macros so they can refer to the PARSER macro, which
 * will be defined by ANTLR *after* this section. (If they were functions,
 * PARSER would be undefined.) */
#undef PARSER_STATE
#define PARSER_STATE ((Smt2*)PARSER->super)
#undef EXPR_MANAGER
#define EXPR_MANAGER PARSER_STATE->getExprManager()
#undef MK_EXPR
#define MK_EXPR EXPR_MANAGER->mkExpr
#undef MK_CONST
#define MK_CONST EXPR_MANAGER->mkConst
#define UNSUPPORTED PARSER_STATE->unimplementedFeature

static bool isClosed(const Expr& e, std::set<Expr>& free, std::hash_set<Expr, ExprHashFunction>& closedCache) {
  if(closedCache.find(e) != closedCache.end()) {
    return true;
  }

  if(e.getKind() == kind::FORALL || e.getKind() == kind::EXISTS || e.getKind() == kind::LAMBDA) {
    isClosed(e[1], free, closedCache);
    for(Expr::const_iterator i = e[0].begin(); i != e[0].end(); ++i) {
      free.erase(*i);
    }
  } else if(e.getKind() == kind::BOUND_VARIABLE) {
    free.insert(e);
    return false;
  } else {
    if(e.hasOperator()) {
      isClosed(e.getOperator(), free, closedCache);
    }
    for(Expr::const_iterator i = e.begin(); i != e.end(); ++i) {
      isClosed(*i, free, closedCache);
    }
  }

  if(free.empty()) {
    closedCache.insert(e);
    return true;
  } else {
    return false;
  }
}

static inline bool isClosed(const Expr& e, std::set<Expr>& free) {
  std::hash_set<Expr, ExprHashFunction> cache;
  return isClosed(e, free, cache);
}  
  

/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSmt2Parser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSmt2Parser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSmt2Parser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSmt2Parser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   Smt2ParserTokenNames[148+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALPHA",
        (pANTLR3_UINT8) "AMPERSAND_TOK",
        (pANTLR3_UINT8) "AND_TOK",
        (pANTLR3_UINT8) "ASSERT_TOK",
        (pANTLR3_UINT8) "AS_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_INST_LEVEL",
        (pANTLR3_UINT8) "ATTRIBUTE_NAMED_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_NO_PATTERN_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_PATTERN_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_RR_PRIORITY",
        (pANTLR3_UINT8) "ATTRIBUTE_TOK",
        (pANTLR3_UINT8) "AT_TOK",
        (pANTLR3_UINT8) "BINARY_LITERAL",
        (pANTLR3_UINT8) "BV2NAT_TOK",
        (pANTLR3_UINT8) "CHECKSAT_TOK",
        (pANTLR3_UINT8) "CHECK_SYNTH_TOK",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONSTRAINT_TOK",
        (pANTLR3_UINT8) "CONST_TOK",
        (pANTLR3_UINT8) "DECIMAL_LITERAL",
        (pANTLR3_UINT8) "DECLARE_CODATATYPES_TOK",
        (pANTLR3_UINT8) "DECLARE_CONST_TOK",
        (pANTLR3_UINT8) "DECLARE_DATATYPES_TOK",
        (pANTLR3_UINT8) "DECLARE_FUNS_TOK",
        (pANTLR3_UINT8) "DECLARE_FUN_TOK",
        (pANTLR3_UINT8) "DECLARE_PREDS_TOK",
        (pANTLR3_UINT8) "DECLARE_PRIMED_VAR_TOK",
        (pANTLR3_UINT8) "DECLARE_SORTS_TOK",
        (pANTLR3_UINT8) "DECLARE_SORT_TOK",
        (pANTLR3_UINT8) "DECLARE_VAR_TOK",
        (pANTLR3_UINT8) "DEFINE_CONST_TOK",
        (pANTLR3_UINT8) "DEFINE_FUNS_REC_TOK",
        (pANTLR3_UINT8) "DEFINE_FUN_REC_TOK",
        (pANTLR3_UINT8) "DEFINE_FUN_TOK",
        (pANTLR3_UINT8) "DEFINE_SORT_TOK",
        (pANTLR3_UINT8) "DEFINE_TOK",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DISTINCT_TOK",
        (pANTLR3_UINT8) "DIVISIBLE_TOK",
        (pANTLR3_UINT8) "DIV_TOK",
        (pANTLR3_UINT8) "DTSIZE_TOK",
        (pANTLR3_UINT8) "ECHO_TOK",
        (pANTLR3_UINT8) "EMPTYSET_TOK",
        (pANTLR3_UINT8) "EQUAL_TOK",
        (pANTLR3_UINT8) "EXISTS_TOK",
        (pANTLR3_UINT8) "EXIT_TOK",
        (pANTLR3_UINT8) "FMFCARDVAL_TOK",
        (pANTLR3_UINT8) "FMFCARD_TOK",
        (pANTLR3_UINT8) "FORALL_TOK",
        (pANTLR3_UINT8) "FP_NAN_TOK",
        (pANTLR3_UINT8) "FP_NINF_TOK",
        (pANTLR3_UINT8) "FP_NZERO_TOK",
        (pANTLR3_UINT8) "FP_PINF_TOK",
        (pANTLR3_UINT8) "FP_PZERO_TOK",
        (pANTLR3_UINT8) "FP_RNA_FULL_TOK",
        (pANTLR3_UINT8) "FP_RNA_TOK",
        (pANTLR3_UINT8) "FP_RNE_FULL_TOK",
        (pANTLR3_UINT8) "FP_RNE_TOK",
        (pANTLR3_UINT8) "FP_RTN_FULL_TOK",
        (pANTLR3_UINT8) "FP_RTN_TOK",
        (pANTLR3_UINT8) "FP_RTP_FULL_TOK",
        (pANTLR3_UINT8) "FP_RTP_TOK",
        (pANTLR3_UINT8) "FP_RTZ_FULL_TOK",
        (pANTLR3_UINT8) "FP_RTZ_TOK",
        (pANTLR3_UINT8) "FP_TO_FPBV_TOK",
        (pANTLR3_UINT8) "FP_TO_FPFP_TOK",
        (pANTLR3_UINT8) "FP_TO_FPR_TOK",
        (pANTLR3_UINT8) "FP_TO_FPS_TOK",
        (pANTLR3_UINT8) "FP_TO_FPU_TOK",
        (pANTLR3_UINT8) "FP_TO_FP_TOK",
        (pANTLR3_UINT8) "FP_TO_SBV_TOK",
        (pANTLR3_UINT8) "FP_TO_UBV_TOK",
        (pANTLR3_UINT8) "GET_ASSERTIONS_TOK",
        (pANTLR3_UINT8) "GET_ASSIGNMENT_TOK",
        (pANTLR3_UINT8) "GET_INFO_TOK",
        (pANTLR3_UINT8) "GET_MODEL_TOK",
        (pANTLR3_UINT8) "GET_OPTION_TOK",
        (pANTLR3_UINT8) "GET_PROOF_TOK",
        (pANTLR3_UINT8) "GET_QE_DISJUNCT_TOK",
        (pANTLR3_UINT8) "GET_QE_TOK",
        (pANTLR3_UINT8) "GET_UNSAT_CORE_TOK",
        (pANTLR3_UINT8) "GET_VALUE_TOK",
        (pANTLR3_UINT8) "GREATER_THAN_EQUAL_TOK",
        (pANTLR3_UINT8) "GREATER_THAN_TOK",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "HEX_LITERAL",
        (pANTLR3_UINT8) "IMPLIES_TOK",
        (pANTLR3_UINT8) "INCLUDE_TOK",
        (pANTLR3_UINT8) "INDEX_TOK",
        (pANTLR3_UINT8) "INST_CLOSURE_TOK",
        (pANTLR3_UINT8) "INT2BV_TOK",
        (pANTLR3_UINT8) "INTEGER_LITERAL",
        (pANTLR3_UINT8) "INV_CONSTRAINT_TOK",
        (pANTLR3_UINT8) "ITE_TOK",
        (pANTLR3_UINT8) "KEYWORD",
        (pANTLR3_UINT8) "LESS_THAN_EQUAL_TOK",
        (pANTLR3_UINT8) "LESS_THAN_TOK",
        (pANTLR3_UINT8) "LET_TOK",
        (pANTLR3_UINT8) "LPAREN_TOK",
        (pANTLR3_UINT8) "META_INFO_TOK",
        (pANTLR3_UINT8) "MINUS_TOK",
        (pANTLR3_UINT8) "NILREF_TOK",
        (pANTLR3_UINT8) "NOT_TOK",
        (pANTLR3_UINT8) "NUMERAL",
        (pANTLR3_UINT8) "OR_TOK",
        (pANTLR3_UINT8) "PLUS_TOK",
        (pANTLR3_UINT8) "POP_TOK",
        (pANTLR3_UINT8) "PROPAGATION_RULE_TOK",
        (pANTLR3_UINT8) "PUSH_TOK",
        (pANTLR3_UINT8) "QUOTED_SYMBOL",
        (pANTLR3_UINT8) "REALLCHAR_TOK",
        (pANTLR3_UINT8) "REDUCTION_RULE_TOK",
        (pANTLR3_UINT8) "RENOSTR_TOK",
        (pANTLR3_UINT8) "RESET_ASSERTIONS_TOK",
        (pANTLR3_UINT8) "RESET_TOK",
        (pANTLR3_UINT8) "REWRITE_RULE_TOK",
        (pANTLR3_UINT8) "RPAREN_TOK",
        (pANTLR3_UINT8) "SET_INFO_TOK",
        (pANTLR3_UINT8) "SET_LOGIC_TOK",
        (pANTLR3_UINT8) "SET_OPTIONS_TOK",
        (pANTLR3_UINT8) "SET_OPTION_TOK",
        (pANTLR3_UINT8) "SIMPLE_SYMBOL",
        (pANTLR3_UINT8) "SIMPLIFY_TOK",
        (pANTLR3_UINT8) "STAR_TOK",
        (pANTLR3_UINT8) "STRING_LITERAL_2_0",
        (pANTLR3_UINT8) "STRING_LITERAL_2_5",
        (pANTLR3_UINT8) "SYGUS_CONSTANT_TOK",
        (pANTLR3_UINT8) "SYGUS_ENUM_CONS_TOK",
        (pANTLR3_UINT8) "SYGUS_ENUM_TOK",
        (pANTLR3_UINT8) "SYGUS_INPUT_VARIABLE_TOK",
        (pANTLR3_UINT8) "SYGUS_LOCAL_VARIABLE_TOK",
        (pANTLR3_UINT8) "SYGUS_QUOTED_LITERAL",
        (pANTLR3_UINT8) "SYGUS_VARIABLE_TOK",
        (pANTLR3_UINT8) "SYMBOL_CHAR",
        (pANTLR3_UINT8) "SYMBOL_CHAR_NOUNDERSCORE_NOATTRIBUTE",
        (pANTLR3_UINT8) "SYNTH_FUN_TOK",
        (pANTLR3_UINT8) "SYNTH_INV_TOK",
        (pANTLR3_UINT8) "UNIVSET_TOK",
        (pANTLR3_UINT8) "UNTERMINATED_QUOTED_SYMBOL",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "XOR_TOK",
        (pANTLR3_UINT8) "'\\\\'",
        (pANTLR3_UINT8) "'extract'",
        (pANTLR3_UINT8) "'repeat'",
        (pANTLR3_UINT8) "'rotate_left'",
        (pANTLR3_UINT8) "'rotate_right'",
        (pANTLR3_UINT8) "'sign_extend'",
        (pANTLR3_UINT8) "'zero_extend'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 CVC4::parser::smt2::myExpr
	parseExpr    (pSmt2Parser ctx);
static 
 CVC4::Command*
	parseCommand    (pSmt2Parser ctx);
static 
 CVC4::Command*
	parseSygus    (pSmt2Parser ctx);
static 
 void
	command    (pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	sygusCommand    (pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	sygusGTerm    (pSmt2Parser ctx, CVC4::SygusGTerm& sgt, std::string& fun);
static 
 void
	metaInfoInternal    (pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	setOptionInternal    (pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	smt25Command    (pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	extendedCommand    (pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	datatypesDefCommand    (pSmt2Parser ctx, bool isCo, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	rewriterulesCommand    (pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	rewritePropaKind    (pSmt2Parser ctx, CVC4::Kind& kind);
static 
 void
	pattern    (pSmt2Parser ctx, CVC4::Expr& expr);
static 
 void
	simpleSymbolicExprNoKeyword    (pSmt2Parser ctx, CVC4::SExpr& sexpr);
static 
 void
	keyword    (pSmt2Parser ctx, std::string& s);
static 
 void
	simpleSymbolicExpr    (pSmt2Parser ctx, CVC4::SExpr& sexpr);
static 
 void
	symbolicExpr    (pSmt2Parser ctx, CVC4::SExpr& sexpr);
static 
 void
	term    (pSmt2Parser ctx, CVC4::Expr& expr, CVC4::Expr& expr2);
static 
 void
	attribute    (pSmt2Parser ctx, CVC4::Expr& expr, CVC4::Expr& retExpr, std::string& attr);
static 
 void
	indexedFunctionName    (pSmt2Parser ctx, CVC4::Expr& op);
static 
 void
	badIndexedFunctionName    (pSmt2Parser ctx);
static 
 void
	termList    (pSmt2Parser ctx, std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr);
static 
 void
	str    (pSmt2Parser ctx, std::string& s, bool fsmtlib);
static 
 void
	builtinOp    (pSmt2Parser ctx, CVC4::Kind& kind);
static 
 void
	quantOp    (pSmt2Parser ctx, CVC4::Kind& kind);
static 
 void
	functionName    (pSmt2Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 void
	sortList    (pSmt2Parser ctx, std::vector<CVC4::Type>& sorts);
static 
 void
	nonemptySortList    (pSmt2Parser ctx, std::vector<CVC4::Type>& sorts);
static 
 void
	sortedVarList    (pSmt2Parser ctx, std::vector<std::pair<std::string, CVC4::Type> >& sortedVars);
static 
 void
	sortName    (pSmt2Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 void
	sortSymbol    (pSmt2Parser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check);
static 
 void
	symbolList    (pSmt2Parser ctx, std::vector<std::string>& names, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type);
static 
 void
	symbol    (pSmt2Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type);
static 
 void
	nonemptyNumeralList    (pSmt2Parser ctx, std::vector<uint64_t>& numerals);
static 
 void
	datatypeDef    (pSmt2Parser ctx, bool isCo, std::vector<CVC4::Datatype>& datatypes, std::vector< CVC4::Type >& params);
static 
 void
	constructorDef    (pSmt2Parser ctx, CVC4::Datatype& type);
static 
 void
	selector    (pSmt2Parser ctx, CVC4::DatatypeConstructor& ctor);
static void	Smt2ParserFree(pSmt2Parser ctx);
static void     Smt2ParserReset (pSmt2Parser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "../../../../../../src/parser/smt2/Smt2.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new Smt2Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt2Parser
Smt2ParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return Smt2ParserNewSSD(instream, NULL);
}

/** \brief Create a new Smt2Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt2Parser
Smt2ParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSmt2Parser ctx;	    /* Context structure we will build and return   */

    ctx	= (pSmt2Parser) ANTLR3_CALLOC(1, sizeof(Smt2Parser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in Smt2Parser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our Smt2Parser interface
     */
    ctx->parseExpr	= parseExpr;
    ctx->parseCommand	= parseCommand;
    ctx->parseSygus	= parseSygus;
    ctx->command	= command;
    ctx->sygusCommand	= sygusCommand;
    ctx->sygusGTerm	= sygusGTerm;
    ctx->metaInfoInternal	= metaInfoInternal;
    ctx->setOptionInternal	= setOptionInternal;
    ctx->smt25Command	= smt25Command;
    ctx->extendedCommand	= extendedCommand;
    ctx->datatypesDefCommand	= datatypesDefCommand;
    ctx->rewriterulesCommand	= rewriterulesCommand;
    ctx->rewritePropaKind	= rewritePropaKind;
    ctx->pattern	= pattern;
    ctx->simpleSymbolicExprNoKeyword	= simpleSymbolicExprNoKeyword;
    ctx->keyword	= keyword;
    ctx->simpleSymbolicExpr	= simpleSymbolicExpr;
    ctx->symbolicExpr	= symbolicExpr;
    ctx->term	= term;
    ctx->attribute	= attribute;
    ctx->indexedFunctionName	= indexedFunctionName;
    ctx->badIndexedFunctionName	= badIndexedFunctionName;
    ctx->termList	= termList;
    ctx->str	= str;
    ctx->builtinOp	= builtinOp;
    ctx->quantOp	= quantOp;
    ctx->functionName	= functionName;
    ctx->sortList	= sortList;
    ctx->nonemptySortList	= nonemptySortList;
    ctx->sortedVarList	= sortedVarList;
    ctx->sortName	= sortName;
    ctx->sortSymbol	= sortSymbol;
    ctx->symbolList	= symbolList;
    ctx->symbol	= symbol;
    ctx->nonemptyNumeralList	= nonemptyNumeralList;
    ctx->datatypeDef	= datatypeDef;
    ctx->constructorDef	= constructorDef;
    ctx->selector	= selector;
    ctx->free			= Smt2ParserFree;
    ctx->reset			= Smt2ParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = Smt2ParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
Smt2ParserReset (pSmt2Parser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 Smt2ParserFree(pSmt2Parser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return Smt2ParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_parseExpr119  */
static	ANTLR3_BITWORD FOLLOW_term_in_parseExpr119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_parseExpr119	= { FOLLOW_term_in_parseExpr119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseExpr126  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseExpr126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseExpr126	= { FOLLOW_EOF_in_parseExpr126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand155  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand155_bits[]	= { ANTLR3_UINT64_LIT(0x000220FDBF040080), ANTLR3_UINT64_LIT(0x76E9C080003FF000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand155	= { FOLLOW_LPAREN_TOK_in_parseCommand155_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_parseCommand157  */
static	ANTLR3_BITWORD FOLLOW_command_in_parseCommand157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_parseCommand157	= { FOLLOW_command_in_parseCommand157_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand160  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand160	= { FOLLOW_RPAREN_TOK_in_parseCommand160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand173  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand173	= { FOLLOW_LPAREN_TOK_in_parseCommand173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_TOK_in_parseCommand175  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_TOK_in_parseCommand175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_TOK_in_parseCommand175	= { FOLLOW_INCLUDE_TOK_in_parseCommand175_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_parseCommand177  */
static	ANTLR3_BITWORD FOLLOW_str_in_parseCommand177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_parseCommand177	= { FOLLOW_str_in_parseCommand177_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand180  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand180	= { FOLLOW_RPAREN_TOK_in_parseCommand180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseCommand193  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseCommand193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseCommand193	= { FOLLOW_EOF_in_parseCommand193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseSygus222  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseSygus222_bits[]	= { ANTLR3_UINT64_LIT(0x000220FFFF2C0080), ANTLR3_UINT64_LIT(0x76E9C081003FF000), ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseSygus222	= { FOLLOW_LPAREN_TOK_in_parseSygus222_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusCommand_in_parseSygus224  */
static	ANTLR3_BITWORD FOLLOW_sygusCommand_in_parseSygus224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusCommand_in_parseSygus224	= { FOLLOW_sygusCommand_in_parseSygus224_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseSygus227  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseSygus227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseSygus227	= { FOLLOW_RPAREN_TOK_in_parseSygus227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseSygus233  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseSygus233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseSygus233	= { FOLLOW_EOF_in_parseSygus233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_LOGIC_TOK_in_command261  */
static	ANTLR3_BITWORD FOLLOW_SET_LOGIC_TOK_in_command261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_LOGIC_TOK_in_command261	= { FOLLOW_SET_LOGIC_TOK_in_command261_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command263  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command263	= { FOLLOW_symbol_in_command263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_INFO_TOK_in_command282  */
static	ANTLR3_BITWORD FOLLOW_SET_INFO_TOK_in_command282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_INFO_TOK_in_command282	= { FOLLOW_SET_INFO_TOK_in_command282_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metaInfoInternal_in_command284  */
static	ANTLR3_BITWORD FOLLOW_metaInfoInternal_in_command284_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_metaInfoInternal_in_command284	= { FOLLOW_metaInfoInternal_in_command284_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_INFO_TOK_in_command297  */
static	ANTLR3_BITWORD FOLLOW_GET_INFO_TOK_in_command297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_INFO_TOK_in_command297	= { FOLLOW_GET_INFO_TOK_in_command297_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_command299  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_command299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_command299	= { FOLLOW_KEYWORD_in_command299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_OPTION_TOK_in_command317  */
static	ANTLR3_BITWORD FOLLOW_SET_OPTION_TOK_in_command317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_OPTION_TOK_in_command317	= { FOLLOW_SET_OPTION_TOK_in_command317_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setOptionInternal_in_command319  */
static	ANTLR3_BITWORD FOLLOW_setOptionInternal_in_command319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setOptionInternal_in_command319	= { FOLLOW_setOptionInternal_in_command319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_OPTION_TOK_in_command332  */
static	ANTLR3_BITWORD FOLLOW_GET_OPTION_TOK_in_command332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_OPTION_TOK_in_command332	= { FOLLOW_GET_OPTION_TOK_in_command332_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_command334  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_command334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_command334	= { FOLLOW_KEYWORD_in_command334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_SORT_TOK_in_command352  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_SORT_TOK_in_command352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_SORT_TOK_in_command352	= { FOLLOW_DECLARE_SORT_TOK_in_command352_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command366  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command366	= { FOLLOW_symbol_in_command366_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_command381  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_command381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_command381	= { FOLLOW_INTEGER_LITERAL_in_command381_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_SORT_TOK_in_command399  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_SORT_TOK_in_command399_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_SORT_TOK_in_command399	= { FOLLOW_DEFINE_SORT_TOK_in_command399_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command407  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command407	= { FOLLOW_symbol_in_command407_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command420  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2902000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command420	= { FOLLOW_LPAREN_TOK_in_command420_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolList_in_command422  */
static	ANTLR3_BITWORD FOLLOW_symbolList_in_command422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolList_in_command422	= { FOLLOW_symbolList_in_command422_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command425  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command425	= { FOLLOW_RPAREN_TOK_in_command425_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_command437  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_command437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_command437	= { FOLLOW_sortSymbol_in_command437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_FUN_TOK_in_command456  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_FUN_TOK_in_command456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_FUN_TOK_in_command456	= { FOLLOW_DECLARE_FUN_TOK_in_command456_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command464  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command464	= { FOLLOW_symbol_in_command464_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command477  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2902004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command477	= { FOLLOW_LPAREN_TOK_in_command477_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_command479  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_command479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_command479	= { FOLLOW_sortList_in_command479_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command482  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command482	= { FOLLOW_RPAREN_TOK_in_command482_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_command488  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_command488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_command488	= { FOLLOW_sortSymbol_in_command488_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_FUN_TOK_in_command507  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_FUN_TOK_in_command507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_FUN_TOK_in_command507	= { FOLLOW_DEFINE_FUN_TOK_in_command507_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command515  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command515	= { FOLLOW_symbol_in_command515_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command528  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command528	= { FOLLOW_LPAREN_TOK_in_command528_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_command530  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_command530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_command530	= { FOLLOW_sortedVarList_in_command530_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command533  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command533	= { FOLLOW_RPAREN_TOK_in_command533_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_command539  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_command539_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_command539	= { FOLLOW_sortSymbol_in_command539_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_command552  */
static	ANTLR3_BITWORD FOLLOW_term_in_command552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_command552	= { FOLLOW_term_in_command552_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_VALUE_TOK_in_command571  */
static	ANTLR3_BITWORD FOLLOW_GET_VALUE_TOK_in_command571_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x0000000000FFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_VALUE_TOK_in_command571	= { FOLLOW_GET_VALUE_TOK_in_command571_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command581  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command581_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command581	= { FOLLOW_LPAREN_TOK_in_command581_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_command583  */
static	ANTLR3_BITWORD FOLLOW_termList_in_command583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_command583	= { FOLLOW_termList_in_command583_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command586  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command586	= { FOLLOW_RPAREN_TOK_in_command586_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_command602  */
static	ANTLR3_BITWORD FOLLOW_set_in_command602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_command602	= { FOLLOW_set_in_command602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_ASSIGNMENT_TOK_in_command629  */
static	ANTLR3_BITWORD FOLLOW_GET_ASSIGNMENT_TOK_in_command629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_ASSIGNMENT_TOK_in_command629	= { FOLLOW_GET_ASSIGNMENT_TOK_in_command629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSERT_TOK_in_command649  */
static	ANTLR3_BITWORD FOLLOW_ASSERT_TOK_in_command649_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSERT_TOK_in_command649	= { FOLLOW_ASSERT_TOK_in_command649_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_command669  */
static	ANTLR3_BITWORD FOLLOW_term_in_command669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_command669	= { FOLLOW_term_in_command669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECKSAT_TOK_in_command688  */
static	ANTLR3_BITWORD FOLLOW_CHECKSAT_TOK_in_command688_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90002), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECKSAT_TOK_in_command688	= { FOLLOW_CHECKSAT_TOK_in_command688_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_command704  */
static	ANTLR3_BITWORD FOLLOW_term_in_command704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_command704	= { FOLLOW_term_in_command704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_ASSERTIONS_TOK_in_command745  */
static	ANTLR3_BITWORD FOLLOW_GET_ASSERTIONS_TOK_in_command745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_ASSERTIONS_TOK_in_command745	= { FOLLOW_GET_ASSERTIONS_TOK_in_command745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_PROOF_TOK_in_command765  */
static	ANTLR3_BITWORD FOLLOW_GET_PROOF_TOK_in_command765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_PROOF_TOK_in_command765	= { FOLLOW_GET_PROOF_TOK_in_command765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_UNSAT_CORE_TOK_in_command785  */
static	ANTLR3_BITWORD FOLLOW_GET_UNSAT_CORE_TOK_in_command785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_UNSAT_CORE_TOK_in_command785	= { FOLLOW_GET_UNSAT_CORE_TOK_in_command785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PUSH_TOK_in_command805  */
static	ANTLR3_BITWORD FOLLOW_PUSH_TOK_in_command805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PUSH_TOK_in_command805	= { FOLLOW_PUSH_TOK_in_command805_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_command823  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_command823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_command823	= { FOLLOW_INTEGER_LITERAL_in_command823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POP_TOK_in_command847  */
static	ANTLR3_BITWORD FOLLOW_POP_TOK_in_command847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_POP_TOK_in_command847	= { FOLLOW_POP_TOK_in_command847_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_command865  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_command865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_command865	= { FOLLOW_INTEGER_LITERAL_in_command865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXIT_TOK_in_command899  */
static	ANTLR3_BITWORD FOLLOW_EXIT_TOK_in_command899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXIT_TOK_in_command899	= { FOLLOW_EXIT_TOK_in_command899_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_smt25Command_in_command918  */
static	ANTLR3_BITWORD FOLLOW_smt25Command_in_command918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_smt25Command_in_command918	= { FOLLOW_smt25Command_in_command918_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extendedCommand_in_command938  */
static	ANTLR3_BITWORD FOLLOW_extendedCommand_in_command938_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extendedCommand_in_command938	= { FOLLOW_extendedCommand_in_command938_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLE_SYMBOL_in_command958  */
static	ANTLR3_BITWORD FOLLOW_SIMPLE_SYMBOL_in_command958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLE_SYMBOL_in_command958	= { FOLLOW_SIMPLE_SYMBOL_in_command958_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_VAR_TOK_in_sygusCommand990  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_VAR_TOK_in_sygusCommand990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_VAR_TOK_in_sygusCommand990	= { FOLLOW_DECLARE_VAR_TOK_in_sygusCommand990_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand998  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand998	= { FOLLOW_symbol_in_sygusCommand998_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusCommand1011  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusCommand1011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusCommand1011	= { FOLLOW_sortSymbol_in_sygusCommand1011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_PRIMED_VAR_TOK_in_sygusCommand1030  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_PRIMED_VAR_TOK_in_sygusCommand1030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_PRIMED_VAR_TOK_in_sygusCommand1030	= { FOLLOW_DECLARE_PRIMED_VAR_TOK_in_sygusCommand1030_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand1038  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand1038_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand1038	= { FOLLOW_symbol_in_sygusCommand1038_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusCommand1051  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusCommand1051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusCommand1051	= { FOLLOW_sortSymbol_in_sygusCommand1051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1073  */
static	ANTLR3_BITWORD FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1073	= { FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1073_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTH_INV_TOK_in_sygusCommand1077  */
static	ANTLR3_BITWORD FOLLOW_SYNTH_INV_TOK_in_sygusCommand1077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTH_INV_TOK_in_sygusCommand1077	= { FOLLOW_SYNTH_INV_TOK_in_sygusCommand1077_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand1093  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand1093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand1093	= { FOLLOW_symbol_in_sygusCommand1093_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusCommand1100  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusCommand1100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusCommand1100	= { FOLLOW_LPAREN_TOK_in_sygusCommand1100_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_sygusCommand1102  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_sygusCommand1102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_sygusCommand1102	= { FOLLOW_sortedVarList_in_sygusCommand1102_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusCommand1105  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusCommand1105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280002), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusCommand1105	= { FOLLOW_RPAREN_TOK_in_sygusCommand1105_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusCommand1119  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusCommand1119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusCommand1119	= { FOLLOW_sortSymbol_in_sygusCommand1119_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusCommand1133  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusCommand1133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusCommand1133	= { FOLLOW_LPAREN_TOK_in_sygusCommand1133_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusCommand1141  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusCommand1141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusCommand1141	= { FOLLOW_LPAREN_TOK_in_sygusCommand1141_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand1149  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand1149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand1149	= { FOLLOW_symbol_in_sygusCommand1149_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusCommand1159  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusCommand1159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusCommand1159	= { FOLLOW_sortSymbol_in_sygusCommand1159_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusCommand1190  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusCommand1190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2802004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusCommand1190	= { FOLLOW_LPAREN_TOK_in_sygusCommand1190_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusGTerm_in_sygusCommand1194  */
static	ANTLR3_BITWORD FOLLOW_sygusGTerm_in_sygusCommand1194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusGTerm_in_sygusCommand1194	= { FOLLOW_sygusGTerm_in_sygusCommand1194_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusCommand1215  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusCommand1215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusCommand1215	= { FOLLOW_RPAREN_TOK_in_sygusCommand1215_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusCommand1225  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusCommand1225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusCommand1225	= { FOLLOW_RPAREN_TOK_in_sygusCommand1225_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusCommand1239  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusCommand1239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusCommand1239	= { FOLLOW_RPAREN_TOK_in_sygusCommand1239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRAINT_TOK_in_sygusCommand1266  */
static	ANTLR3_BITWORD FOLLOW_CONSTRAINT_TOK_in_sygusCommand1266_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRAINT_TOK_in_sygusCommand1266	= { FOLLOW_CONSTRAINT_TOK_in_sygusCommand1266_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_sygusCommand1274  */
static	ANTLR3_BITWORD FOLLOW_term_in_sygusCommand1274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_sygusCommand1274	= { FOLLOW_term_in_sygusCommand1274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1287  */
static	ANTLR3_BITWORD FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1287	= { FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1287_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand1297  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand1297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280002), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand1297	= { FOLLOW_symbol_in_sygusCommand1297_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1321  */
static	ANTLR3_BITWORD FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1321	= { FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_sygusCommand1339  */
static	ANTLR3_BITWORD FOLLOW_command_in_sygusCommand1339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_sygusCommand1339	= { FOLLOW_command_in_sygusCommand1339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGTerm1380  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGTerm1380_bits[]	= { ANTLR3_UINT64_LIT(0x000C9A02402A0040), ANTLR3_UINT64_LIT(0xA802353B24C00000), ANTLR3_UINT64_LIT(0x0000000000095964) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGTerm1380	= { FOLLOW_LPAREN_TOK_in_sygusGTerm1380_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtinOp_in_sygusGTerm1393  */
static	ANTLR3_BITWORD FOLLOW_builtinOp_in_sygusGTerm1393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_builtinOp_in_sygusGTerm1393	= { FOLLOW_builtinOp_in_sygusGTerm1393_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_sygusGTerm1404  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_sygusGTerm1404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_sygusGTerm1404	= { FOLLOW_LET_TOK_in_sygusGTerm1404_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGTerm1406  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGTerm1406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGTerm1406	= { FOLLOW_LPAREN_TOK_in_sygusGTerm1406_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGTerm1419  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGTerm1419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGTerm1419	= { FOLLOW_LPAREN_TOK_in_sygusGTerm1419_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusGTerm1430  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusGTerm1430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusGTerm1430	= { FOLLOW_symbol_in_sygusGTerm1430_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGTerm1442  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGTerm1442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2802004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGTerm1442	= { FOLLOW_sortSymbol_in_sygusGTerm1442_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusGTerm_in_sygusGTerm1456  */
static	ANTLR3_BITWORD FOLLOW_sygusGTerm_in_sygusGTerm1456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusGTerm_in_sygusGTerm1456	= { FOLLOW_sygusGTerm_in_sygusGTerm1456_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGTerm1467  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGTerm1467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGTerm1467	= { FOLLOW_RPAREN_TOK_in_sygusGTerm1467_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGTerm1472  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGTerm1472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGTerm1472	= { FOLLOW_RPAREN_TOK_in_sygusGTerm1472_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGTerm1480  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGTerm1480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGTerm1480	= { FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGTerm1480_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGTerm1482  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGTerm1482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGTerm1482	= { FOLLOW_sortSymbol_in_sygusGTerm1482_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGTerm1500  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGTerm1500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGTerm1500	= { FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGTerm1500_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGTerm1502  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGTerm1502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGTerm1502	= { FOLLOW_sortSymbol_in_sygusGTerm1502_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_LOCAL_VARIABLE_TOK_in_sygusGTerm1519  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_LOCAL_VARIABLE_TOK_in_sygusGTerm1519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_LOCAL_VARIABLE_TOK_in_sygusGTerm1519	= { FOLLOW_SYGUS_LOCAL_VARIABLE_TOK_in_sygusGTerm1519_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGTerm1521  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGTerm1521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGTerm1521	= { FOLLOW_sortSymbol_in_sygusGTerm1521_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_INPUT_VARIABLE_TOK_in_sygusGTerm1538  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_INPUT_VARIABLE_TOK_in_sygusGTerm1538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_INPUT_VARIABLE_TOK_in_sygusGTerm1538	= { FOLLOW_SYGUS_INPUT_VARIABLE_TOK_in_sygusGTerm1538_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGTerm1540  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGTerm1540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGTerm1540	= { FOLLOW_sortSymbol_in_sygusGTerm1540_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusGTerm1557  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusGTerm1557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusGTerm1557	= { FOLLOW_symbol_in_sygusGTerm1557_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusGTerm_in_sygusGTerm1585  */
static	ANTLR3_BITWORD FOLLOW_sygusGTerm_in_sygusGTerm1585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240290000), ANTLR3_UINT64_LIT(0x2902004182000000), ANTLR3_UINT64_LIT(0x0000000000085803) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusGTerm_in_sygusGTerm1585	= { FOLLOW_sygusGTerm_in_sygusGTerm1585_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGTerm1608  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGTerm1608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGTerm1608	= { FOLLOW_RPAREN_TOK_in_sygusGTerm1608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_sygusGTerm1616  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_sygusGTerm1616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_sygusGTerm1616	= { FOLLOW_INTEGER_LITERAL_in_sygusGTerm1616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_sygusGTerm1628  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_sygusGTerm1628_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_sygusGTerm1628	= { FOLLOW_HEX_LITERAL_in_sygusGTerm1628_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINARY_LITERAL_in_sygusGTerm1640  */
static	ANTLR3_BITWORD FOLLOW_BINARY_LITERAL_in_sygusGTerm1640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BINARY_LITERAL_in_sygusGTerm1640	= { FOLLOW_BINARY_LITERAL_in_sygusGTerm1640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_sygusGTerm1652  */
static	ANTLR3_BITWORD FOLLOW_str_in_sygusGTerm1652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_sygusGTerm1652	= { FOLLOW_str_in_sygusGTerm1652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusGTerm1665  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusGTerm1665_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusGTerm1665	= { FOLLOW_symbol_in_sygusGTerm1665_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_ENUM_CONS_TOK_in_sygusGTerm1674  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_ENUM_CONS_TOK_in_sygusGTerm1674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_ENUM_CONS_TOK_in_sygusGTerm1674	= { FOLLOW_SYGUS_ENUM_CONS_TOK_in_sygusGTerm1674_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusGTerm1676  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusGTerm1676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusGTerm1676	= { FOLLOW_symbol_in_sygusGTerm1676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_metaInfoInternal1718  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_metaInfoInternal1718_bits[]	= { ANTLR3_UINT64_LIT(0x000EBA7B54AF00C0), ANTLR3_UINT64_LIT(0xFEEBF55FA6F3F000), ANTLR3_UINT64_LIT(0x0000000000095803) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_metaInfoInternal1718	= { FOLLOW_KEYWORD_in_metaInfoInternal1718_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_metaInfoInternal1720  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_metaInfoInternal1720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_metaInfoInternal1720	= { FOLLOW_symbolicExpr_in_metaInfoInternal1720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyword_in_setOptionInternal1746  */
static	ANTLR3_BITWORD FOLLOW_keyword_in_setOptionInternal1746_bits[]	= { ANTLR3_UINT64_LIT(0x000EBA7B54AF00C0), ANTLR3_UINT64_LIT(0xFEEBF55FA6F3F000), ANTLR3_UINT64_LIT(0x0000000000095803) };
static  ANTLR3_BITSET_LIST FOLLOW_keyword_in_setOptionInternal1746	= { FOLLOW_keyword_in_setOptionInternal1746_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_setOptionInternal1749  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_setOptionInternal1749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_setOptionInternal1749	= { FOLLOW_symbolicExpr_in_setOptionInternal1749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_META_INFO_TOK_in_smt25Command1781  */
static	ANTLR3_BITWORD FOLLOW_META_INFO_TOK_in_smt25Command1781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_META_INFO_TOK_in_smt25Command1781	= { FOLLOW_META_INFO_TOK_in_smt25Command1781_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metaInfoInternal_in_smt25Command1783  */
static	ANTLR3_BITWORD FOLLOW_metaInfoInternal_in_smt25Command1783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_metaInfoInternal_in_smt25Command1783	= { FOLLOW_metaInfoInternal_in_smt25Command1783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_CONST_TOK_in_smt25Command1797  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_CONST_TOK_in_smt25Command1797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_CONST_TOK_in_smt25Command1797	= { FOLLOW_DECLARE_CONST_TOK_in_smt25Command1797_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_smt25Command1805  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_smt25Command1805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_smt25Command1805	= { FOLLOW_symbol_in_smt25Command1805_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_smt25Command1818  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_smt25Command1818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_smt25Command1818	= { FOLLOW_sortSymbol_in_smt25Command1818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_MODEL_TOK_in_smt25Command1838  */
static	ANTLR3_BITWORD FOLLOW_GET_MODEL_TOK_in_smt25Command1838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_MODEL_TOK_in_smt25Command1838	= { FOLLOW_GET_MODEL_TOK_in_smt25Command1838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ECHO_TOK_in_smt25Command1859  */
static	ANTLR3_BITWORD FOLLOW_ECHO_TOK_in_smt25Command1859_bits[]	= { ANTLR3_UINT64_LIT(0x000EBA7B54AF00C2), ANTLR3_UINT64_LIT(0xFEEBF51FA6F3F000), ANTLR3_UINT64_LIT(0x0000000000095803) };
static  ANTLR3_BITSET_LIST FOLLOW_ECHO_TOK_in_smt25Command1859	= { FOLLOW_ECHO_TOK_in_smt25Command1859_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExpr_in_smt25Command1867  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExpr_in_smt25Command1867_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExpr_in_smt25Command1867	= { FOLLOW_simpleSymbolicExpr_in_smt25Command1867_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESET_TOK_in_smt25Command1903  */
static	ANTLR3_BITWORD FOLLOW_RESET_TOK_in_smt25Command1903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RESET_TOK_in_smt25Command1903	= { FOLLOW_RESET_TOK_in_smt25Command1903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1921  */
static	ANTLR3_BITWORD FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1921	= { FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1933  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1933	= { FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1933_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_smt25Command1945  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_smt25Command1945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_smt25Command1945	= { FOLLOW_symbol_in_smt25Command1945_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command1958  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command1958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command1958	= { FOLLOW_LPAREN_TOK_in_smt25Command1958_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_smt25Command1960  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_smt25Command1960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_smt25Command1960	= { FOLLOW_sortedVarList_in_smt25Command1960_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command1963  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command1963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command1963	= { FOLLOW_RPAREN_TOK_in_smt25Command1963_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_smt25Command1969  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_smt25Command1969_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_smt25Command1969	= { FOLLOW_sortSymbol_in_smt25Command1969_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_smt25Command1982  */
static	ANTLR3_BITWORD FOLLOW_term_in_smt25Command1982_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_smt25Command1982	= { FOLLOW_term_in_smt25Command1982_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1995  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1995	= { FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1995_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command2007  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command2007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command2007	= { FOLLOW_LPAREN_TOK_in_smt25Command2007_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command2015  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command2015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command2015	= { FOLLOW_LPAREN_TOK_in_smt25Command2015_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_smt25Command2023  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_smt25Command2023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_smt25Command2023	= { FOLLOW_symbol_in_smt25Command2023_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command2040  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command2040_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command2040	= { FOLLOW_LPAREN_TOK_in_smt25Command2040_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_smt25Command2042  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_smt25Command2042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_smt25Command2042	= { FOLLOW_sortedVarList_in_smt25Command2042_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command2045  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command2045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command2045	= { FOLLOW_RPAREN_TOK_in_smt25Command2045_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_smt25Command2053  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_smt25Command2053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_smt25Command2053	= { FOLLOW_sortSymbol_in_smt25Command2053_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command2070  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command2070_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command2070	= { FOLLOW_RPAREN_TOK_in_smt25Command2070_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command2083  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command2083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command2083	= { FOLLOW_RPAREN_TOK_in_smt25Command2083_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command2089  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command2089_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command2089	= { FOLLOW_LPAREN_TOK_in_smt25Command2089_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_smt25Command2107  */
static	ANTLR3_BITWORD FOLLOW_term_in_smt25Command2107_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x291602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_smt25Command2107	= { FOLLOW_term_in_smt25Command2107_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command2127  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command2127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command2127	= { FOLLOW_RPAREN_TOK_in_smt25Command2127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_DATATYPES_TOK_in_extendedCommand2164  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_DATATYPES_TOK_in_extendedCommand2164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_DATATYPES_TOK_in_extendedCommand2164	= { FOLLOW_DECLARE_DATATYPES_TOK_in_extendedCommand2164_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypesDefCommand_in_extendedCommand2166  */
static	ANTLR3_BITWORD FOLLOW_datatypesDefCommand_in_extendedCommand2166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypesDefCommand_in_extendedCommand2166	= { FOLLOW_datatypesDefCommand_in_extendedCommand2166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2173  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2173	= { FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypesDefCommand_in_extendedCommand2175  */
static	ANTLR3_BITWORD FOLLOW_datatypesDefCommand_in_extendedCommand2175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypesDefCommand_in_extendedCommand2175	= { FOLLOW_datatypesDefCommand_in_extendedCommand2175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rewriterulesCommand_in_extendedCommand2182  */
static	ANTLR3_BITWORD FOLLOW_rewriterulesCommand_in_extendedCommand2182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rewriterulesCommand_in_extendedCommand2182	= { FOLLOW_rewriterulesCommand_in_extendedCommand2182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_SORTS_TOK_in_extendedCommand2197  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_SORTS_TOK_in_extendedCommand2197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_SORTS_TOK_in_extendedCommand2197	= { FOLLOW_DECLARE_SORTS_TOK_in_extendedCommand2197_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2217  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2217	= { FOLLOW_LPAREN_TOK_in_extendedCommand2217_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2225  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2902000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2225	= { FOLLOW_symbol_in_extendedCommand2225_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2247  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2247	= { FOLLOW_RPAREN_TOK_in_extendedCommand2247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_FUNS_TOK_in_extendedCommand2260  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_FUNS_TOK_in_extendedCommand2260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_FUNS_TOK_in_extendedCommand2260	= { FOLLOW_DECLARE_FUNS_TOK_in_extendedCommand2260_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2274  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2274	= { FOLLOW_LPAREN_TOK_in_extendedCommand2274_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2282  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2282	= { FOLLOW_LPAREN_TOK_in_extendedCommand2282_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2284  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2284_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2284	= { FOLLOW_symbol_in_extendedCommand2284_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonemptySortList_in_extendedCommand2301  */
static	ANTLR3_BITWORD FOLLOW_nonemptySortList_in_extendedCommand2301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_nonemptySortList_in_extendedCommand2301	= { FOLLOW_nonemptySortList_in_extendedCommand2301_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2304  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2304	= { FOLLOW_RPAREN_TOK_in_extendedCommand2304_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2325  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2325	= { FOLLOW_RPAREN_TOK_in_extendedCommand2325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_PREDS_TOK_in_extendedCommand2338  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_PREDS_TOK_in_extendedCommand2338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_PREDS_TOK_in_extendedCommand2338	= { FOLLOW_DECLARE_PREDS_TOK_in_extendedCommand2338_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2352  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2352	= { FOLLOW_LPAREN_TOK_in_extendedCommand2352_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2360  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2360	= { FOLLOW_LPAREN_TOK_in_extendedCommand2360_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2362  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2902004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2362	= { FOLLOW_symbol_in_extendedCommand2362_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_extendedCommand2379  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_extendedCommand2379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_extendedCommand2379	= { FOLLOW_sortList_in_extendedCommand2379_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2382  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2382	= { FOLLOW_RPAREN_TOK_in_extendedCommand2382_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2403  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2403	= { FOLLOW_RPAREN_TOK_in_extendedCommand2403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_TOK_in_extendedCommand2416  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_TOK_in_extendedCommand2416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_TOK_in_extendedCommand2416	= { FOLLOW_DEFINE_TOK_in_extendedCommand2416_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2426  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2426_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2426	= { FOLLOW_symbol_in_extendedCommand2426_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2443  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2443	= { FOLLOW_term_in_extendedCommand2443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2460  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2460	= { FOLLOW_LPAREN_TOK_in_extendedCommand2460_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2468  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2468	= { FOLLOW_symbol_in_extendedCommand2468_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_extendedCommand2485  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_extendedCommand2485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_extendedCommand2485	= { FOLLOW_sortedVarList_in_extendedCommand2485_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2488  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2488_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2488	= { FOLLOW_RPAREN_TOK_in_extendedCommand2488_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2504  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2504	= { FOLLOW_term_in_extendedCommand2504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2525  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2525	= { FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2525_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2533  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2533	= { FOLLOW_symbol_in_extendedCommand2533_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_extendedCommand2546  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_extendedCommand2546_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_extendedCommand2546	= { FOLLOW_sortSymbol_in_extendedCommand2546_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2559  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2559	= { FOLLOW_term_in_extendedCommand2559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLIFY_TOK_in_extendedCommand2573  */
static	ANTLR3_BITWORD FOLLOW_SIMPLIFY_TOK_in_extendedCommand2573_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLIFY_TOK_in_extendedCommand2573	= { FOLLOW_SIMPLIFY_TOK_in_extendedCommand2573_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2581  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2581	= { FOLLOW_term_in_extendedCommand2581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_QE_TOK_in_extendedCommand2594  */
static	ANTLR3_BITWORD FOLLOW_GET_QE_TOK_in_extendedCommand2594_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_QE_TOK_in_extendedCommand2594	= { FOLLOW_GET_QE_TOK_in_extendedCommand2594_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2602  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2602	= { FOLLOW_term_in_extendedCommand2602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2615  */
static	ANTLR3_BITWORD FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2615_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2615	= { FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2615_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2623  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2623	= { FOLLOW_term_in_extendedCommand2623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDefCommand2654  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDefCommand2654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2902000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDefCommand2654	= { FOLLOW_LPAREN_TOK_in_datatypesDefCommand2654_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_datatypesDefCommand2662  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_datatypesDefCommand2662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2902000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_datatypesDefCommand2662	= { FOLLOW_symbol_in_datatypesDefCommand2662_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDefCommand2678  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDefCommand2678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDefCommand2678	= { FOLLOW_RPAREN_TOK_in_datatypesDefCommand2678_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDefCommand2682  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDefCommand2682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDefCommand2682	= { FOLLOW_LPAREN_TOK_in_datatypesDefCommand2682_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDefCommand2686  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDefCommand2686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDefCommand2686	= { FOLLOW_LPAREN_TOK_in_datatypesDefCommand2686_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypeDef_in_datatypesDefCommand2688  */
static	ANTLR3_BITWORD FOLLOW_datatypeDef_in_datatypesDefCommand2688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypeDef_in_datatypesDefCommand2688	= { FOLLOW_datatypeDef_in_datatypesDefCommand2688_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDefCommand2691  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDefCommand2691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDefCommand2691	= { FOLLOW_RPAREN_TOK_in_datatypesDefCommand2691_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDefCommand2696  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDefCommand2696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDefCommand2696	= { FOLLOW_RPAREN_TOK_in_datatypesDefCommand2696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REWRITE_RULE_TOK_in_rewriterulesCommand2725  */
static	ANTLR3_BITWORD FOLLOW_REWRITE_RULE_TOK_in_rewriterulesCommand2725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_REWRITE_RULE_TOK_in_rewriterulesCommand2725	= { FOLLOW_REWRITE_RULE_TOK_in_rewriterulesCommand2725_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_rewriterulesCommand2731  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_rewriterulesCommand2731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_rewriterulesCommand2731	= { FOLLOW_LPAREN_TOK_in_rewriterulesCommand2731_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_rewriterulesCommand2733  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_rewriterulesCommand2733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_rewriterulesCommand2733	= { FOLLOW_sortedVarList_in_rewriterulesCommand2733_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_rewriterulesCommand2736  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_rewriterulesCommand2736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_rewriterulesCommand2736	= { FOLLOW_RPAREN_TOK_in_rewriterulesCommand2736_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_rewriterulesCommand2748  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_rewriterulesCommand2748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_rewriterulesCommand2748	= { FOLLOW_LPAREN_TOK_in_rewriterulesCommand2748_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pattern_in_rewriterulesCommand2752  */
static	ANTLR3_BITWORD FOLLOW_pattern_in_rewriterulesCommand2752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_pattern_in_rewriterulesCommand2752	= { FOLLOW_pattern_in_rewriterulesCommand2752_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_rewriterulesCommand2760  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_rewriterulesCommand2760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_rewriterulesCommand2760	= { FOLLOW_RPAREN_TOK_in_rewriterulesCommand2760_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_rewriterulesCommand2766  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_rewriterulesCommand2766_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x291602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_rewriterulesCommand2766	= { FOLLOW_LPAREN_TOK_in_rewriterulesCommand2766_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_rewriterulesCommand2769  */
static	ANTLR3_BITWORD FOLLOW_termList_in_rewriterulesCommand2769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_rewriterulesCommand2769	= { FOLLOW_termList_in_rewriterulesCommand2769_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_rewriterulesCommand2774  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_rewriterulesCommand2774_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_rewriterulesCommand2774	= { FOLLOW_RPAREN_TOK_in_rewriterulesCommand2774_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_rewriterulesCommand2780  */
static	ANTLR3_BITWORD FOLLOW_term_in_rewriterulesCommand2780_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_rewriterulesCommand2780	= { FOLLOW_term_in_rewriterulesCommand2780_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_rewriterulesCommand2783  */
static	ANTLR3_BITWORD FOLLOW_term_in_rewriterulesCommand2783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_rewriterulesCommand2783	= { FOLLOW_term_in_rewriterulesCommand2783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rewritePropaKind_in_rewriterulesCommand2802  */
static	ANTLR3_BITWORD FOLLOW_rewritePropaKind_in_rewriterulesCommand2802_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_rewritePropaKind_in_rewriterulesCommand2802	= { FOLLOW_rewritePropaKind_in_rewriterulesCommand2802_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_rewriterulesCommand2809  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_rewriterulesCommand2809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_rewriterulesCommand2809	= { FOLLOW_LPAREN_TOK_in_rewriterulesCommand2809_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_rewriterulesCommand2811  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_rewriterulesCommand2811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_rewriterulesCommand2811	= { FOLLOW_sortedVarList_in_rewriterulesCommand2811_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_rewriterulesCommand2814  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_rewriterulesCommand2814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_rewriterulesCommand2814	= { FOLLOW_RPAREN_TOK_in_rewriterulesCommand2814_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_rewriterulesCommand2826  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_rewriterulesCommand2826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_rewriterulesCommand2826	= { FOLLOW_LPAREN_TOK_in_rewriterulesCommand2826_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pattern_in_rewriterulesCommand2830  */
static	ANTLR3_BITWORD FOLLOW_pattern_in_rewriterulesCommand2830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_pattern_in_rewriterulesCommand2830	= { FOLLOW_pattern_in_rewriterulesCommand2830_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_rewriterulesCommand2838  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_rewriterulesCommand2838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_rewriterulesCommand2838	= { FOLLOW_RPAREN_TOK_in_rewriterulesCommand2838_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_rewriterulesCommand2844  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_rewriterulesCommand2844_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x291602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_rewriterulesCommand2844	= { FOLLOW_LPAREN_TOK_in_rewriterulesCommand2844_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_rewriterulesCommand2847  */
static	ANTLR3_BITWORD FOLLOW_termList_in_rewriterulesCommand2847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_rewriterulesCommand2847	= { FOLLOW_termList_in_rewriterulesCommand2847_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_rewriterulesCommand2852  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_rewriterulesCommand2852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_rewriterulesCommand2852	= { FOLLOW_RPAREN_TOK_in_rewriterulesCommand2852_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_rewriterulesCommand2858  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_rewriterulesCommand2858_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x291602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_rewriterulesCommand2858	= { FOLLOW_LPAREN_TOK_in_rewriterulesCommand2858_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_rewriterulesCommand2861  */
static	ANTLR3_BITWORD FOLLOW_termList_in_rewriterulesCommand2861_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_rewriterulesCommand2861	= { FOLLOW_termList_in_rewriterulesCommand2861_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_rewriterulesCommand2866  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_rewriterulesCommand2866_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_rewriterulesCommand2866	= { FOLLOW_RPAREN_TOK_in_rewriterulesCommand2866_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_rewriterulesCommand2872  */
static	ANTLR3_BITWORD FOLLOW_term_in_rewriterulesCommand2872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_rewriterulesCommand2872	= { FOLLOW_term_in_rewriterulesCommand2872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REDUCTION_RULE_TOK_in_rewritePropaKind2893  */
static	ANTLR3_BITWORD FOLLOW_REDUCTION_RULE_TOK_in_rewritePropaKind2893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REDUCTION_RULE_TOK_in_rewritePropaKind2893	= { FOLLOW_REDUCTION_RULE_TOK_in_rewritePropaKind2893_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROPAGATION_RULE_TOK_in_rewritePropaKind2904  */
static	ANTLR3_BITWORD FOLLOW_PROPAGATION_RULE_TOK_in_rewritePropaKind2904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PROPAGATION_RULE_TOK_in_rewritePropaKind2904	= { FOLLOW_PROPAGATION_RULE_TOK_in_rewritePropaKind2904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_pattern2926  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_pattern2926_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_pattern2926	= { FOLLOW_LPAREN_TOK_in_pattern2926_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_pattern2928  */
static	ANTLR3_BITWORD FOLLOW_termList_in_pattern2928_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_pattern2928	= { FOLLOW_termList_in_pattern2928_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_pattern2931  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_pattern2931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_pattern2931	= { FOLLOW_RPAREN_TOK_in_pattern2931_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2956  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2956	= { FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2968  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2968	= { FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2980  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2980	= { FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2992  */
static	ANTLR3_BITWORD FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2992_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2992	= { FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2992_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_simpleSymbolicExprNoKeyword3004  */
static	ANTLR3_BITWORD FOLLOW_str_in_simpleSymbolicExprNoKeyword3004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_simpleSymbolicExprNoKeyword3004	= { FOLLOW_str_in_simpleSymbolicExprNoKeyword3004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_simpleSymbolicExprNoKeyword3024  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_simpleSymbolicExprNoKeyword3024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_simpleSymbolicExprNoKeyword3024	= { FOLLOW_symbol_in_simpleSymbolicExprNoKeyword3024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_simpleSymbolicExprNoKeyword3039  */
static	ANTLR3_BITWORD FOLLOW_set_in_simpleSymbolicExprNoKeyword3039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_simpleSymbolicExprNoKeyword3039	= { FOLLOW_set_in_simpleSymbolicExprNoKeyword3039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtinOp_in_simpleSymbolicExprNoKeyword3225  */
static	ANTLR3_BITWORD FOLLOW_builtinOp_in_simpleSymbolicExprNoKeyword3225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_builtinOp_in_simpleSymbolicExprNoKeyword3225	= { FOLLOW_builtinOp_in_simpleSymbolicExprNoKeyword3225_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_keyword3246  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_keyword3246_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_keyword3246	= { FOLLOW_KEYWORD_in_keyword3246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3266  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3266	= { FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_simpleSymbolicExpr3273  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_simpleSymbolicExpr3273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_simpleSymbolicExpr3273	= { FOLLOW_KEYWORD_in_simpleSymbolicExpr3273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExpr_in_symbolicExpr3298  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExpr_in_symbolicExpr3298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExpr_in_symbolicExpr3298	= { FOLLOW_simpleSymbolicExpr_in_symbolicExpr3298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_symbolicExpr3305  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_symbolicExpr3305_bits[]	= { ANTLR3_UINT64_LIT(0x000EBA7B54AF00C0), ANTLR3_UINT64_LIT(0xFFEBF55FA6F3F000), ANTLR3_UINT64_LIT(0x0000000000095803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_symbolicExpr3305	= { FOLLOW_LPAREN_TOK_in_symbolicExpr3305_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_symbolicExpr3313  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_symbolicExpr3313_bits[]	= { ANTLR3_UINT64_LIT(0x000EBA7B54AF00C0), ANTLR3_UINT64_LIT(0xFFEBF55FA6F3F000), ANTLR3_UINT64_LIT(0x0000000000095803) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_symbolicExpr3313	= { FOLLOW_symbolicExpr_in_symbolicExpr3313_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_symbolicExpr3321  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_symbolicExpr3321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_symbolicExpr3321	= { FOLLOW_RPAREN_TOK_in_symbolicExpr3321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3354  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3354_bits[]	= { ANTLR3_UINT64_LIT(0x000C9A0000020040), ANTLR3_UINT64_LIT(0x8000351A24C00000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3354	= { FOLLOW_LPAREN_TOK_in_term3354_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtinOp_in_term3356  */
static	ANTLR3_BITWORD FOLLOW_builtinOp_in_term3356_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_builtinOp_in_term3356	= { FOLLOW_builtinOp_in_term3356_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_term3359  */
static	ANTLR3_BITWORD FOLLOW_termList_in_term3359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_term3359	= { FOLLOW_termList_in_term3359_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3362  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3362	= { FOLLOW_RPAREN_TOK_in_term3362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3374  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3374	= { FOLLOW_LPAREN_TOK_in_term3374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AS_TOK_in_term3376  */
static	ANTLR3_BITWORD FOLLOW_AS_TOK_in_term3376_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_AS_TOK_in_term3376	= { FOLLOW_AS_TOK_in_term3376_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_term3378  */
static	ANTLR3_BITWORD FOLLOW_term_in_term3378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_term3378	= { FOLLOW_term_in_term3378_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_term3381  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_term3381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_term3381	= { FOLLOW_sortSymbol_in_term3381_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3384  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3384	= { FOLLOW_RPAREN_TOK_in_term3384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3396  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3396_bits[]	= { ANTLR3_UINT64_LIT(0x0011000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3396	= { FOLLOW_LPAREN_TOK_in_term3396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quantOp_in_term3398  */
static	ANTLR3_BITWORD FOLLOW_quantOp_in_term3398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_quantOp_in_term3398	= { FOLLOW_quantOp_in_term3398_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3405  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3405	= { FOLLOW_LPAREN_TOK_in_term3405_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_term3407  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_term3407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_term3407	= { FOLLOW_sortedVarList_in_term3407_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3410  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3410_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3410	= { FOLLOW_RPAREN_TOK_in_term3410_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_term3422  */
static	ANTLR3_BITWORD FOLLOW_term_in_term3422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_term3422	= { FOLLOW_term_in_term3422_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3425  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3425	= { FOLLOW_RPAREN_TOK_in_term3425_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3437  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3437	= { FOLLOW_LPAREN_TOK_in_term3437_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_term3439  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_term3439_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_term3439	= { FOLLOW_functionName_in_term3439_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_term3457  */
static	ANTLR3_BITWORD FOLLOW_termList_in_term3457_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_term3457	= { FOLLOW_termList_in_term3457_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3460  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3460	= { FOLLOW_RPAREN_TOK_in_term3460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3473  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3473	= { FOLLOW_LPAREN_TOK_in_term3473_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_indexedFunctionName_in_term3489  */
static	ANTLR3_BITWORD FOLLOW_indexedFunctionName_in_term3489_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_indexedFunctionName_in_term3489	= { FOLLOW_indexedFunctionName_in_term3489_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_term3492  */
static	ANTLR3_BITWORD FOLLOW_termList_in_term3492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_term3492	= { FOLLOW_termList_in_term3492_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3495  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3495	= { FOLLOW_RPAREN_TOK_in_term3495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3519  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3519	= { FOLLOW_LPAREN_TOK_in_term3519_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AS_TOK_in_term3521  */
static	ANTLR3_BITWORD FOLLOW_AS_TOK_in_term3521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_AS_TOK_in_term3521	= { FOLLOW_AS_TOK_in_term3521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONST_TOK_in_term3523  */
static	ANTLR3_BITWORD FOLLOW_CONST_TOK_in_term3523_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_CONST_TOK_in_term3523	= { FOLLOW_CONST_TOK_in_term3523_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_term3525  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_term3525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_term3525	= { FOLLOW_sortSymbol_in_term3525_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3534  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3534_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3534	= { FOLLOW_RPAREN_TOK_in_term3534_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_term3536  */
static	ANTLR3_BITWORD FOLLOW_term_in_term3536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_term3536	= { FOLLOW_term_in_term3536_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3539  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3539	= { FOLLOW_RPAREN_TOK_in_term3539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3565  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3565	= { FOLLOW_LPAREN_TOK_in_term3565_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_term3567  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_term3567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_term3567	= { FOLLOW_LET_TOK_in_term3567_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3569  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3569_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3569	= { FOLLOW_LPAREN_TOK_in_term3569_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3583  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3583	= { FOLLOW_LPAREN_TOK_in_term3583_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_term3585  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_term3585_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_term3585	= { FOLLOW_symbol_in_term3585_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_term3595  */
static	ANTLR3_BITWORD FOLLOW_term_in_term3595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_term3595	= { FOLLOW_term_in_term3595_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_term3600  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_term3600_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_term3600	= { FOLLOW_sortSymbol_in_term3600_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_term3612  */
static	ANTLR3_BITWORD FOLLOW_term_in_term3612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_term3612	= { FOLLOW_term_in_term3612_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3629  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3629	= { FOLLOW_RPAREN_TOK_in_term3629_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3666  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3666_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3666	= { FOLLOW_RPAREN_TOK_in_term3666_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_term3672  */
static	ANTLR3_BITWORD FOLLOW_term_in_term3672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_term3672	= { FOLLOW_term_in_term3672_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3679  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3679	= { FOLLOW_RPAREN_TOK_in_term3679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_term3691  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_term3691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_term3691	= { FOLLOW_symbol_in_term3691_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_ENUM_CONS_TOK_in_term3694  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_ENUM_CONS_TOK_in_term3694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_ENUM_CONS_TOK_in_term3694	= { FOLLOW_SYGUS_ENUM_CONS_TOK_in_term3694_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_term3700  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_term3700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_term3700	= { FOLLOW_symbol_in_term3700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_term3719  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_term3719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_term3719	= { FOLLOW_symbol_in_term3719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3739  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3739	= { FOLLOW_LPAREN_TOK_in_term3739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_TOK_in_term3741  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_TOK_in_term3741_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_TOK_in_term3741	= { FOLLOW_ATTRIBUTE_TOK_in_term3741_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_term3743  */
static	ANTLR3_BITWORD FOLLOW_term_in_term3743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003E00), ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_term3743	= { FOLLOW_term_in_term3743_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_term3752  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_term3752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003E00), ANTLR3_UINT64_LIT(0x0100000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_term3752	= { FOLLOW_attribute_in_term3752_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3770  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3770	= { FOLLOW_RPAREN_TOK_in_term3770_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3788  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3788_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3788	= { FOLLOW_INTEGER_LITERAL_in_term3788_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_term3801  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_term3801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_term3801	= { FOLLOW_DECIMAL_LITERAL_in_term3801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_term3814  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_term3814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_term3814	= { FOLLOW_LPAREN_TOK_in_term3814_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDEX_TOK_in_term3816  */
static	ANTLR3_BITWORD FOLLOW_INDEX_TOK_in_term3816_bits[]	= { ANTLR3_UINT64_LIT(0x0160000000000000), ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INDEX_TOK_in_term3816	= { FOLLOW_INDEX_TOK_in_term3816_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLE_SYMBOL_in_term3827  */
static	ANTLR3_BITWORD FOLLOW_SIMPLE_SYMBOL_in_term3827_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLE_SYMBOL_in_term3827	= { FOLLOW_SIMPLE_SYMBOL_in_term3827_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3831  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3831_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3831	= { FOLLOW_INTEGER_LITERAL_in_term3831_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_PINF_TOK_in_term3848  */
static	ANTLR3_BITWORD FOLLOW_FP_PINF_TOK_in_term3848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_PINF_TOK_in_term3848	= { FOLLOW_FP_PINF_TOK_in_term3848_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3852  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3852	= { FOLLOW_INTEGER_LITERAL_in_term3852_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3856  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3856	= { FOLLOW_INTEGER_LITERAL_in_term3856_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_NINF_TOK_in_term3872  */
static	ANTLR3_BITWORD FOLLOW_FP_NINF_TOK_in_term3872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_NINF_TOK_in_term3872	= { FOLLOW_FP_NINF_TOK_in_term3872_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3876  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3876	= { FOLLOW_INTEGER_LITERAL_in_term3876_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3880  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3880	= { FOLLOW_INTEGER_LITERAL_in_term3880_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_NAN_TOK_in_term3896  */
static	ANTLR3_BITWORD FOLLOW_FP_NAN_TOK_in_term3896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_NAN_TOK_in_term3896	= { FOLLOW_FP_NAN_TOK_in_term3896_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3900  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3900_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3900	= { FOLLOW_INTEGER_LITERAL_in_term3900_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_term3904  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_term3904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_term3904	= { FOLLOW_INTEGER_LITERAL_in_term3904_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_term3930  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_term3930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_term3930	= { FOLLOW_RPAREN_TOK_in_term3930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_term3937  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_term3937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_term3937	= { FOLLOW_HEX_LITERAL_in_term3937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINARY_LITERAL_in_term3950  */
static	ANTLR3_BITWORD FOLLOW_BINARY_LITERAL_in_term3950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BINARY_LITERAL_in_term3950	= { FOLLOW_BINARY_LITERAL_in_term3950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_term3963  */
static	ANTLR3_BITWORD FOLLOW_str_in_term3963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_term3963	= { FOLLOW_str_in_term3963_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RNE_TOK_in_term3976  */
static	ANTLR3_BITWORD FOLLOW_FP_RNE_TOK_in_term3976_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RNE_TOK_in_term3976	= { FOLLOW_FP_RNE_TOK_in_term3976_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RNA_TOK_in_term3989  */
static	ANTLR3_BITWORD FOLLOW_FP_RNA_TOK_in_term3989_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RNA_TOK_in_term3989	= { FOLLOW_FP_RNA_TOK_in_term3989_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RTP_TOK_in_term4002  */
static	ANTLR3_BITWORD FOLLOW_FP_RTP_TOK_in_term4002_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RTP_TOK_in_term4002	= { FOLLOW_FP_RTP_TOK_in_term4002_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RTN_TOK_in_term4015  */
static	ANTLR3_BITWORD FOLLOW_FP_RTN_TOK_in_term4015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RTN_TOK_in_term4015	= { FOLLOW_FP_RTN_TOK_in_term4015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RTZ_TOK_in_term4028  */
static	ANTLR3_BITWORD FOLLOW_FP_RTZ_TOK_in_term4028_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RTZ_TOK_in_term4028	= { FOLLOW_FP_RTZ_TOK_in_term4028_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RNE_FULL_TOK_in_term4041  */
static	ANTLR3_BITWORD FOLLOW_FP_RNE_FULL_TOK_in_term4041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RNE_FULL_TOK_in_term4041	= { FOLLOW_FP_RNE_FULL_TOK_in_term4041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RNA_FULL_TOK_in_term4049  */
static	ANTLR3_BITWORD FOLLOW_FP_RNA_FULL_TOK_in_term4049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RNA_FULL_TOK_in_term4049	= { FOLLOW_FP_RNA_FULL_TOK_in_term4049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RTP_FULL_TOK_in_term4057  */
static	ANTLR3_BITWORD FOLLOW_FP_RTP_FULL_TOK_in_term4057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RTP_FULL_TOK_in_term4057	= { FOLLOW_FP_RTP_FULL_TOK_in_term4057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RTN_FULL_TOK_in_term4065  */
static	ANTLR3_BITWORD FOLLOW_FP_RTN_FULL_TOK_in_term4065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RTN_FULL_TOK_in_term4065	= { FOLLOW_FP_RTN_FULL_TOK_in_term4065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_RTZ_FULL_TOK_in_term4073  */
static	ANTLR3_BITWORD FOLLOW_FP_RTZ_FULL_TOK_in_term4073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_RTZ_FULL_TOK_in_term4073	= { FOLLOW_FP_RTZ_FULL_TOK_in_term4073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RENOSTR_TOK_in_term4082  */
static	ANTLR3_BITWORD FOLLOW_RENOSTR_TOK_in_term4082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RENOSTR_TOK_in_term4082	= { FOLLOW_RENOSTR_TOK_in_term4082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REALLCHAR_TOK_in_term4095  */
static	ANTLR3_BITWORD FOLLOW_REALLCHAR_TOK_in_term4095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REALLCHAR_TOK_in_term4095	= { FOLLOW_REALLCHAR_TOK_in_term4095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EMPTYSET_TOK_in_term4108  */
static	ANTLR3_BITWORD FOLLOW_EMPTYSET_TOK_in_term4108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EMPTYSET_TOK_in_term4108	= { FOLLOW_EMPTYSET_TOK_in_term4108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNIVSET_TOK_in_term4121  */
static	ANTLR3_BITWORD FOLLOW_UNIVSET_TOK_in_term4121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNIVSET_TOK_in_term4121	= { FOLLOW_UNIVSET_TOK_in_term4121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NILREF_TOK_in_term4134  */
static	ANTLR3_BITWORD FOLLOW_NILREF_TOK_in_term4134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NILREF_TOK_in_term4134	= { FOLLOW_NILREF_TOK_in_term4134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_attribute4166  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_attribute4166_bits[]	= { ANTLR3_UINT64_LIT(0x000EBA7B54AF00C2), ANTLR3_UINT64_LIT(0xFEEBF51BA6F3F000), ANTLR3_UINT64_LIT(0x0000000000095803) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_attribute4166	= { FOLLOW_KEYWORD_in_attribute4166_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4170  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4170	= { FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4186  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4186	= { FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4186_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_attribute4188  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_attribute4188_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_attribute4188	= { FOLLOW_LPAREN_TOK_in_attribute4188_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_attribute4196  */
static	ANTLR3_BITWORD FOLLOW_term_in_attribute4196_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x291602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_attribute4196	= { FOLLOW_term_in_attribute4196_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_attribute4214  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_attribute4214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_attribute4214	= { FOLLOW_RPAREN_TOK_in_attribute4214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4226  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4226_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90000), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4226	= { FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4226_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_attribute4228  */
static	ANTLR3_BITWORD FOLLOW_term_in_attribute4228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_attribute4228	= { FOLLOW_term_in_attribute4228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_attribute4243  */
static	ANTLR3_BITWORD FOLLOW_set_in_attribute4243_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_attribute4243	= { FOLLOW_set_in_attribute4243_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_attribute4253  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_attribute4253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_attribute4253	= { FOLLOW_INTEGER_LITERAL_in_attribute4253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4265  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4265_bits[]	= { ANTLR3_UINT64_LIT(0x000EBA7B54AF00C0), ANTLR3_UINT64_LIT(0xFEEBF55FA6F3F000), ANTLR3_UINT64_LIT(0x0000000000095803) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4265	= { FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4265_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_attribute4267  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_attribute4267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_attribute4267	= { FOLLOW_symbolicExpr_in_attribute4267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_indexedFunctionName4290  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_indexedFunctionName4290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_indexedFunctionName4290	= { FOLLOW_LPAREN_TOK_in_indexedFunctionName4290_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDEX_TOK_in_indexedFunctionName4292  */
static	ANTLR3_BITWORD FOLLOW_INDEX_TOK_in_indexedFunctionName4292_bits[]	= { ANTLR3_UINT64_LIT(0x03E0040000000000), ANTLR3_UINT64_LIT(0x2002000040000FF0), ANTLR3_UINT64_LIT(0x0000000000FC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_INDEX_TOK_in_indexedFunctionName4292	= { FOLLOW_INDEX_TOK_in_indexedFunctionName4292_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_146_in_indexedFunctionName4300  */
static	ANTLR3_BITWORD FOLLOW_146_in_indexedFunctionName4300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_146_in_indexedFunctionName4300	= { FOLLOW_146_in_indexedFunctionName4300_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4304  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4304	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4304_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4308  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4308	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4308_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_147_in_indexedFunctionName4324  */
static	ANTLR3_BITWORD FOLLOW_147_in_indexedFunctionName4324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_147_in_indexedFunctionName4324	= { FOLLOW_147_in_indexedFunctionName4324_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4328  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4328	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4328_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_151_in_indexedFunctionName4344  */
static	ANTLR3_BITWORD FOLLOW_151_in_indexedFunctionName4344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_151_in_indexedFunctionName4344	= { FOLLOW_151_in_indexedFunctionName4344_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4348  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4348_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4348	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4348_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_150_in_indexedFunctionName4364  */
static	ANTLR3_BITWORD FOLLOW_150_in_indexedFunctionName4364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_150_in_indexedFunctionName4364	= { FOLLOW_150_in_indexedFunctionName4364_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4368  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4368	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4368_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_148_in_indexedFunctionName4384  */
static	ANTLR3_BITWORD FOLLOW_148_in_indexedFunctionName4384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_148_in_indexedFunctionName4384	= { FOLLOW_148_in_indexedFunctionName4384_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4388  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4388	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4388_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_149_in_indexedFunctionName4404  */
static	ANTLR3_BITWORD FOLLOW_149_in_indexedFunctionName4404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_149_in_indexedFunctionName4404	= { FOLLOW_149_in_indexedFunctionName4404_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4408  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4408	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4408_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIVISIBLE_TOK_in_indexedFunctionName4424  */
static	ANTLR3_BITWORD FOLLOW_DIVISIBLE_TOK_in_indexedFunctionName4424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DIVISIBLE_TOK_in_indexedFunctionName4424	= { FOLLOW_DIVISIBLE_TOK_in_indexedFunctionName4424_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4428  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4428	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4428_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT2BV_TOK_in_indexedFunctionName4444  */
static	ANTLR3_BITWORD FOLLOW_INT2BV_TOK_in_indexedFunctionName4444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INT2BV_TOK_in_indexedFunctionName4444	= { FOLLOW_INT2BV_TOK_in_indexedFunctionName4444_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4448  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4448_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4448	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4448_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_PINF_TOK_in_indexedFunctionName4464  */
static	ANTLR3_BITWORD FOLLOW_FP_PINF_TOK_in_indexedFunctionName4464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_PINF_TOK_in_indexedFunctionName4464	= { FOLLOW_FP_PINF_TOK_in_indexedFunctionName4464_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4468  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4468	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4468_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4472  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4472	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4472_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_NINF_TOK_in_indexedFunctionName4488  */
static	ANTLR3_BITWORD FOLLOW_FP_NINF_TOK_in_indexedFunctionName4488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_NINF_TOK_in_indexedFunctionName4488	= { FOLLOW_FP_NINF_TOK_in_indexedFunctionName4488_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4492  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4492	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4492_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4496  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4496	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4496_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_NAN_TOK_in_indexedFunctionName4512  */
static	ANTLR3_BITWORD FOLLOW_FP_NAN_TOK_in_indexedFunctionName4512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_NAN_TOK_in_indexedFunctionName4512	= { FOLLOW_FP_NAN_TOK_in_indexedFunctionName4512_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4516  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4516	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4516_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4520  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4520	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4520_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_PZERO_TOK_in_indexedFunctionName4536  */
static	ANTLR3_BITWORD FOLLOW_FP_PZERO_TOK_in_indexedFunctionName4536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_PZERO_TOK_in_indexedFunctionName4536	= { FOLLOW_FP_PZERO_TOK_in_indexedFunctionName4536_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4540  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4540	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4540_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4544  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4544	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4544_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_NZERO_TOK_in_indexedFunctionName4560  */
static	ANTLR3_BITWORD FOLLOW_FP_NZERO_TOK_in_indexedFunctionName4560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_NZERO_TOK_in_indexedFunctionName4560	= { FOLLOW_FP_NZERO_TOK_in_indexedFunctionName4560_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4564  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4564	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4564_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4568  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4568_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4568	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4568_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_FP_TOK_in_indexedFunctionName4584  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_FP_TOK_in_indexedFunctionName4584_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_FP_TOK_in_indexedFunctionName4584	= { FOLLOW_FP_TO_FP_TOK_in_indexedFunctionName4584_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4588  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4588	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4588_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4592  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4592	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4592_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_FPBV_TOK_in_indexedFunctionName4608  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_FPBV_TOK_in_indexedFunctionName4608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_FPBV_TOK_in_indexedFunctionName4608	= { FOLLOW_FP_TO_FPBV_TOK_in_indexedFunctionName4608_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4612  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4612	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4612_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4616  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4616	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4616_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_FPFP_TOK_in_indexedFunctionName4632  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_FPFP_TOK_in_indexedFunctionName4632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_FPFP_TOK_in_indexedFunctionName4632	= { FOLLOW_FP_TO_FPFP_TOK_in_indexedFunctionName4632_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4636  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4636_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4636	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4636_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4640  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4640	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4640_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_FPR_TOK_in_indexedFunctionName4656  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_FPR_TOK_in_indexedFunctionName4656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_FPR_TOK_in_indexedFunctionName4656	= { FOLLOW_FP_TO_FPR_TOK_in_indexedFunctionName4656_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4660  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4660_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4660	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4660_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4664  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4664	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4664_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_FPS_TOK_in_indexedFunctionName4680  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_FPS_TOK_in_indexedFunctionName4680_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_FPS_TOK_in_indexedFunctionName4680	= { FOLLOW_FP_TO_FPS_TOK_in_indexedFunctionName4680_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4684  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4684	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4684_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4688  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4688	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4688_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_FPU_TOK_in_indexedFunctionName4704  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_FPU_TOK_in_indexedFunctionName4704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_FPU_TOK_in_indexedFunctionName4704	= { FOLLOW_FP_TO_FPU_TOK_in_indexedFunctionName4704_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4708  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4708	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4708_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4712  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4712	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4712_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_UBV_TOK_in_indexedFunctionName4728  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_UBV_TOK_in_indexedFunctionName4728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_UBV_TOK_in_indexedFunctionName4728	= { FOLLOW_FP_TO_UBV_TOK_in_indexedFunctionName4728_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4732  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4732	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4732_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FP_TO_SBV_TOK_in_indexedFunctionName4748  */
static	ANTLR3_BITWORD FOLLOW_FP_TO_SBV_TOK_in_indexedFunctionName4748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FP_TO_SBV_TOK_in_indexedFunctionName4748	= { FOLLOW_FP_TO_SBV_TOK_in_indexedFunctionName4748_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4752  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4752	= { FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4752_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_badIndexedFunctionName_in_indexedFunctionName4768  */
static	ANTLR3_BITWORD FOLLOW_badIndexedFunctionName_in_indexedFunctionName4768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_badIndexedFunctionName_in_indexedFunctionName4768	= { FOLLOW_badIndexedFunctionName_in_indexedFunctionName4768_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_indexedFunctionName4780  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_indexedFunctionName4780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_indexedFunctionName4780	= { FOLLOW_RPAREN_TOK_in_indexedFunctionName4780_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_badIndexedFunctionName4802  */
static	ANTLR3_BITWORD FOLLOW_set_in_badIndexedFunctionName4802_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_badIndexedFunctionName4802	= { FOLLOW_set_in_badIndexedFunctionName4802_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termList4843  */
static	ANTLR3_BITWORD FOLLOW_term_in_termList4843_bits[]	= { ANTLR3_UINT64_LIT(0xFC00400240A90002), ANTLR3_UINT64_LIT(0x281602418200000F), ANTLR3_UINT64_LIT(0x0000000000087803) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termList4843	= { FOLLOW_term_in_termList4843_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_2_0_in_str4865  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_2_0_in_str4865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_2_0_in_str4865	= { FOLLOW_STRING_LITERAL_2_0_in_str4865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_2_5_in_str4877  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_2_5_in_str4877_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_2_5_in_str4877	= { FOLLOW_STRING_LITERAL_2_5_in_str4877_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_builtinOp4904  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_builtinOp4904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_builtinOp4904	= { FOLLOW_NOT_TOK_in_builtinOp4904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIES_TOK_in_builtinOp4917  */
static	ANTLR3_BITWORD FOLLOW_IMPLIES_TOK_in_builtinOp4917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIES_TOK_in_builtinOp4917	= { FOLLOW_IMPLIES_TOK_in_builtinOp4917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_builtinOp4926  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_builtinOp4926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_builtinOp4926	= { FOLLOW_AND_TOK_in_builtinOp4926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_builtinOp4939  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_builtinOp4939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_builtinOp4939	= { FOLLOW_OR_TOK_in_builtinOp4939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_XOR_TOK_in_builtinOp4953  */
static	ANTLR3_BITWORD FOLLOW_XOR_TOK_in_builtinOp4953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_XOR_TOK_in_builtinOp4953	= { FOLLOW_XOR_TOK_in_builtinOp4953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_builtinOp4966  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_builtinOp4966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_builtinOp4966	= { FOLLOW_EQUAL_TOK_in_builtinOp4966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISTINCT_TOK_in_builtinOp4977  */
static	ANTLR3_BITWORD FOLLOW_DISTINCT_TOK_in_builtinOp4977_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISTINCT_TOK_in_builtinOp4977	= { FOLLOW_DISTINCT_TOK_in_builtinOp4977_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITE_TOK_in_builtinOp4985  */
static	ANTLR3_BITWORD FOLLOW_ITE_TOK_in_builtinOp4985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITE_TOK_in_builtinOp4985	= { FOLLOW_ITE_TOK_in_builtinOp4985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_TOK_in_builtinOp4998  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_TOK_in_builtinOp4998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_TOK_in_builtinOp4998	= { FOLLOW_GREATER_THAN_TOK_in_builtinOp4998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_EQUAL_TOK_in_builtinOp5023  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_EQUAL_TOK_in_builtinOp5023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_EQUAL_TOK_in_builtinOp5023	= { FOLLOW_GREATER_THAN_EQUAL_TOK_in_builtinOp5023_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_EQUAL_TOK_in_builtinOp5048  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_EQUAL_TOK_in_builtinOp5048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_EQUAL_TOK_in_builtinOp5048	= { FOLLOW_LESS_THAN_EQUAL_TOK_in_builtinOp5048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_TOK_in_builtinOp5073  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_TOK_in_builtinOp5073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_TOK_in_builtinOp5073	= { FOLLOW_LESS_THAN_TOK_in_builtinOp5073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_TOK_in_builtinOp5098  */
static	ANTLR3_BITWORD FOLLOW_PLUS_TOK_in_builtinOp5098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_TOK_in_builtinOp5098	= { FOLLOW_PLUS_TOK_in_builtinOp5098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_TOK_in_builtinOp5110  */
static	ANTLR3_BITWORD FOLLOW_MINUS_TOK_in_builtinOp5110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_TOK_in_builtinOp5110	= { FOLLOW_MINUS_TOK_in_builtinOp5110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_TOK_in_builtinOp5121  */
static	ANTLR3_BITWORD FOLLOW_STAR_TOK_in_builtinOp5121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_TOK_in_builtinOp5121	= { FOLLOW_STAR_TOK_in_builtinOp5121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIV_TOK_in_builtinOp5133  */
static	ANTLR3_BITWORD FOLLOW_DIV_TOK_in_builtinOp5133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIV_TOK_in_builtinOp5133	= { FOLLOW_DIV_TOK_in_builtinOp5133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BV2NAT_TOK_in_builtinOp5147  */
static	ANTLR3_BITWORD FOLLOW_BV2NAT_TOK_in_builtinOp5147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BV2NAT_TOK_in_builtinOp5147	= { FOLLOW_BV2NAT_TOK_in_builtinOp5147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DTSIZE_TOK_in_builtinOp5160  */
static	ANTLR3_BITWORD FOLLOW_DTSIZE_TOK_in_builtinOp5160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DTSIZE_TOK_in_builtinOp5160	= { FOLLOW_DTSIZE_TOK_in_builtinOp5160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FMFCARD_TOK_in_builtinOp5174  */
static	ANTLR3_BITWORD FOLLOW_FMFCARD_TOK_in_builtinOp5174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FMFCARD_TOK_in_builtinOp5174	= { FOLLOW_FMFCARD_TOK_in_builtinOp5174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FMFCARDVAL_TOK_in_builtinOp5187  */
static	ANTLR3_BITWORD FOLLOW_FMFCARDVAL_TOK_in_builtinOp5187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FMFCARDVAL_TOK_in_builtinOp5187	= { FOLLOW_FMFCARDVAL_TOK_in_builtinOp5187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INST_CLOSURE_TOK_in_builtinOp5197  */
static	ANTLR3_BITWORD FOLLOW_INST_CLOSURE_TOK_in_builtinOp5197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INST_CLOSURE_TOK_in_builtinOp5197	= { FOLLOW_INST_CLOSURE_TOK_in_builtinOp5197_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_quantOp5239  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_quantOp5239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_quantOp5239	= { FOLLOW_EXISTS_TOK_in_quantOp5239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_quantOp5250  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_quantOp5250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_quantOp5250	= { FOLLOW_FORALL_TOK_in_quantOp5250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_functionName5271  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_functionName5271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_functionName5271	= { FOLLOW_symbol_in_functionName5271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sortList5295  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sortList5295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280002), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sortList5295	= { FOLLOW_sortSymbol_in_sortList5295_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_nonemptySortList5322  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_nonemptySortList5322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280002), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_nonemptySortList5322	= { FOLLOW_sortSymbol_in_nonemptySortList5322_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sortedVarList5351  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sortedVarList5351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sortedVarList5351	= { FOLLOW_LPAREN_TOK_in_sortedVarList5351_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sortedVarList5353  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sortedVarList5353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sortedVarList5353	= { FOLLOW_symbol_in_sortedVarList5353_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sortedVarList5362  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sortedVarList5362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sortedVarList5362	= { FOLLOW_sortSymbol_in_sortedVarList5362_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sortedVarList5365  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sortedVarList5365_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sortedVarList5365	= { FOLLOW_RPAREN_TOK_in_sortedVarList5365_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sortName5396  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sortName5396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sortName5396	= { FOLLOW_symbol_in_sortName5396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortName_in_sortSymbol5416  */
static	ANTLR3_BITWORD FOLLOW_sortName_in_sortSymbol5416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortName_in_sortSymbol5416	= { FOLLOW_sortName_in_sortSymbol5416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sortSymbol5429  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sortSymbol5429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000110000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sortSymbol5429	= { FOLLOW_LPAREN_TOK_in_sortSymbol5429_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDEX_TOK_in_sortSymbol5432  */
static	ANTLR3_BITWORD FOLLOW_INDEX_TOK_in_sortSymbol5432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_INDEX_TOK_in_sortSymbol5432	= { FOLLOW_INDEX_TOK_in_sortSymbol5432_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sortSymbol5445  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sortSymbol5445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2902004180000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sortSymbol5445	= { FOLLOW_symbol_in_sortSymbol5445_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonemptyNumeralList_in_sortSymbol5454  */
static	ANTLR3_BITWORD FOLLOW_nonemptyNumeralList_in_sortSymbol5454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_nonemptyNumeralList_in_sortSymbol5454	= { FOLLOW_nonemptyNumeralList_in_sortSymbol5454_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_sortSymbol5471  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_sortSymbol5471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_sortSymbol5471	= { FOLLOW_sortList_in_sortSymbol5471_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sortSymbol5488  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sortSymbol5488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sortSymbol5488	= { FOLLOW_RPAREN_TOK_in_sortSymbol5488_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_symbolList5511  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_symbolList5511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280002), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_symbolList5511	= { FOLLOW_symbol_in_symbolList5511_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLE_SYMBOL_in_symbol5533  */
static	ANTLR3_BITWORD FOLLOW_SIMPLE_SYMBOL_in_symbol5533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLE_SYMBOL_in_symbol5533	= { FOLLOW_SIMPLE_SYMBOL_in_symbol5533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_147_in_symbol5547  */
static	ANTLR3_BITWORD FOLLOW_147_in_symbol5547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_147_in_symbol5547	= { FOLLOW_147_in_symbol5547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_OPTIONS_TOK_in_symbol5563  */
static	ANTLR3_BITWORD FOLLOW_SET_OPTIONS_TOK_in_symbol5563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_OPTIONS_TOK_in_symbol5563	= { FOLLOW_SET_OPTIONS_TOK_in_symbol5563_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_VAR_TOK_in_symbol5573  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_VAR_TOK_in_symbol5573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_VAR_TOK_in_symbol5573	= { FOLLOW_DECLARE_VAR_TOK_in_symbol5573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_PRIMED_VAR_TOK_in_symbol5583  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_PRIMED_VAR_TOK_in_symbol5583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_PRIMED_VAR_TOK_in_symbol5583	= { FOLLOW_DECLARE_PRIMED_VAR_TOK_in_symbol5583_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTH_FUN_TOK_in_symbol5593  */
static	ANTLR3_BITWORD FOLLOW_SYNTH_FUN_TOK_in_symbol5593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTH_FUN_TOK_in_symbol5593	= { FOLLOW_SYNTH_FUN_TOK_in_symbol5593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTH_INV_TOK_in_symbol5603  */
static	ANTLR3_BITWORD FOLLOW_SYNTH_INV_TOK_in_symbol5603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTH_INV_TOK_in_symbol5603	= { FOLLOW_SYNTH_INV_TOK_in_symbol5603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRAINT_TOK_in_symbol5613  */
static	ANTLR3_BITWORD FOLLOW_CONSTRAINT_TOK_in_symbol5613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRAINT_TOK_in_symbol5613	= { FOLLOW_CONSTRAINT_TOK_in_symbol5613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INV_CONSTRAINT_TOK_in_symbol5623  */
static	ANTLR3_BITWORD FOLLOW_INV_CONSTRAINT_TOK_in_symbol5623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INV_CONSTRAINT_TOK_in_symbol5623	= { FOLLOW_INV_CONSTRAINT_TOK_in_symbol5623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECK_SYNTH_TOK_in_symbol5633  */
static	ANTLR3_BITWORD FOLLOW_CHECK_SYNTH_TOK_in_symbol5633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECK_SYNTH_TOK_in_symbol5633	= { FOLLOW_CHECK_SYNTH_TOK_in_symbol5633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_SYMBOL_in_symbol5653  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_SYMBOL_in_symbol5653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QUOTED_SYMBOL_in_symbol5653	= { FOLLOW_QUOTED_SYMBOL_in_symbol5653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol5665  */
static	ANTLR3_BITWORD FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol5665_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol5665	= { FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol5665_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_symbol5673  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_symbol5673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_symbol5673	= { FOLLOW_EOF_in_symbol5673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_145_in_symbol5689  */
static	ANTLR3_BITWORD FOLLOW_145_in_symbol5689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_145_in_symbol5689	= { FOLLOW_145_in_symbol5689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList5721  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList5721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList5721	= { FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList5721_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_datatypeDef5763  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_datatypeDef5763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_datatypeDef5763	= { FOLLOW_symbol_in_datatypeDef5763_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypeDef5786  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypeDef5786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypeDef5786	= { FOLLOW_LPAREN_TOK_in_datatypeDef5786_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorDef_in_datatypeDef5788  */
static	ANTLR3_BITWORD FOLLOW_constructorDef_in_datatypeDef5788_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorDef_in_datatypeDef5788	= { FOLLOW_constructorDef_in_datatypeDef5788_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypeDef5791  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypeDef5791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypeDef5791	= { FOLLOW_RPAREN_TOK_in_datatypeDef5791_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_constructorDef5821  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_constructorDef5821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_constructorDef5821	= { FOLLOW_symbol_in_constructorDef5821_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_constructorDef5836  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_constructorDef5836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802000100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_constructorDef5836	= { FOLLOW_LPAREN_TOK_in_constructorDef5836_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selector_in_constructorDef5838  */
static	ANTLR3_BITWORD FOLLOW_selector_in_constructorDef5838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_selector_in_constructorDef5838	= { FOLLOW_selector_in_constructorDef5838_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_constructorDef5841  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_constructorDef5841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_constructorDef5841	= { FOLLOW_RPAREN_TOK_in_constructorDef5841_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_selector5869  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_selector5869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240280000), ANTLR3_UINT64_LIT(0x2802004100000000), ANTLR3_UINT64_LIT(0x0000000000085800) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_selector5869	= { FOLLOW_symbol_in_selector5869_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_selector5872  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_selector5872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_selector5872	= { FOLLOW_sortSymbol_in_selector5872_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parseExpr
 * ../../../../../../src/parser/smt2/Smt2.g:193:1: parseExpr returns [CVC4::parser::smt2::myExpr expr] : ( term[expr, expr2] | EOF );
 */
static CVC4::parser::smt2::myExpr
parseExpr(pSmt2Parser ctx)
{
    CVC4::parser::smt2::myExpr expr;



      Expr expr2;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:197:3: ( term[expr, expr2] | EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case BINARY_LITERAL:
            case CHECK_SYNTH_TOK:
            case CONSTRAINT_TOK:
            case DECIMAL_LITERAL:
            case DECLARE_PRIMED_VAR_TOK:
            case DECLARE_VAR_TOK:
            case EMPTYSET_TOK:
            case FP_RNA_FULL_TOK:
            case FP_RNA_TOK:
            case FP_RNE_FULL_TOK:
            case FP_RNE_TOK:
            case FP_RTN_FULL_TOK:
            case FP_RTN_TOK:
            case FP_RTP_FULL_TOK:
            case FP_RTP_TOK:
            case FP_RTZ_FULL_TOK:
            case FP_RTZ_TOK:
            case HEX_LITERAL:
            case INTEGER_LITERAL:
            case INV_CONSTRAINT_TOK:
            case LPAREN_TOK:
            case NILREF_TOK:
            case QUOTED_SYMBOL:
            case REALLCHAR_TOK:
            case RENOSTR_TOK:
            case SET_OPTIONS_TOK:
            case SIMPLE_SYMBOL:
            case STRING_LITERAL_2_0:
            case STRING_LITERAL_2_5:
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            case UNIVSET_TOK:
            case UNTERMINATED_QUOTED_SYMBOL:
            case 147:
            	{
            		alt1=1;
            	}
                break;
            case EOF:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleparseExprEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:197:5: term[expr, expr2]
        	    {
        	        FOLLOWPUSH(FOLLOW_term_in_parseExpr119);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:198:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseExpr126);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseExprEx; /* Prevent compiler warnings */
    ruleparseExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return expr;
}
/* $ANTLR end parseExpr */

/**
 * $ANTLR start parseCommand
 * ../../../../../../src/parser/smt2/Smt2.g:205:1: parseCommand returns [CVC4::Command* cmd_return = NULL] : ( LPAREN_TOK command[&cmd] RPAREN_TOK | LPAREN_TOK INCLUDE_TOK str[name,true] RPAREN_TOK | EOF );
 */
static CVC4::Command*
parseCommand(pSmt2Parser ctx)
{
    CVC4::Command* cmd_return;



      CVC4::PtrCloser<CVC4::Command> cmd;
      std::string name;

    /* Initialize rule variables
     */
    cmd_return =  NULL;


    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:213:3: ( LPAREN_TOK command[&cmd] RPAREN_TOK | LPAREN_TOK INCLUDE_TOK str[name,true] RPAREN_TOK | EOF )

            ANTLR3_UINT32 alt2;

            alt2=3;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case INCLUDE_TOK:
            			{
            				alt2=2;
            			}
            		    break;
            		case ASSERT_TOK:
            		case CHECKSAT_TOK:
            		case DECLARE_CODATATYPES_TOK:
            		case DECLARE_CONST_TOK:
            		case DECLARE_DATATYPES_TOK:
            		case DECLARE_FUNS_TOK:
            		case DECLARE_FUN_TOK:
            		case DECLARE_PREDS_TOK:
            		case DECLARE_SORTS_TOK:
            		case DECLARE_SORT_TOK:
            		case DEFINE_CONST_TOK:
            		case DEFINE_FUNS_REC_TOK:
            		case DEFINE_FUN_REC_TOK:
            		case DEFINE_FUN_TOK:
            		case DEFINE_SORT_TOK:
            		case DEFINE_TOK:
            		case ECHO_TOK:
            		case EXIT_TOK:
            		case GET_ASSERTIONS_TOK:
            		case GET_ASSIGNMENT_TOK:
            		case GET_INFO_TOK:
            		case GET_MODEL_TOK:
            		case GET_OPTION_TOK:
            		case GET_PROOF_TOK:
            		case GET_QE_DISJUNCT_TOK:
            		case GET_QE_TOK:
            		case GET_UNSAT_CORE_TOK:
            		case GET_VALUE_TOK:
            		case META_INFO_TOK:
            		case POP_TOK:
            		case PROPAGATION_RULE_TOK:
            		case PUSH_TOK:
            		case REDUCTION_RULE_TOK:
            		case RESET_ASSERTIONS_TOK:
            		case RESET_TOK:
            		case REWRITE_RULE_TOK:
            		case SET_INFO_TOK:
            		case SET_LOGIC_TOK:
            		case SET_OPTION_TOK:
            		case SIMPLE_SYMBOL:
            		case SIMPLIFY_TOK:
            			{
            				alt2=1;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 2;
            		    EXCEPTION->state        = 1;


            		    goto ruleparseCommandEx;

            		}

            	}
                break;
            case EOF:
            	{
            		alt2=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleparseCommandEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:213:5: LPAREN_TOK command[&cmd] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand155);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_command_in_parseCommand157);
        	        command(ctx, &cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand160);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:218:5: LPAREN_TOK INCLUDE_TOK str[name,true] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand173);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(INCLUDE_TOK, &FOLLOW_INCLUDE_TOK_in_parseCommand175);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_str_in_parseCommand177);
        	        str(ctx, name, true);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand180);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             if(!PARSER_STATE->canIncludeFile()) {
        	                    PARSER_STATE->parseError("include-file feature was disabled for this "
        	                                             "run.");
        	                  }
        	                  if(PARSER_STATE->strictModeEnabled()) {
        	                    PARSER_STATE->parseError("Extended commands are not permitted while "
        	                                             "operating in strict compliance mode.");
        	                  }
        	                  PARSER_STATE->includeFile(name);
        	                  // The command of the included file will be produced at the next
        	                  // parseCommand() call
        	                  cmd.reset(new EmptyCommand("include::" + name));
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:233:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseCommand193);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseCommandEx; /* Prevent compiler warnings */
    ruleparseCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      cmd_return = cmd.release();

                }
            }


    return cmd_return;
}
/* $ANTLR end parseCommand */

/**
 * $ANTLR start parseSygus
 * ../../../../../../src/parser/smt2/Smt2.g:241:1: parseSygus returns [CVC4::Command* cmd_return = NULL] : ( LPAREN_TOK sygusCommand[&cmd] RPAREN_TOK | EOF );
 */
static CVC4::Command*
parseSygus(pSmt2Parser ctx)
{
    CVC4::Command* cmd_return;



      CVC4::PtrCloser<CVC4::Command> cmd;
      std::string name;

    /* Initialize rule variables
     */
    cmd_return =  NULL;


    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:249:3: ( LPAREN_TOK sygusCommand[&cmd] RPAREN_TOK | EOF )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt3=1;
            	}
                break;
            case EOF:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruleparseSygusEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:249:5: LPAREN_TOK sygusCommand[&cmd] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseSygus222);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sygusCommand_in_parseSygus224);
        	        sygusCommand(ctx, &cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseSygus227);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:250:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseSygus233);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseSygusEx; /* Prevent compiler warnings */
    ruleparseSygusEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      cmd_return = cmd.release();

                }
            }


    return cmd_return;
}
/* $ANTLR end parseSygus */

/**
 * $ANTLR start command
 * ../../../../../../src/parser/smt2/Smt2.g:257:1: command[CVC4::PtrCloser<CVC4::Command>* cmd] : ( SET_LOGIC_TOK symbol[name,CHECK_NONE,SYM_SORT] | SET_INFO_TOK metaInfoInternal[cmd] | GET_INFO_TOK KEYWORD | SET_OPTION_TOK setOptionInternal[cmd] | GET_OPTION_TOK KEYWORD | DECLARE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL | DEFINE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] LPAREN_TOK symbolList[names,CHECK_NONE,SYM_SORT] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] | DECLARE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortList[sorts] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] | DEFINE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] term[expr, expr2] | GET_VALUE_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK ) | GET_ASSIGNMENT_TOK | ASSERT_TOK term[expr, expr2] | CHECKSAT_TOK ( term[expr, expr2] |) | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_CORE_TOK | PUSH_TOK (k= INTEGER_LITERAL |) | POP_TOK (k= INTEGER_LITERAL |) | EXIT_TOK | smt25Command[cmd] | extendedCommand[cmd] | SIMPLE_SYMBOL );
 */
static void
command(pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{

      std::string name;
      std::vector<std::string> names;
      Expr expr, expr2;
      Type t;
      std::vector<Expr> terms;
      std::vector<Type> sorts;
      std::vector<std::pair<std::string, Type> > sortedVarNames;

    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    k;
    pANTLR3_COMMON_TOKEN    KEYWORD1;
    pANTLR3_COMMON_TOKEN    KEYWORD2;
    pANTLR3_COMMON_TOKEN    SIMPLE_SYMBOL3;

    /* Initialize rule variables
     */

    n       = NULL;
    k       = NULL;
    KEYWORD1       = NULL;
    KEYWORD2       = NULL;
    SIMPLE_SYMBOL3       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:267:3: ( SET_LOGIC_TOK symbol[name,CHECK_NONE,SYM_SORT] | SET_INFO_TOK metaInfoInternal[cmd] | GET_INFO_TOK KEYWORD | SET_OPTION_TOK setOptionInternal[cmd] | GET_OPTION_TOK KEYWORD | DECLARE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL | DEFINE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] LPAREN_TOK symbolList[names,CHECK_NONE,SYM_SORT] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] | DECLARE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortList[sorts] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] | DEFINE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] term[expr, expr2] | GET_VALUE_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK ) | GET_ASSIGNMENT_TOK | ASSERT_TOK term[expr, expr2] | CHECKSAT_TOK ( term[expr, expr2] |) | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_CORE_TOK | PUSH_TOK (k= INTEGER_LITERAL |) | POP_TOK (k= INTEGER_LITERAL |) | EXIT_TOK | smt25Command[cmd] | extendedCommand[cmd] | SIMPLE_SYMBOL )

            ANTLR3_UINT32 alt8;

            alt8=22;

            switch ( LA(1) )
            {
            case SET_LOGIC_TOK:
            	{
            		alt8=1;
            	}
                break;
            case SET_INFO_TOK:
            	{
            		alt8=2;
            	}
                break;
            case GET_INFO_TOK:
            	{
            		alt8=3;
            	}
                break;
            case SET_OPTION_TOK:
            	{
            		alt8=4;
            	}
                break;
            case GET_OPTION_TOK:
            	{
            		alt8=5;
            	}
                break;
            case DECLARE_SORT_TOK:
            	{
            		alt8=6;
            	}
                break;
            case DEFINE_SORT_TOK:
            	{
            		alt8=7;
            	}
                break;
            case DECLARE_FUN_TOK:
            	{
            		alt8=8;
            	}
                break;
            case DEFINE_FUN_TOK:
            	{
            		alt8=9;
            	}
                break;
            case GET_VALUE_TOK:
            	{
            		alt8=10;
            	}
                break;
            case GET_ASSIGNMENT_TOK:
            	{
            		alt8=11;
            	}
                break;
            case ASSERT_TOK:
            	{
            		alt8=12;
            	}
                break;
            case CHECKSAT_TOK:
            	{
            		alt8=13;
            	}
                break;
            case GET_ASSERTIONS_TOK:
            	{
            		alt8=14;
            	}
                break;
            case GET_PROOF_TOK:
            	{
            		alt8=15;
            	}
                break;
            case GET_UNSAT_CORE_TOK:
            	{
            		alt8=16;
            	}
                break;
            case PUSH_TOK:
            	{
            		alt8=17;
            	}
                break;
            case POP_TOK:
            	{
            		alt8=18;
            	}
                break;
            case EXIT_TOK:
            	{
            		alt8=19;
            	}
                break;
            case DECLARE_CONST_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case ECHO_TOK:
            case GET_MODEL_TOK:
            case META_INFO_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            	{
            		alt8=20;
            	}
                break;
            case DECLARE_CODATATYPES_TOK:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUNS_TOK:
            case DECLARE_PREDS_TOK:
            case DECLARE_SORTS_TOK:
            case DEFINE_CONST_TOK:
            case DEFINE_TOK:
            case GET_QE_DISJUNCT_TOK:
            case GET_QE_TOK:
            case PROPAGATION_RULE_TOK:
            case REDUCTION_RULE_TOK:
            case REWRITE_RULE_TOK:
            case SIMPLIFY_TOK:
            	{
            		alt8=21;
            	}
                break;
            case SIMPLE_SYMBOL:
            	{
            		alt8=22;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulecommandEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:268:5: SET_LOGIC_TOK symbol[name,CHECK_NONE,SYM_SORT]
        	    {
        	         MATCHT(SET_LOGIC_TOK, &FOLLOW_SET_LOGIC_TOK_in_command261);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command263);
        	        symbol(ctx, name, CHECK_NONE, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             Debug("parser") << "set logic: '" << name << "'" << std::endl;
        	                  if( PARSER_STATE->logicIsSet() ) {
        	                    PARSER_STATE->parseError("Only one set-logic is allowed.");
        	                  }
        	                  PARSER_STATE->setLogic(name);
        	                  if( PARSER_STATE->sygus() ){
        	                    cmd->reset(new SetBenchmarkLogicCommand("ALL"));
        	                  }else{
        	                    cmd->reset(new SetBenchmarkLogicCommand(name));
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:281:5: SET_INFO_TOK metaInfoInternal[cmd]
        	    {
        	         MATCHT(SET_INFO_TOK, &FOLLOW_SET_INFO_TOK_in_command282);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_metaInfoInternal_in_command284);
        	        metaInfoInternal(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:283:5: GET_INFO_TOK KEYWORD
        	    {
        	         MATCHT(GET_INFO_TOK, &FOLLOW_GET_INFO_TOK_in_command297);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        KEYWORD1 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_command299);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             cmd->reset(new GetInfoCommand(
        	                      AntlrInput::tokenText(KEYWORD1).c_str() + 1));
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:288:5: SET_OPTION_TOK setOptionInternal[cmd]
        	    {
        	         MATCHT(SET_OPTION_TOK, &FOLLOW_SET_OPTION_TOK_in_command317);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_setOptionInternal_in_command319);
        	        setOptionInternal(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:290:5: GET_OPTION_TOK KEYWORD
        	    {
        	         MATCHT(GET_OPTION_TOK, &FOLLOW_GET_OPTION_TOK_in_command332);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        KEYWORD2 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_command334);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             cmd->reset(new GetOptionCommand(
        	                      AntlrInput::tokenText(KEYWORD2).c_str() + 1));
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:295:5: DECLARE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL
        	    {
        	         MATCHT(DECLARE_SORT_TOK, &FOLLOW_DECLARE_SORT_TOK_in_command352);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             if(!PARSER_STATE->isTheoryEnabled(Smt2::THEORY_UF) &&
        	                     !PARSER_STATE->isTheoryEnabled(Smt2::THEORY_ARRAYS) &&
        	                     !PARSER_STATE->isTheoryEnabled(Smt2::THEORY_DATATYPES) &&
        	                     !PARSER_STATE->isTheoryEnabled(Smt2::THEORY_SETS)) {
        	                      PARSER_STATE->parseErrorLogic("Free sort symbols not allowed in ");
        	                  }
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command366);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_command381);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             Debug("parser") << "declare sort: '" << name
        	                                  << "' arity=" << n << std::endl;
        	                  unsigned arity = AntlrInput::tokenToUnsigned(n);
        	                  if(arity == 0) {
        	                    Type type = PARSER_STATE->mkSort(name);
        	                    cmd->reset(new DeclareTypeCommand(name, 0, type));
        	                  } else {
        	                    Type type = PARSER_STATE->mkSortConstructor(name, arity);
        	                    cmd->reset(new DeclareTypeCommand(name, arity, type));
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/smt2/Smt2.g:318:5: DEFINE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] LPAREN_TOK symbolList[names,CHECK_NONE,SYM_SORT] RPAREN_TOK sortSymbol[t,CHECK_DECLARED]
        	    {
        	         MATCHT(DEFINE_SORT_TOK, &FOLLOW_DEFINE_SORT_TOK_in_command399);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command407);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command420);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbolList_in_command422);
        	        symbolList(ctx, names, CHECK_NONE, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command425);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(true);
        	                  for(std::vector<std::string>::const_iterator i = names.begin(),
        	                        iend = names.end();
        	                      i != iend;
        	                      ++i) {
        	                    sorts.push_back(PARSER_STATE->mkSort(*i));
        	                  }
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_command437);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  // Do NOT call mkSort, since that creates a new sort!
        	                  // This name is not its own distinct sort, it's an alias.
        	                  PARSER_STATE->defineParameterizedType(name, sorts, t);
        	                  cmd->reset(new DefineTypeCommand(name, sorts, t));
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/smt2/Smt2.g:338:5: DECLARE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortList[sorts] RPAREN_TOK sortSymbol[t,CHECK_DECLARED]
        	    {
        	         MATCHT(DECLARE_FUN_TOK, &FOLLOW_DECLARE_FUN_TOK_in_command456);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command464);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command477);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortList_in_command479);
        	        sortList(ctx, sorts);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command482);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_command488);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             Debug("parser") << "declare fun: '" << name << "'" << std::endl;
        	                  if( sorts.size() > 0 ) {
        	                    if(!PARSER_STATE->isTheoryEnabled(Smt2::THEORY_UF)) {
        	                      PARSER_STATE->parseErrorLogic("Functions (of non-zero arity) cannot "
        	                                                    "be declared in logic ");
        	                    }
        	                    t = EXPR_MANAGER->mkFunctionType(sorts, t);
        	                  }
        	                  Expr func = PARSER_STATE->mkVar(name, t);
        	                  cmd->reset(new DeclareFunctionCommand(name, func, t));
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/smt2/Smt2.g:355:5: DEFINE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] term[expr, expr2]
        	    {
        	         MATCHT(DEFINE_FUN_TOK, &FOLLOW_DEFINE_FUN_TOK_in_command507);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command515);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command528);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_command530);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command533);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_command539);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             /* add variables to parser state before parsing term */
        	                  Debug("parser") << "define fun: '" << name << "'" << std::endl;
        	                  if( sortedVarNames.size() > 0 ) {
        	                    std::vector<CVC4::Type> sorts;
        	                    sorts.reserve(sortedVarNames.size());
        	                    for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                          sortedVarNames.begin(), iend = sortedVarNames.end();
        	                        i != iend;
        	                        ++i) {
        	                      sorts.push_back((*i).second);
        	                    }
        	                    t = EXPR_MANAGER->mkFunctionType(sorts, t);
        	                  }
        	                  PARSER_STATE->pushScope(true);
        	                  for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                        sortedVarNames.begin(), iend = sortedVarNames.end();
        	                      i != iend;
        	                      ++i) {
        	                    terms.push_back(PARSER_STATE->mkBoundVar((*i).first, (*i).second));
        	                  }
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_command552);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  // declare the name down here (while parsing term, signature
        	                  // must not be extended with the name itself; no recursion
        	                  // permitted)
        	                  Expr func = PARSER_STATE->mkFunction(name, t,
        	                                                       ExprManager::VAR_FLAG_DEFINED);
        	                  cmd->reset(new DefineFunctionCommand(name, func, terms, expr));
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/smt2/Smt2.g:391:5: GET_VALUE_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK )
        	    {
        	         MATCHT(GET_VALUE_TOK, &FOLLOW_GET_VALUE_TOK_in_command571);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:392:5: ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK )
        	        {
        	            int alt4=2;
        	            switch ( LA(1) )
        	            {
        	            case LPAREN_TOK:
        	            	{
        	            		alt4=1;
        	            	}
        	                break;
        	            case ALPHA:
        	            case AMPERSAND_TOK:
        	            case AND_TOK:
        	            case ASSERT_TOK:
        	            case AS_TOK:
        	            case ATTRIBUTE_INST_LEVEL:
        	            case ATTRIBUTE_NAMED_TOK:
        	            case ATTRIBUTE_NO_PATTERN_TOK:
        	            case ATTRIBUTE_PATTERN_TOK:
        	            case ATTRIBUTE_RR_PRIORITY:
        	            case ATTRIBUTE_TOK:
        	            case AT_TOK:
        	            case BINARY_LITERAL:
        	            case BV2NAT_TOK:
        	            case CHECKSAT_TOK:
        	            case CHECK_SYNTH_TOK:
        	            case COMMENT:
        	            case CONSTRAINT_TOK:
        	            case CONST_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_CODATATYPES_TOK:
        	            case DECLARE_CONST_TOK:
        	            case DECLARE_DATATYPES_TOK:
        	            case DECLARE_FUNS_TOK:
        	            case DECLARE_FUN_TOK:
        	            case DECLARE_PREDS_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_SORTS_TOK:
        	            case DECLARE_SORT_TOK:
        	            case DECLARE_VAR_TOK:
        	            case DEFINE_CONST_TOK:
        	            case DEFINE_FUNS_REC_TOK:
        	            case DEFINE_FUN_REC_TOK:
        	            case DEFINE_FUN_TOK:
        	            case DEFINE_SORT_TOK:
        	            case DEFINE_TOK:
        	            case DIGIT:
        	            case DISTINCT_TOK:
        	            case DIVISIBLE_TOK:
        	            case DIV_TOK:
        	            case DTSIZE_TOK:
        	            case ECHO_TOK:
        	            case EMPTYSET_TOK:
        	            case EQUAL_TOK:
        	            case EXISTS_TOK:
        	            case EXIT_TOK:
        	            case FMFCARDVAL_TOK:
        	            case FMFCARD_TOK:
        	            case FORALL_TOK:
        	            case FP_NAN_TOK:
        	            case FP_NINF_TOK:
        	            case FP_NZERO_TOK:
        	            case FP_PINF_TOK:
        	            case FP_PZERO_TOK:
        	            case FP_RNA_FULL_TOK:
        	            case FP_RNA_TOK:
        	            case FP_RNE_FULL_TOK:
        	            case FP_RNE_TOK:
        	            case FP_RTN_FULL_TOK:
        	            case FP_RTN_TOK:
        	            case FP_RTP_FULL_TOK:
        	            case FP_RTP_TOK:
        	            case FP_RTZ_FULL_TOK:
        	            case FP_RTZ_TOK:
        	            case FP_TO_FPBV_TOK:
        	            case FP_TO_FPFP_TOK:
        	            case FP_TO_FPR_TOK:
        	            case FP_TO_FPS_TOK:
        	            case FP_TO_FPU_TOK:
        	            case FP_TO_FP_TOK:
        	            case FP_TO_SBV_TOK:
        	            case FP_TO_UBV_TOK:
        	            case GET_ASSERTIONS_TOK:
        	            case GET_ASSIGNMENT_TOK:
        	            case GET_INFO_TOK:
        	            case GET_MODEL_TOK:
        	            case GET_OPTION_TOK:
        	            case GET_PROOF_TOK:
        	            case GET_QE_DISJUNCT_TOK:
        	            case GET_QE_TOK:
        	            case GET_UNSAT_CORE_TOK:
        	            case GET_VALUE_TOK:
        	            case GREATER_THAN_EQUAL_TOK:
        	            case GREATER_THAN_TOK:
        	            case HEX_DIGIT:
        	            case HEX_LITERAL:
        	            case IMPLIES_TOK:
        	            case INCLUDE_TOK:
        	            case INDEX_TOK:
        	            case INST_CLOSURE_TOK:
        	            case INT2BV_TOK:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case ITE_TOK:
        	            case KEYWORD:
        	            case LESS_THAN_EQUAL_TOK:
        	            case LESS_THAN_TOK:
        	            case LET_TOK:
        	            case META_INFO_TOK:
        	            case MINUS_TOK:
        	            case NILREF_TOK:
        	            case NOT_TOK:
        	            case NUMERAL:
        	            case OR_TOK:
        	            case PLUS_TOK:
        	            case POP_TOK:
        	            case PROPAGATION_RULE_TOK:
        	            case PUSH_TOK:
        	            case QUOTED_SYMBOL:
        	            case REALLCHAR_TOK:
        	            case REDUCTION_RULE_TOK:
        	            case RENOSTR_TOK:
        	            case RESET_ASSERTIONS_TOK:
        	            case RESET_TOK:
        	            case REWRITE_RULE_TOK:
        	            case RPAREN_TOK:
        	            case SET_INFO_TOK:
        	            case SET_LOGIC_TOK:
        	            case SET_OPTIONS_TOK:
        	            case SET_OPTION_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SIMPLIFY_TOK:
        	            case STAR_TOK:
        	            case STRING_LITERAL_2_0:
        	            case STRING_LITERAL_2_5:
        	            case SYGUS_CONSTANT_TOK:
        	            case SYGUS_ENUM_CONS_TOK:
        	            case SYGUS_ENUM_TOK:
        	            case SYGUS_INPUT_VARIABLE_TOK:
        	            case SYGUS_LOCAL_VARIABLE_TOK:
        	            case SYGUS_QUOTED_LITERAL:
        	            case SYGUS_VARIABLE_TOK:
        	            case SYMBOL_CHAR:
        	            case SYMBOL_CHAR_NOUNDERSCORE_NOATTRIBUTE:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNIVSET_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case WHITESPACE:
        	            case XOR_TOK:
        	            case 145:
        	            case 146:
        	            case 147:
        	            case 148:
        	            case 149:
        	            case 150:
        	            case 151:
        	            	{
        	            		alt4=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 4;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:392:7: LPAREN_TOK termList[terms,expr] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command581);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_termList_in_command583);
        	        	        termList(ctx, terms, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command586);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             cmd->reset(new GetValueCommand(terms)); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:394:7: ~ LPAREN_TOK
        	        	    {
        	        	        if ( ((LA(1) >= ALPHA) && (LA(1) <= LET_TOK)) || ((LA(1) >= META_INFO_TOK) && (LA(1) <= 151)) )
        	        	        {
        	        	            CONSUME();
        	        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        	        }
        	        	        else
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	        	            EXCEPTION->expectingSet = NULL;

        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->parseError("The get-value command expects a list of "
        	        	                                             "terms.  Perhaps you forgot a pair of "
        	        	                                             "parentheses?");
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/smt2/Smt2.g:401:5: GET_ASSIGNMENT_TOK
        	    {
        	         MATCHT(GET_ASSIGNMENT_TOK, &FOLLOW_GET_ASSIGNMENT_TOK_in_command629);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetAssignmentCommand()); 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/smt2/Smt2.g:404:5: ASSERT_TOK term[expr, expr2]
        	    {
        	         MATCHT(ASSERT_TOK, &FOLLOW_ASSERT_TOK_in_command649);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             PARSER_STATE->clearLastNamedTerm(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_command669);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             bool inUnsatCore = PARSER_STATE->lastNamedTerm().first == expr;
        	                  cmd->reset(new AssertCommand(expr, inUnsatCore));
        	                  if(inUnsatCore) {
        	                    PARSER_STATE->registerUnsatCoreName(PARSER_STATE->lastNamedTerm());
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/smt2/Smt2.g:418:5: CHECKSAT_TOK ( term[expr, expr2] |)
        	    {
        	         MATCHT(CHECKSAT_TOK, &FOLLOW_CHECKSAT_TOK_in_command688);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             if( PARSER_STATE->sygus() ){
        	                    PARSER_STATE->parseError("Sygus does not support check-sat command.");
        	                  }
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:423:5: ( term[expr, expr2] |)
        	        {
        	            int alt5=2;
        	            switch ( LA(1) )
        	            {
        	            case BINARY_LITERAL:
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_VAR_TOK:
        	            case EMPTYSET_TOK:
        	            case FP_RNA_FULL_TOK:
        	            case FP_RNA_TOK:
        	            case FP_RNE_FULL_TOK:
        	            case FP_RNE_TOK:
        	            case FP_RTN_FULL_TOK:
        	            case FP_RTN_TOK:
        	            case FP_RTP_FULL_TOK:
        	            case FP_RTP_TOK:
        	            case FP_RTZ_FULL_TOK:
        	            case FP_RTZ_TOK:
        	            case HEX_LITERAL:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case LPAREN_TOK:
        	            case NILREF_TOK:
        	            case QUOTED_SYMBOL:
        	            case REALLCHAR_TOK:
        	            case RENOSTR_TOK:
        	            case SET_OPTIONS_TOK:
        	            case SIMPLE_SYMBOL:
        	            case STRING_LITERAL_2_0:
        	            case STRING_LITERAL_2_5:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNIVSET_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case 147:
        	            	{
        	            		alt5=1;
        	            	}
        	                break;
        	            case RPAREN_TOK:
        	            	{
        	            		alt5=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 5;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt5)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:423:7: term[expr, expr2]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_term_in_command704);
        	        	        term(ctx, expr, expr2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             if(PARSER_STATE->strictModeEnabled()) {
        	        	                      PARSER_STATE->parseError(
        	        	                          "Extended commands (such as check-sat with an argument) are not "
        	        	                          "permitted while operating in strict compliance mode.");
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:430:7: 
        	        	    {
        	        	        {
        	        	             expr = MK_CONST(bool(true)); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             cmd->reset(new CheckSatCommand(expr)); 
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../../../src/parser/smt2/Smt2.g:434:5: GET_ASSERTIONS_TOK
        	    {
        	         MATCHT(GET_ASSERTIONS_TOK, &FOLLOW_GET_ASSERTIONS_TOK_in_command745);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetAssertionsCommand()); 
        	        }


        	    }
        	    break;
        	case 15:
        	    // ../../../../../../src/parser/smt2/Smt2.g:437:5: GET_PROOF_TOK
        	    {
        	         MATCHT(GET_PROOF_TOK, &FOLLOW_GET_PROOF_TOK_in_command765);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetProofCommand()); 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../../../src/parser/smt2/Smt2.g:440:5: GET_UNSAT_CORE_TOK
        	    {
        	         MATCHT(GET_UNSAT_CORE_TOK, &FOLLOW_GET_UNSAT_CORE_TOK_in_command785);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetUnsatCoreCommand(PARSER_STATE->getUnsatCoreNames())); 
        	        }


        	    }
        	    break;
        	case 17:
        	    // ../../../../../../src/parser/smt2/Smt2.g:443:5: PUSH_TOK (k= INTEGER_LITERAL |)
        	    {
        	         MATCHT(PUSH_TOK, &FOLLOW_PUSH_TOK_in_command805);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             if( PARSER_STATE->sygus() ){
        	                    PARSER_STATE->parseError("Sygus does not support push command.");
        	                  }
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:448:5: (k= INTEGER_LITERAL |)
        	        {
        	            int alt6=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt6=1;
        	            	}
        	                break;
        	            case RPAREN_TOK:
        	            	{
        	            		alt6=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 6;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt6)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:448:7: k= INTEGER_LITERAL
        	        	    {
        	        	        k = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_command823);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             unsigned n = AntlrInput::tokenToUnsigned(k);
        	        	                    if(n == 0) {
        	        	                      cmd->reset(new EmptyCommand());
        	        	                    } else if(n == 1) {
        	        	                      PARSER_STATE->pushScope();
        	        	                      PARSER_STATE->pushUnsatCoreNameScope();
        	        	                      cmd->reset(new PushCommand());
        	        	                    } else {
        	        	                      CVC4::PtrCloser<CommandSequence> seq(new CommandSequence());
        	        	                      do {
        	        	                        PARSER_STATE->pushScope();
        	        	                        PARSER_STATE->pushUnsatCoreNameScope();
        	        	                        Command* push_cmd = new PushCommand();
        	        	                        push_cmd->setMuted(n > 1);
        	        	                        seq->addCommand(push_cmd);
        	        	                        --n;
        	        	                        } while(n > 0);
        	        	                      cmd->reset(seq.release());
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:469:7: 
        	        	    {
        	        	        {
        	        	             if(PARSER_STATE->strictModeEnabled()) {
        	        	                      PARSER_STATE->parseError(
        	        	                          "Strict compliance mode demands an integer to be provided to "
        	        	                          "PUSH.  Maybe you want (push 1)?");
        	        	                    } else {
        	        	                      PARSER_STATE->pushScope();
        	        	                      PARSER_STATE->pushUnsatCoreNameScope();
        	        	                      cmd->reset(new PushCommand());
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 18:
        	    // ../../../../../../src/parser/smt2/Smt2.g:479:5: POP_TOK (k= INTEGER_LITERAL |)
        	    {
        	         MATCHT(POP_TOK, &FOLLOW_POP_TOK_in_command847);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             if( PARSER_STATE->sygus() ){
        	                    PARSER_STATE->parseError("Sygus does not support pop command.");
        	                  }
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:484:5: (k= INTEGER_LITERAL |)
        	        {
        	            int alt7=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt7=1;
        	            	}
        	                break;
        	            case RPAREN_TOK:
        	            	{
        	            		alt7=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 7;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt7)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:484:7: k= INTEGER_LITERAL
        	        	    {
        	        	        k = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_command865);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             unsigned n = AntlrInput::tokenToUnsigned(k);
        	        	                    if(n > PARSER_STATE->scopeLevel()) {
        	        	                      PARSER_STATE->parseError("Attempted to pop above the top stack "
        	        	                                               "frame.");
        	        	                    }
        	        	                    if(n == 0) {
        	        	                      cmd->reset(new EmptyCommand());
        	        	                    } else if(n == 1) {
        	        	                      PARSER_STATE->popUnsatCoreNameScope();
        	        	                      PARSER_STATE->popScope();
        	        	                      cmd->reset(new PopCommand());
        	        	                    } else {
        	        	                      CVC4::PtrCloser<CommandSequence> seq(new CommandSequence());
        	        	                      do {
        	        	                        PARSER_STATE->popUnsatCoreNameScope();
        	        	                        PARSER_STATE->popScope();
        	        	                        Command* pop_command = new PopCommand();
        	        	                        pop_command->setMuted(n > 1);
        	        	                        seq->addCommand(pop_command);
        	        	                        --n;
        	        	                      } while(n > 0);
        	        	                      cmd->reset(seq.release());
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:509:7: 
        	        	    {
        	        	        {
        	        	             if(PARSER_STATE->strictModeEnabled()) {
        	        	                      PARSER_STATE->parseError(
        	        	                          "Strict compliance mode demands an integer to be provided to POP."
        	        	                          "Maybe you want (pop 1)?");
        	        	                    } else {
        	        	                      PARSER_STATE->popUnsatCoreNameScope();
        	        	                      PARSER_STATE->popScope();
        	        	                      cmd->reset(new PopCommand());
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 19:
        	    // ../../../../../../src/parser/smt2/Smt2.g:521:5: EXIT_TOK
        	    {
        	         MATCHT(EXIT_TOK, &FOLLOW_EXIT_TOK_in_command899);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             cmd->reset(new QuitCommand()); 
        	        }


        	    }
        	    break;
        	case 20:
        	    // ../../../../../../src/parser/smt2/Smt2.g:525:5: smt25Command[cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_smt25Command_in_command918);
        	        smt25Command(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             if(PARSER_STATE->v2_0() && PARSER_STATE->strictModeEnabled()) {
        	                    PARSER_STATE->parseError(
        	                        "SMT-LIB 2.5 commands are not permitted while operating in strict "
        	                        "compliance mode and in SMT-LIB 2.0 mode.");
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 21:
        	    // ../../../../../../src/parser/smt2/Smt2.g:534:5: extendedCommand[cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_extendedCommand_in_command938);
        	        extendedCommand(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             if(PARSER_STATE->strictModeEnabled()) {
        	                    PARSER_STATE->parseError(
        	                        "Extended commands are not permitted while operating in strict "
        	                        "compliance mode.");
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 22:
        	    // ../../../../../../src/parser/smt2/Smt2.g:543:5: SIMPLE_SYMBOL
        	    {
        	        SIMPLE_SYMBOL3 = (pANTLR3_COMMON_TOKEN) MATCHT(SIMPLE_SYMBOL, &FOLLOW_SIMPLE_SYMBOL_in_command958);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             std::string id = AntlrInput::tokenText(SIMPLE_SYMBOL3);
        	                  if(id == "benchmark") {
        	                    PARSER_STATE->parseError(
        	                        "In SMT-LIBv2 mode, but got something that looks like SMT-LIBv1. "
        	                        "Use --lang smt1 for SMT-LIBv1.");
        	                  } else {
        	                    PARSER_STATE->parseError("expected SMT-LIBv2 command, got `" + id +
        	                                             "'.");
        	                  }
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecommandEx; /* Prevent compiler warnings */
    rulecommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end command */

/**
 * $ANTLR start sygusCommand
 * ../../../../../../src/parser/smt2/Smt2.g:556:1: sygusCommand[CVC4::PtrCloser<CVC4::Command>* cmd] : ( DECLARE_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] | DECLARE_PRIMED_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] | ( SYNTH_FUN_TOK | SYNTH_INV_TOK ) symbol[fun,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK ( sortSymbol[range,CHECK_DECLARED] )? ( LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] LPAREN_TOK ( sygusGTerm[ sgts.back().back(), fun] )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK )? | CONSTRAINT_TOK term[expr, expr2] | INV_CONSTRAINT_TOK ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+ | CHECK_SYNTH_TOK | command[cmd] );
 */
static void
sygusCommand(pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{

      std::string name, fun;
      std::vector<std::string> names;
      Expr expr, expr2;
      Type t, range;
      std::vector<Expr> terms;
      std::vector<Type> sorts;
      std::vector<Expr> sygus_vars;
      std::vector<std::pair<std::string, Type> > sortedVarNames;
      SExpr sexpr;
      CVC4::PtrCloser<CVC4::CommandSequence> seq;
      std::vector< std::vector< CVC4::SygusGTerm > > sgts;
      std::vector< CVC4::Datatype > datatypes;
      std::vector< std::vector<Expr> > ops;
      std::vector< std::vector< std::string > > cnames;
      std::vector< std::vector< std::vector< CVC4::Type > > > cargs;
      std::vector< bool > allow_const;
      std::vector< std::vector< std::string > > unresolved_gterm_sym;
      bool read_syntax = false;
      Type sygus_ret;
      std::map< CVC4::Type, CVC4::Type > sygus_to_builtin;
      std::map< CVC4::Type, CVC4::Expr > sygus_to_builtin_expr;
      int startIndex = -1;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:581:3: ( DECLARE_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] | DECLARE_PRIMED_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] | ( SYNTH_FUN_TOK | SYNTH_INV_TOK ) symbol[fun,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK ( sortSymbol[range,CHECK_DECLARED] )? ( LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] LPAREN_TOK ( sygusGTerm[ sgts.back().back(), fun] )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK )? | CONSTRAINT_TOK term[expr, expr2] | INV_CONSTRAINT_TOK ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+ | CHECK_SYNTH_TOK | command[cmd] )

            ANTLR3_UINT32 alt15;

            alt15=7;

            switch ( LA(1) )
            {
            case DECLARE_VAR_TOK:
            	{
            		alt15=1;
            	}
                break;
            case DECLARE_PRIMED_VAR_TOK:
            	{
            		alt15=2;
            	}
                break;
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            	{
            		alt15=3;
            	}
                break;
            case CONSTRAINT_TOK:
            	{
            		alt15=4;
            	}
                break;
            case INV_CONSTRAINT_TOK:
            	{
            		alt15=5;
            	}
                break;
            case CHECK_SYNTH_TOK:
            	{
            		alt15=6;
            	}
                break;
            case ASSERT_TOK:
            case CHECKSAT_TOK:
            case DECLARE_CODATATYPES_TOK:
            case DECLARE_CONST_TOK:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUNS_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_PREDS_TOK:
            case DECLARE_SORTS_TOK:
            case DECLARE_SORT_TOK:
            case DEFINE_CONST_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case DEFINE_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_INFO_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_QE_DISJUNCT_TOK:
            case GET_QE_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case META_INFO_TOK:
            case POP_TOK:
            case PROPAGATION_RULE_TOK:
            case PUSH_TOK:
            case REDUCTION_RULE_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case REWRITE_RULE_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTION_TOK:
            case SIMPLE_SYMBOL:
            case SIMPLIFY_TOK:
            	{
            		alt15=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto rulesygusCommandEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:582:5: DECLARE_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED]
        	    {
        	         MATCHT(DECLARE_VAR_TOK, &FOLLOW_DECLARE_VAR_TOK_in_sygusCommand990);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand998);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusCommand1011);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->mkSygusVar(name, t);
        	                  cmd->reset(new EmptyCommand());
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:590:5: DECLARE_PRIMED_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED]
        	    {
        	         MATCHT(DECLARE_PRIMED_VAR_TOK, &FOLLOW_DECLARE_PRIMED_VAR_TOK_in_sygusCommand1030);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand1038);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusCommand1051);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->mkSygusVar(name, t, true);
        	                  cmd->reset(new EmptyCommand());
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:599:5: ( SYNTH_FUN_TOK | SYNTH_INV_TOK ) symbol[fun,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK ( sortSymbol[range,CHECK_DECLARED] )? ( LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] LPAREN_TOK ( sygusGTerm[ sgts.back().back(), fun] )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK )?
        	    {
        	        // ../../../../../../src/parser/smt2/Smt2.g:599:5: ( SYNTH_FUN_TOK | SYNTH_INV_TOK )
        	        {
        	            int alt9=2;
        	            switch ( LA(1) )
        	            {
        	            case SYNTH_FUN_TOK:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;
        	            case SYNTH_INV_TOK:
        	            	{
        	            		alt9=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 9;
        	                EXCEPTION->state        = 0;


        	                goto rulesygusCommandEx;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:599:7: SYNTH_FUN_TOK
        	        	    {
        	        	         MATCHT(SYNTH_FUN_TOK, &FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1073);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:599:23: SYNTH_INV_TOK
        	        	    {
        	        	         MATCHT(SYNTH_INV_TOK, &FOLLOW_SYNTH_INV_TOK_in_sygusCommand1077);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	        {
        	        	             range = EXPR_MANAGER->booleanType(); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand1093);
        	        symbol(ctx, fun, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusCommand1100);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_sygusCommand1102);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusCommand1105);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             seq.reset(new CommandSequence());
        	                  PARSER_STATE->pushScope(true);
        	                  for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                        sortedVarNames.begin(), iend = sortedVarNames.end(); i != iend;
        	                      ++i) {
        	                    Expr v = PARSER_STATE->mkBoundVar((*i).first, (*i).second);
        	                    terms.push_back( v );
        	                    sygus_vars.push_back( v );
        	                  }
        	                  Expr bvl;
        	                  if( !terms.empty() ){
        	                    bvl = MK_EXPR(kind::BOUND_VAR_LIST, terms);
        	                  }
        	                  terms.clear();
        	                  terms.push_back(bvl);
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:619:5: ( sortSymbol[range,CHECK_DECLARED] )?
        	        {
        	            int alt10=2;
        	            switch ( LA(1) )
        	            {
        	                case CHECK_SYNTH_TOK:
        	                case CONSTRAINT_TOK:
        	                case DECLARE_PRIMED_VAR_TOK:
        	                case DECLARE_VAR_TOK:
        	                case INV_CONSTRAINT_TOK:
        	                case QUOTED_SYMBOL:
        	                case SET_OPTIONS_TOK:
        	                case SIMPLE_SYMBOL:
        	                case SYNTH_FUN_TOK:
        	                case SYNTH_INV_TOK:
        	                case UNTERMINATED_QUOTED_SYMBOL:
        	                case 147:
        	                	{
        	                		alt10=1;
        	                	}
        	                    break;
        	                case LPAREN_TOK:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case CHECK_SYNTH_TOK:
        	                		    case CONSTRAINT_TOK:
        	                		    case DECLARE_PRIMED_VAR_TOK:
        	                		    case DECLARE_VAR_TOK:
        	                		    case INDEX_TOK:
        	                		    case INV_CONSTRAINT_TOK:
        	                		    case QUOTED_SYMBOL:
        	                		    case SET_OPTIONS_TOK:
        	                		    case SIMPLE_SYMBOL:
        	                		    case SYNTH_FUN_TOK:
        	                		    case SYNTH_INV_TOK:
        	                		    case UNTERMINATED_QUOTED_SYMBOL:
        	                		    case 147:
        	                		    	{
        	                		    		alt10=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:619:7: sortSymbol[range,CHECK_DECLARED]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusCommand1119);
        	        	        sortSymbol(ctx, range, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  if( range.isNull() ){
        	                    PARSER_STATE->parseError("Must supply return type for synth-fun.");
        	                  }
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:624:5: ( LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] LPAREN_TOK ( sygusGTerm[ sgts.back().back(), fun] )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK )?
        	        {
        	            int alt13=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt13=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:624:7: LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] LPAREN_TOK ( sygusGTerm[ sgts.back().back(), fun] )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusCommand1133);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	        // ../../../../../../src/parser/smt2/Smt2.g:625:5: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] LPAREN_TOK ( sygusGTerm[ sgts.back().back(), fun] )+ RPAREN_TOK RPAREN_TOK )+
        	        	        {
        	        	            int cnt12=0;

        	        	            for (;;)
        	        	            {
        	        	                int alt12=2;
        	        	        	switch ( LA(1) )
        	        	        	{
        	        	        	case LPAREN_TOK:
        	        	        		{
        	        	        			alt12=1;
        	        	        		}
        	        	        	    break;

        	        	        	}

        	        	        	switch (alt12)
        	        	        	{
        	        	        	    case 1:
        	        	        	        // ../../../../../../src/parser/smt2/Smt2.g:625:7: LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] LPAREN_TOK ( sygusGTerm[ sgts.back().back(), fun] )+ RPAREN_TOK RPAREN_TOK
        	        	        	        {
        	        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusCommand1141);
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusCommandEx;
        	        	        	            }


        	        	        	            FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand1149);
        	        	        	            symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	        	            FOLLOWPOP();
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusCommandEx;
        	        	        	            }


        	        	        	            FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusCommand1159);
        	        	        	            sortSymbol(ctx, t, CHECK_DECLARED);

        	        	        	            FOLLOWPOP();
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusCommandEx;
        	        	        	            }


        	        	        	            {
        	        	        	                 std::stringstream ss;
        	        	        	                        ss << fun << "_" << name;
        	        	        	                        if( name=="Start" ){
        	        	        	                          startIndex = datatypes.size();
        	        	        	                        }
        	        	        	                        std::string dname = ss.str();
        	        	        	                        sgts.push_back( std::vector< CVC4::SygusGTerm >() );
        	        	        	                        sgts.back().push_back( CVC4::SygusGTerm() );
        	        	        	                        PARSER_STATE->pushSygusDatatypeDef(
        	        	        	                            t, dname, datatypes, sorts, ops, cnames, cargs, allow_const,
        	        	        	                            unresolved_gterm_sym);
        	        	        	                        Type unres_t;
        	        	        	                        if(!PARSER_STATE->isUnresolvedType(dname)) {
        	        	        	                          // if not unresolved, must be undeclared
        	        	        	                          Debug("parser-sygus") << "Make unresolved type : " << dname
        	        	        	                                                << std::endl;
        	        	        	                          PARSER_STATE->checkDeclaration(dname, CHECK_UNDECLARED, SYM_SORT);
        	        	        	                          unres_t = PARSER_STATE->mkUnresolvedType(dname);
        	        	        	                        }else{
        	        	        	                          Debug("parser-sygus") << "Get sort : " << dname << std::endl;
        	        	        	                          unres_t = PARSER_STATE->getSort(dname);
        	        	        	                        }
        	        	        	                        sygus_to_builtin[unres_t] = t;
        	        	        	                        Debug("parser-sygus") << "--- Read sygus grammar " << name
        	        	        	                                              << " under function " << fun << "..."
        	        	        	                                              << std::endl
        	        	        	                                              << "    type to resolve " << unres_t << std::endl
        	        	        	                                              << "    builtin type " << t << std::endl;
        	        	        	                      
        	        	        	            }


        	        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusCommand1190);
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusCommandEx;
        	        	        	            }


        	        	        	            // ../../../../../../src/parser/smt2/Smt2.g:659:18: ( sygusGTerm[ sgts.back().back(), fun] )+
        	        	        	            {
        	        	        	                int cnt11=0;

        	        	        	                for (;;)
        	        	        	                {
        	        	        	                    int alt11=2;
        	        	        	            	switch ( LA(1) )
        	        	        	            	{
        	        	        	            	case BINARY_LITERAL:
        	        	        	            	case CHECK_SYNTH_TOK:
        	        	        	            	case CONSTRAINT_TOK:
        	        	        	            	case DECLARE_PRIMED_VAR_TOK:
        	        	        	            	case DECLARE_VAR_TOK:
        	        	        	            	case HEX_LITERAL:
        	        	        	            	case INTEGER_LITERAL:
        	        	        	            	case INV_CONSTRAINT_TOK:
        	        	        	            	case LPAREN_TOK:
        	        	        	            	case QUOTED_SYMBOL:
        	        	        	            	case SET_OPTIONS_TOK:
        	        	        	            	case SIMPLE_SYMBOL:
        	        	        	            	case STRING_LITERAL_2_0:
        	        	        	            	case STRING_LITERAL_2_5:
        	        	        	            	case SYNTH_FUN_TOK:
        	        	        	            	case SYNTH_INV_TOK:
        	        	        	            	case UNTERMINATED_QUOTED_SYMBOL:
        	        	        	            	case 147:
        	        	        	            		{
        	        	        	            			alt11=1;
        	        	        	            		}
        	        	        	            	    break;

        	        	        	            	}

        	        	        	            	switch (alt11)
        	        	        	            	{
        	        	        	            	    case 1:
        	        	        	            	        // ../../../../../../src/parser/smt2/Smt2.g:659:20: sygusGTerm[ sgts.back().back(), fun]
        	        	        	            	        {
        	        	        	            	            FOLLOWPUSH(FOLLOW_sygusGTerm_in_sygusCommand1194);
        	        	        	            	            sygusGTerm(ctx, sgts.back().back(), fun);

        	        	        	            	            FOLLOWPOP();
        	        	        	            	            if  (HASEXCEPTION())
        	        	        	            	            {
        	        	        	            	                goto rulesygusCommandEx;
        	        	        	            	            }


        	        	        	            	            {
        	        	        	            	                 sgts.back().push_back( CVC4::SygusGTerm() ); 
        	        	        	            	            }


        	        	        	            	        }
        	        	        	            	        break;

        	        	        	            	    default:

        	        	        	            		if ( cnt11 >= 1 )
        	        	        	            		{
        	        	        	            		    goto loop11;
        	        	        	            		}
        	        	        	            		/* mismatchedSetEx()
        	        	        	            		 */
        	        	        	            		CONSTRUCTEX();
        	        	        	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        	        	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        	        	            		goto rulesygusCommandEx;
        	        	        	            	}
        	        	        	            	cnt11++;
        	        	        	                }
        	        	        	                loop11: ;	/* Jump to here if this rule does not match */
        	        	        	            }

        	        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusCommand1215);
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusCommandEx;
        	        	        	            }


        	        	        	            {
        	        	        	                 sgts.back().pop_back(); 
        	        	        	            }


        	        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusCommand1225);
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusCommandEx;
        	        	        	            }


        	        	        	        }
        	        	        	        break;

        	        	        	    default:

        	        	        		if ( cnt12 >= 1 )
        	        	        		{
        	        	        		    goto loop12;
        	        	        		}
        	        	        		/* mismatchedSetEx()
        	        	        		 */
        	        	        		CONSTRUCTEX();
        	        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        	        		goto rulesygusCommandEx;
        	        	        	}
        	        	        	cnt12++;
        	        	            }
        	        	            loop12: ;	/* Jump to here if this rule does not match */
        	        	        }

        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusCommand1239);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	        {
        	        	             read_syntax = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             
        	                  if( !read_syntax ){
        	                    //create the default grammar
        	                    Debug("parser-sygus") << "Make default grammar..." << std::endl;
        	                    PARSER_STATE->mkSygusDefaultGrammar(
        	                        range, terms[0], fun, datatypes, sorts, ops, sygus_vars,
        	                        startIndex);
        	                    //set start index
        	                    Debug("parser-sygus") << "Set start index " << startIndex << "..."
        	                                          << std::endl;
        	                    PARSER_STATE->setSygusStartIndex(fun, startIndex, datatypes, sorts,
        	                                                     ops);        
        	                  }else{
        	                    Debug("parser-sygus") << "--- Process " << sgts.size()
        	                                          << " sygus gterms..." << std::endl;
        	                    for( unsigned i=0; i<sgts.size(); i++ ){
        	                      for( unsigned j=0; j<sgts[i].size(); j++ ){
        	                        Type sub_ret;
        	                        PARSER_STATE->processSygusGTerm(
        	                            sgts[i][j], i, datatypes, sorts, ops, cnames, cargs,
        	                            allow_const, unresolved_gterm_sym, sygus_vars, sygus_to_builtin,
        	                            sygus_to_builtin_expr, sub_ret );
        	                      }
        	                    }
        	                    //swap index if necessary
        	                    Debug("parser-sygus") << "--- Making sygus datatypes..." << std::endl;
        	                    for( unsigned i=0; i<datatypes.size(); i++ ){
        	                      Debug("parser-sygus") << "..." << datatypes[i].getName()
        	                                            << " has builtin sort " << sorts[i]
        	                                            << std::endl;
        	                    }
        	                    for( unsigned i=0; i<datatypes.size(); i++ ){
        	                      Debug("parser-sygus") << "...make " << datatypes[i].getName()
        	                                            << " with builtin sort " << sorts[i]
        	                                            << std::endl;
        	                      if( sorts[i].isNull() ){
        	                        PARSER_STATE->parseError("Internal error : could not infer "
        	                                                 "builtin sort for nested gterm.");
        	                      }
        	                      datatypes[i].setSygus( sorts[i], terms[0], allow_const[i], false );
        	                      PARSER_STATE->mkSygusDatatype(
        	                          datatypes[i], ops[i], cnames[i], cargs[i],
        	                          unresolved_gterm_sym[i], sygus_to_builtin );
        	                    }
        	                    PARSER_STATE->setSygusStartIndex(fun, startIndex, datatypes, sorts,
        	                                                     ops);
        	                  }
        	                  //only care about datatypes/sorts/ops past here
        	                  PARSER_STATE->popScope();
        	                  Debug("parser-sygus") << "--- Make " << datatypes.size()
        	                                        << " mutual datatypes..." << std::endl;
        	                  for( unsigned i=0; i<datatypes.size(); i++ ){
        	                    Debug("parser-sygus") << "  " << i << " : " << datatypes[i].getName()
        	                                          << std::endl;
        	                  }
        	                  std::vector<DatatypeType> datatypeTypes =
        	                      PARSER_STATE->mkMutualDatatypeTypes(datatypes);
        	                  seq->addCommand(new DatatypeDeclarationCommand(datatypeTypes));
        	                  std::map<DatatypeType, Expr> evals;
        	                  if( sorts[0]!=range ){
        	                    PARSER_STATE->parseError(std::string("Bad return type in grammar for "
        	                                                         "SyGuS function ") + fun);
        	                  }
        	                  // make all the evals first, since they are mutually referential
        	                  for(size_t i = 0; i < datatypeTypes.size(); ++i) {
        	                    DatatypeType dtt = datatypeTypes[i];
        	                    const Datatype& dt = dtt.getDatatype();
        	                    name = "eval_" + dt.getName();
        	                    PARSER_STATE->checkDeclaration(name, CHECK_UNDECLARED, SYM_VARIABLE);
        	                    std::vector<Type> evalType;
        	                    evalType.push_back(dtt);
        	                    if( !terms[0].isNull() ){
        	                      for(size_t j = 0; j < terms[0].getNumChildren(); ++j) {
        	                        evalType.push_back(terms[0][j].getType());
        	                      }
        	                    }
        	                    evalType.push_back(sorts[i]);
        	                    const FunctionType eval_func_type =
        	                        EXPR_MANAGER->mkFunctionType(evalType);
        	                    Expr eval = PARSER_STATE->mkVar(name, eval_func_type);
        	                    Debug("parser-sygus") << "Make eval " << eval << " for " << dt.getName()
        	                                          << std::endl;
        	                    evals.insert(std::make_pair(dtt, eval));
        	                    if(i == 0) {
        	                      PARSER_STATE->addSygusFun(fun, eval);
        	                    }
        	                  }
        	                  // now go through and settle everything
        	                  for(size_t i = 0; i < datatypeTypes.size(); ++i) {
        	                    DatatypeType dtt = datatypeTypes[i];
        	                    const Datatype& dt = dtt.getDatatype();
        	                    Expr eval = evals[dtt];
        	                    Debug("parser-sygus") << "Sygus : process grammar : " << dt
        	                                          << std::endl;
        	                    for(size_t j = 0; j < dt.getNumConstructors(); ++j) {
        	                      Expr assertion = PARSER_STATE->getSygusAssertion(
        	                          datatypeTypes, ops, evals, terms, eval, dt, i, j );
        	                      seq->addCommand(new AssertCommand(assertion));
        	                    }
        	                  }
        	                  cmd->reset(seq.release());
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:769:5: CONSTRAINT_TOK term[expr, expr2]
        	    {
        	         MATCHT(CONSTRAINT_TOK, &FOLLOW_CONSTRAINT_TOK_in_sygusCommand1266);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             
        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  Debug("parser-sygus") << "Sygus : define sygus funs..." << std::endl;
        	                  PARSER_STATE->defineSygusFuns(); 
        	                  Debug("parser-sygus") << "Sygus : read constraint..." << std::endl;
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_sygusCommand1274);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             Debug("parser-sygus") << "...read constraint " << expr << std::endl;
        	                  PARSER_STATE->addSygusConstraint(expr);
        	                  cmd->reset(new EmptyCommand());
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:780:5: INV_CONSTRAINT_TOK ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+
        	    {
        	         MATCHT(INV_CONSTRAINT_TOK, &FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1287);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	              
        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  Debug("parser-sygus") << "Sygus : define sygus funs..." << std::endl;
        	                  PARSER_STATE->defineSygusFuns(); 
        	                  Debug("parser-sygus") << "Sygus : read inv-constraint..." << std::endl;
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:786:5: ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+
        	        {
        	            int cnt14=0;

        	            for (;;)
        	            {
        	                int alt14=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case CHECK_SYNTH_TOK:
        	        	case CONSTRAINT_TOK:
        	        	case DECLARE_PRIMED_VAR_TOK:
        	        	case DECLARE_VAR_TOK:
        	        	case INV_CONSTRAINT_TOK:
        	        	case QUOTED_SYMBOL:
        	        	case SET_OPTIONS_TOK:
        	        	case SIMPLE_SYMBOL:
        	        	case SYNTH_FUN_TOK:
        	        	case SYNTH_INV_TOK:
        	        	case UNTERMINATED_QUOTED_SYMBOL:
        	        	case 147:
        	        		{
        	        			alt14=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt14)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:786:7: symbol[name,CHECK_NONE,SYM_VARIABLE]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand1297);
        	        	            symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesygusCommandEx;
        	        	            }


        	        	            {
        	        	                 
        	        	                        if( !terms.empty() ){
        	        	                          if( !PARSER_STATE->isDefinedFunction(name) ){
        	        	                            std::stringstream ss;
        	        	                            ss << "Function " << name << " in inv-constraint is not defined.";
        	        	                            PARSER_STATE->parseError(ss.str());
        	        	                          }
        	        	                        }
        	        	                        terms.push_back( PARSER_STATE->getVariable(name) );
        	        	                      
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt14 >= 1 )
        	        		{
        	        		    goto loop14;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulesygusCommandEx;
        	        	}
        	        	cnt14++;
        	            }
        	            loop14: ;	/* Jump to here if this rule does not match */
        	        }

        	        {

        	                  if( terms.size()!=4 ){
        	                    PARSER_STATE->parseError("Bad syntax for inv-constraint: expected 4 "
        	                                             "arguments.");
        	                  }
        	                  //get primed variables
        	                  std::vector< Expr > primed[2];
        	                  std::vector< Expr > all;
        	                  for( unsigned i=0; i<2; i++ ){
        	                    PARSER_STATE->getSygusPrimedVars( primed[i], i==1 );
        	                    all.insert( all.end(), primed[i].begin(), primed[i].end() );
        	                  }
        	                  //make relevant terms
        	                  for( unsigned i=0; i<4; i++ ){
        	                    Debug("parser-sygus") << "Make inv-constraint term #" << i << "..."
        	                                          << std::endl;
        	                    Expr op = terms[i];
        	                    std::vector< Expr > children;
        	                    children.push_back( op );
        	                    if( i==2 ){
        	                      children.insert( children.end(), all.begin(), all.end() );
        	                    }else{
        	                      children.insert( children.end(), primed[0].begin(), primed[0].end() );
        	                    }
        	                    terms[i] = EXPR_MANAGER->mkExpr(kind::APPLY,children);
        	                    if( i==0 ){
        	                      std::vector< Expr > children2;
        	                      children2.push_back( op );
        	                      children2.insert(children2.end(), primed[1].begin(),
        	                                       primed[1].end());
        	                      terms.push_back( EXPR_MANAGER->mkExpr(kind::APPLY,children2) );
        	                    }
        	                  }
        	                  //make constraints
        	                  std::vector< Expr > conj;
        	                  conj.push_back( EXPR_MANAGER->mkExpr(kind::IMPLIES, terms[1],
        	                                                       terms[0] ) );
        	                  const Expr term0_and_2 = EXPR_MANAGER->mkExpr(kind::AND, terms[0],
        	                                                                terms[2] );
        	                  conj.push_back( EXPR_MANAGER->mkExpr(kind::IMPLIES, term0_and_2,
        	                                                       terms[4] ) );
        	                  conj.push_back( EXPR_MANAGER->mkExpr(kind::IMPLIES, terms[0], terms[3]) );
        	                  Expr ic = EXPR_MANAGER->mkExpr( kind::AND, conj );
        	                  Debug("parser-sygus") << "...read invariant constraint " << ic
        	                                        << std::endl;
        	                  PARSER_STATE->addSygusConstraint(ic);
        	                  cmd->reset(new EmptyCommand());
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:845:5: CHECK_SYNTH_TOK
        	    {
        	         MATCHT(CHECK_SYNTH_TOK, &FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1321);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); PARSER_STATE->defineSygusFuns(); 
        	        }


        	        {
        	             Expr sygusVar = EXPR_MANAGER->mkVar("sygus", EXPR_MANAGER->booleanType());
        	                  Expr inst_attr =EXPR_MANAGER->mkExpr(kind::INST_ATTRIBUTE, sygusVar);
        	                  Expr sygusAttr = EXPR_MANAGER->mkExpr(kind::INST_PATTERN_LIST, inst_attr);
        	                  std::vector<Expr> bodyv;
        	                  Debug("parser-sygus") << "Sygus : Constructing sygus constraint..."
        	                                        << std::endl;
        	                  Expr body = EXPR_MANAGER->mkExpr(kind::NOT,
        	                                                   PARSER_STATE->getSygusConstraints());
        	                  Debug("parser-sygus") << "...constructed sygus constraint " << body
        	                                        << std::endl;      
        	                  if( !PARSER_STATE->getSygusVars().empty() ){
        	                    Expr boundVars = EXPR_MANAGER->mkExpr(kind::BOUND_VAR_LIST,
        	                                                          PARSER_STATE->getSygusVars());
        	                    body = EXPR_MANAGER->mkExpr(kind::EXISTS, boundVars, body);
        	                    Debug("parser-sygus") << "...constructed exists " << body << std::endl;
        	                  }
        	                  if( !PARSER_STATE->getSygusFunSymbols().empty() ){
        	                    Expr boundVars = EXPR_MANAGER->mkExpr(
        	                        kind::BOUND_VAR_LIST, PARSER_STATE->getSygusFunSymbols());
        	                    body = EXPR_MANAGER->mkExpr(kind::FORALL, boundVars, body, sygusAttr);
        	                  }
        	                  Debug("parser-sygus") << "...constructed forall " << body << std::endl;   
        	                  Command* c = new SetUserAttributeCommand("sygus", sygusVar);
        	                  c->setMuted(true);
        	                  PARSER_STATE->preemptCommand(c);
        	                  cmd->reset(new CheckSynthCommand(body));
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/smt2/Smt2.g:874:5: command[cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_command_in_sygusCommand1339);
        	        command(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesygusCommandEx; /* Prevent compiler warnings */
    rulesygusCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sygusCommand */

/**
 * $ANTLR start sygusGTerm
 * ../../../../../../src/parser/smt2/Smt2.g:891:1: sygusGTerm[CVC4::SygusGTerm& sgt, std::string& fun] : ( LPAREN_TOK ( builtinOp[k] | LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[sname,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] sygusGTerm[sgt.d_children.back(), fun] RPAREN_TOK )+ RPAREN_TOK | SYGUS_CONSTANT_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_LOCAL_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_INPUT_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | symbol[name,CHECK_NONE,SYM_VARIABLE] ) ( sygusGTerm[sgt.d_children.back(), fun] )* RPAREN_TOK | INTEGER_LITERAL | HEX_LITERAL | BINARY_LITERAL | str[s,false] | symbol[name,CHECK_NONE,SYM_VARIABLE] ( SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE] )? );
 */
static void
sygusGTerm(pSmt2Parser ctx, CVC4::SygusGTerm& sgt, std::string& fun)
{

      std::string name, name2;
      bool readEnum = false;
      Kind k;
      Type t;
      CVC4::DatatypeConstructor* ctor = NULL;
      std::string sname;
      std::vector< Expr > let_vars;
      bool readingLet = false;
      std::string s;

    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL4;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL5;
    pANTLR3_COMMON_TOKEN    BINARY_LITERAL6;

    /* Initialize rule variables
     */

    INTEGER_LITERAL4       = NULL;
    HEX_LITERAL5       = NULL;
    BINARY_LITERAL6       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:903:3: ( LPAREN_TOK ( builtinOp[k] | LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[sname,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] sygusGTerm[sgt.d_children.back(), fun] RPAREN_TOK )+ RPAREN_TOK | SYGUS_CONSTANT_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_LOCAL_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_INPUT_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | symbol[name,CHECK_NONE,SYM_VARIABLE] ) ( sygusGTerm[sgt.d_children.back(), fun] )* RPAREN_TOK | INTEGER_LITERAL | HEX_LITERAL | BINARY_LITERAL | str[s,false] | symbol[name,CHECK_NONE,SYM_VARIABLE] ( SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE] )? )

            ANTLR3_UINT32 alt20;

            alt20=6;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt20=1;
            	}
                break;
            case INTEGER_LITERAL:
            	{
            		alt20=2;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt20=3;
            	}
                break;
            case BINARY_LITERAL:
            	{
            		alt20=4;
            	}
                break;
            case STRING_LITERAL_2_0:
            case STRING_LITERAL_2_5:
            	{
            		alt20=5;
            	}
                break;
            case CHECK_SYNTH_TOK:
            case CONSTRAINT_TOK:
            case DECLARE_PRIMED_VAR_TOK:
            case DECLARE_VAR_TOK:
            case INV_CONSTRAINT_TOK:
            case QUOTED_SYMBOL:
            case SET_OPTIONS_TOK:
            case SIMPLE_SYMBOL:
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            case UNTERMINATED_QUOTED_SYMBOL:
            case 147:
            	{
            		alt20=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto rulesygusGTermEx;

            }

            switch (alt20)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:903:5: LPAREN_TOK ( builtinOp[k] | LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[sname,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] sygusGTerm[sgt.d_children.back(), fun] RPAREN_TOK )+ RPAREN_TOK | SYGUS_CONSTANT_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_LOCAL_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_INPUT_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | symbol[name,CHECK_NONE,SYM_VARIABLE] ) ( sygusGTerm[sgt.d_children.back(), fun] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGTerm1380);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusGTermEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:905:5: ( builtinOp[k] | LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[sname,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] sygusGTerm[sgt.d_children.back(), fun] RPAREN_TOK )+ RPAREN_TOK | SYGUS_CONSTANT_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_LOCAL_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | SYGUS_INPUT_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED] | symbol[name,CHECK_NONE,SYM_VARIABLE] )
        	        {
        	            int alt17=7;
        	            switch ( LA(1) )
        	            {
        	            case AND_TOK:
        	            case BV2NAT_TOK:
        	            case DISTINCT_TOK:
        	            case DIV_TOK:
        	            case DTSIZE_TOK:
        	            case EQUAL_TOK:
        	            case FMFCARDVAL_TOK:
        	            case FMFCARD_TOK:
        	            case GREATER_THAN_EQUAL_TOK:
        	            case GREATER_THAN_TOK:
        	            case IMPLIES_TOK:
        	            case INST_CLOSURE_TOK:
        	            case ITE_TOK:
        	            case LESS_THAN_EQUAL_TOK:
        	            case LESS_THAN_TOK:
        	            case MINUS_TOK:
        	            case NOT_TOK:
        	            case OR_TOK:
        	            case PLUS_TOK:
        	            case STAR_TOK:
        	            case XOR_TOK:
        	            	{
        	            		alt17=1;
        	            	}
        	                break;
        	            case LET_TOK:
        	            	{
        	            		alt17=2;
        	            	}
        	                break;
        	            case SYGUS_CONSTANT_TOK:
        	            	{
        	            		alt17=3;
        	            	}
        	                break;
        	            case SYGUS_VARIABLE_TOK:
        	            	{
        	            		alt17=4;
        	            	}
        	                break;
        	            case SYGUS_LOCAL_VARIABLE_TOK:
        	            	{
        	            		alt17=5;
        	            	}
        	                break;
        	            case SYGUS_INPUT_VARIABLE_TOK:
        	            	{
        	            		alt17=6;
        	            	}
        	                break;
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_VAR_TOK:
        	            case INV_CONSTRAINT_TOK:
        	            case QUOTED_SYMBOL:
        	            case SET_OPTIONS_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case 147:
        	            	{
        	            		alt17=7;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 17;
        	                EXCEPTION->state        = 0;


        	                goto rulesygusGTermEx;

        	            }

        	            switch (alt17)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:905:7: builtinOp[k]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_builtinOp_in_sygusGTerm1393);
        	        	        builtinOp(ctx, k);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             
        	        	                    Debug("parser-sygus") << "Sygus grammar " << fun << " : builtin op : "
        	        	                                          << name << std::endl;
        	        	                    // Since we enforce satisfaction completeness, immediately convert to
        	        	                    // total version.
        	        	                    if( k==CVC4::kind::BITVECTOR_UDIV ){
        	        	                      k = CVC4::kind::BITVECTOR_UDIV_TOTAL;
        	        	                    }else if( k==CVC4::kind::BITVECTOR_UREM ){
        	        	                      k = CVC4::kind::BITVECTOR_UREM_TOTAL;
        	        	                    }
        	        	                    sgt.d_name = kind::kindToString(k);
        	        	                    sgt.d_gterm_type = SygusGTerm::gterm_op;
        	        	                    sgt.d_expr = EXPR_MANAGER->operatorOf(k);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:919:8: LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[sname,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] sygusGTerm[sgt.d_children.back(), fun] RPAREN_TOK )+ RPAREN_TOK
        	        	    {
        	        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_sygusGTerm1404);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGTerm1406);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             
        	        	                     sgt.d_name = std::string("let");
        	        	                     sgt.d_gterm_type = SygusGTerm::gterm_let;
        	        	                     PARSER_STATE->pushScope(true);
        	        	                     readingLet = true;
        	        	                   
        	        	        }


        	        	        // ../../../../../../src/parser/smt2/Smt2.g:925:8: ( LPAREN_TOK symbol[sname,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] sygusGTerm[sgt.d_children.back(), fun] RPAREN_TOK )+
        	        	        {
        	        	            int cnt16=0;

        	        	            for (;;)
        	        	            {
        	        	                int alt16=2;
        	        	        	switch ( LA(1) )
        	        	        	{
        	        	        	case LPAREN_TOK:
        	        	        		{
        	        	        			alt16=1;
        	        	        		}
        	        	        	    break;

        	        	        	}

        	        	        	switch (alt16)
        	        	        	{
        	        	        	    case 1:
        	        	        	        // ../../../../../../src/parser/smt2/Smt2.g:925:10: LPAREN_TOK symbol[sname,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] sygusGTerm[sgt.d_children.back(), fun] RPAREN_TOK
        	        	        	        {
        	        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGTerm1419);
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusGTermEx;
        	        	        	            }


        	        	        	            FOLLOWPUSH(FOLLOW_symbol_in_sygusGTerm1430);
        	        	        	            symbol(ctx, sname, CHECK_NONE, SYM_VARIABLE);

        	        	        	            FOLLOWPOP();
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusGTermEx;
        	        	        	            }


        	        	        	            FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGTerm1442);
        	        	        	            sortSymbol(ctx, t, CHECK_DECLARED);

        	        	        	            FOLLOWPOP();
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusGTermEx;
        	        	        	            }


        	        	        	            {
        	        	        	                 
        	        	        	                          Expr v = PARSER_STATE->mkBoundVar(sname,t); 
        	        	        	                          sgt.d_let_vars.push_back( v ); 
        	        	        	                          sgt.addChild();
        	        	        	                        
        	        	        	            }


        	        	        	            FOLLOWPUSH(FOLLOW_sygusGTerm_in_sygusGTerm1456);
        	        	        	            sygusGTerm(ctx, sgt.d_children.back(), fun);

        	        	        	            FOLLOWPOP();
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusGTermEx;
        	        	        	            }


        	        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGTerm1467);
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulesygusGTermEx;
        	        	        	            }


        	        	        	        }
        	        	        	        break;

        	        	        	    default:

        	        	        		if ( cnt16 >= 1 )
        	        	        		{
        	        	        		    goto loop16;
        	        	        		}
        	        	        		/* mismatchedSetEx()
        	        	        		 */
        	        	        		CONSTRUCTEX();
        	        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        	        		goto rulesygusGTermEx;
        	        	        	}
        	        	        	cnt16++;
        	        	            }
        	        	            loop16: ;	/* Jump to here if this rule does not match */
        	        	        }

        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGTerm1472);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:934:7: SYGUS_CONSTANT_TOK sortSymbol[t,CHECK_DECLARED]
        	        	    {
        	        	         MATCHT(SYGUS_CONSTANT_TOK, &FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGTerm1480);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGTerm1482);
        	        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             sgt.d_gterm_type = SygusGTerm::gterm_constant;
        	        	                    sgt.d_type = t;
        	        	                    Debug("parser-sygus") << "Sygus grammar constant." << std::endl;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:939:7: SYGUS_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED]
        	        	    {
        	        	         MATCHT(SYGUS_VARIABLE_TOK, &FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGTerm1500);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGTerm1502);
        	        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             sgt.d_gterm_type = SygusGTerm::gterm_variable;
        	        	                    sgt.d_type = t;
        	        	                    Debug("parser-sygus") << "Sygus grammar variable." << std::endl;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 5:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:944:7: SYGUS_LOCAL_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED]
        	        	    {
        	        	         MATCHT(SYGUS_LOCAL_VARIABLE_TOK, &FOLLOW_SYGUS_LOCAL_VARIABLE_TOK_in_sygusGTerm1519);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGTerm1521);
        	        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             sgt.d_gterm_type = SygusGTerm::gterm_local_variable;
        	        	                    sgt.d_type = t;
        	        	                    Debug("parser-sygus") << "Sygus grammar local variable...ignore."
        	        	                                          << std::endl;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 6:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:950:7: SYGUS_INPUT_VARIABLE_TOK sortSymbol[t,CHECK_DECLARED]
        	        	    {
        	        	         MATCHT(SYGUS_INPUT_VARIABLE_TOK, &FOLLOW_SYGUS_INPUT_VARIABLE_TOK_in_sygusGTerm1538);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGTerm1540);
        	        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             sgt.d_gterm_type = SygusGTerm::gterm_input_variable;
        	        	                    sgt.d_type = t;
        	        	                    Debug("parser-sygus") << "Sygus grammar (input) variable."
        	        	                                          << std::endl;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 7:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:956:7: symbol[name,CHECK_NONE,SYM_VARIABLE]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusGTerm1557);
        	        	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             
        	        	                    bool isBuiltinOperator = PARSER_STATE->isOperatorEnabled(name);
        	        	                    if(isBuiltinOperator) {
        	        	                      Debug("parser-sygus") << "Sygus grammar " << fun << " : builtin op : "
        	        	                                            << name << std::endl;
        	        	                      k = PARSER_STATE->getOperatorKind(name);
        	        	                      if( k==CVC4::kind::BITVECTOR_UDIV ){
        	        	                        k = CVC4::kind::BITVECTOR_UDIV_TOTAL;
        	        	                      }else if( k==CVC4::kind::BITVECTOR_UREM ){
        	        	                        k = CVC4::kind::BITVECTOR_UREM_TOTAL;
        	        	                      }
        	        	                      sgt.d_name = kind::kindToString(k);
        	        	                      sgt.d_gterm_type = SygusGTerm::gterm_op;
        	        	                      sgt.d_expr = EXPR_MANAGER->operatorOf(k);
        	        	                    }else{
        	        	                      // what is this sygus term trying to accomplish here, if the
        	        	                      // symbol isn't yet declared?!  probably the following line will
        	        	                      // fail, but we need an operator to continue here..
        	        	                      Debug("parser-sygus")
        	        	                          << "Sygus grammar " << fun << " : op (declare="
        	        	                          << PARSER_STATE->isDeclared(name) << ", define="
        	        	                          << PARSER_STATE->isDefinedFunction(name) << ") : " << name
        	        	                          << std::endl;
        	        	                      if(!PARSER_STATE->isDeclared(name) &&
        	        	                         !PARSER_STATE->isDefinedFunction(name) ){
        	        	                        PARSER_STATE->parseError("Functions in sygus grammars must be "
        	        	                                                 "defined.");
        	        	                      }
        	        	                      sgt.d_name = name;
        	        	                      sgt.d_gterm_type = SygusGTerm::gterm_op;
        	        	                      sgt.d_expr = PARSER_STATE->getVariable(name) ;
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             Debug("parser-sygus") << "Read arguments under " << sgt.d_name
        	                                        << std::endl;
        	                  sgt.addChild();
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:995:5: ( sygusGTerm[sgt.d_children.back(), fun] )*

        	        for (;;)
        	        {
        	            int alt18=2;
        	            switch ( LA(1) )
        	            {
        	            case BINARY_LITERAL:
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_VAR_TOK:
        	            case HEX_LITERAL:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case LPAREN_TOK:
        	            case QUOTED_SYMBOL:
        	            case SET_OPTIONS_TOK:
        	            case SIMPLE_SYMBOL:
        	            case STRING_LITERAL_2_0:
        	            case STRING_LITERAL_2_5:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case 147:
        	            	{
        	            		alt18=1;
        	            	}
        	                break;

        	            }

        	            switch (alt18)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:995:7: sygusGTerm[sgt.d_children.back(), fun]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sygusGTerm_in_sygusGTerm1585);
        	        	        sygusGTerm(ctx, sgt.d_children.back(), fun);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             Debug("parser-sygus") << "Finished read argument #"
        	        	                                          << sgt.d_children.size() << "..." << std::endl;
        	        	                    sgt.addChild();
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop18;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop18: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGTerm1608);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusGTermEx;
        	        }


        	        {

        	                  //pop last child index 
        	                  sgt.d_children.pop_back();   
        	                  if( readingLet ){
        	                    PARSER_STATE->popScope();
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1008:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL4 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_sygusGTerm1616);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusGTermEx;
        	        }


        	        {
        	             Debug("parser-sygus") << "Sygus grammar " << fun << " : integer literal "
        	                                        << AntlrInput::tokenText(INTEGER_LITERAL4)
        	                                        << std::endl;
        	                  sgt.d_expr = MK_CONST(Rational(AntlrInput::tokenText(INTEGER_LITERAL4)));
        	                  sgt.d_name = AntlrInput::tokenText(INTEGER_LITERAL4);
        	                  sgt.d_gterm_type = SygusGTerm::gterm_op;
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1016:5: HEX_LITERAL
        	    {
        	        HEX_LITERAL5 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_sygusGTerm1628);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusGTermEx;
        	        }


        	        {
        	             Debug("parser-sygus") << "Sygus grammar " << fun << " : hex literal "
        	                                        << AntlrInput::tokenText(HEX_LITERAL5) << std::endl;
        	                  assert( AntlrInput::tokenText(HEX_LITERAL5).find("#x") == 0 );
        	                  std::string hexString = AntlrInput::tokenTextSubstr(HEX_LITERAL5, 2);
        	                  sgt.d_expr = MK_CONST( BitVector(hexString, 16) );
        	                  sgt.d_name = AntlrInput::tokenText(HEX_LITERAL5);
        	                  sgt.d_gterm_type = SygusGTerm::gterm_op;
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1025:5: BINARY_LITERAL
        	    {
        	        BINARY_LITERAL6 = (pANTLR3_COMMON_TOKEN) MATCHT(BINARY_LITERAL, &FOLLOW_BINARY_LITERAL_in_sygusGTerm1640);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusGTermEx;
        	        }


        	        {
        	             Debug("parser-sygus") << "Sygus grammar " << fun << " : binary literal "
        	                                        << AntlrInput::tokenText(BINARY_LITERAL6)
        	                                        << std::endl;
        	                  assert( AntlrInput::tokenText(BINARY_LITERAL6).find("#b") == 0 );
        	                  std::string binString = AntlrInput::tokenTextSubstr(BINARY_LITERAL6, 2);
        	                  sgt.d_expr = MK_CONST( BitVector(binString, 2) );
        	                  sgt.d_name = AntlrInput::tokenText(BINARY_LITERAL6);
        	                  sgt.d_gterm_type = SygusGTerm::gterm_op;
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1035:5: str[s,false]
        	    {
        	        FOLLOWPUSH(FOLLOW_str_in_sygusGTerm1652);
        	        str(ctx, s, false);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusGTermEx;
        	        }


        	        {
        	             Debug("parser-sygus") << "Sygus grammar " << fun << " : string literal \""
        	                                        << s << "\"" << std::endl;
        	                  sgt.d_expr = MK_CONST( ::CVC4::String(s) );
        	                  sgt.d_name = s;
        	                  sgt.d_gterm_type = SygusGTerm::gterm_op;
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1042:5: symbol[name,CHECK_NONE,SYM_VARIABLE] ( SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE] )?
        	    {
        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusGTerm1665);
        	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusGTermEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1043:5: ( SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE] )?
        	        {
        	            int alt19=2;
        	            switch ( LA(1) )
        	            {
        	                case SYGUS_ENUM_CONS_TOK:
        	                	{
        	                		alt19=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt19)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1043:7: SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE]
        	        	    {
        	        	         MATCHT(SYGUS_ENUM_CONS_TOK, &FOLLOW_SYGUS_ENUM_CONS_TOK_in_sygusGTerm1674);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusGTerm1676);
        	        	        symbol(ctx, name2, CHECK_NONE, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusGTermEx;
        	        	        }


        	        	        {
        	        	             readEnum = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             if( readEnum ){
        	                    name = name + "__Enum__" + name2;
        	                    Debug("parser-sygus") << "Sygus grammar " << fun << " : Enum constant "
        	                                          << name << std::endl;
        	                    Expr c = PARSER_STATE->getVariable(name);
        	                    sgt.d_expr = MK_EXPR(kind::APPLY_CONSTRUCTOR,c);
        	                    sgt.d_name = name;
        	                    sgt.d_gterm_type = SygusGTerm::gterm_op;
        	                  }else{
        	                    if( name[0] == '-' ){  //hack for unary minus
        	                      Debug("parser-sygus") << "Sygus grammar " << fun
        	                                            << " : unary minus integer literal " << name
        	                                            << std::endl;
        	                      sgt.d_expr = MK_CONST(Rational(name));
        	                      sgt.d_name = name;
        	                      sgt.d_gterm_type = SygusGTerm::gterm_op;
        	                    }else if( PARSER_STATE->isDeclared(name,SYM_VARIABLE) ){
        	                      Debug("parser-sygus") << "Sygus grammar " << fun << " : symbol "
        	                                            << name << std::endl;
        	                      sgt.d_expr = PARSER_STATE->getVariable(name);
        	                      sgt.d_name = name;
        	                      sgt.d_gterm_type = SygusGTerm::gterm_op;
        	                    }else{
        	                      //prepend function name to base sorts when reading an operator
        	                      std::stringstream ss;
        	                      ss << fun << "_" << name;
        	                      name = ss.str();
        	                      if( PARSER_STATE->isDeclared(name, SYM_SORT) ){
        	                        Debug("parser-sygus") << "Sygus grammar " << fun
        	                                              << " : nested sort " << name << std::endl;
        	                        sgt.d_type = PARSER_STATE->getSort(name);
        	                        sgt.d_gterm_type = SygusGTerm::gterm_nested_sort;
        	                      }else{
        	                        Debug("parser-sygus") << "Sygus grammar " << fun
        	                                              << " : unresolved symbol " << name
        	                                              << std::endl;
        	                        sgt.d_gterm_type = SygusGTerm::gterm_unresolved;
        	                        sgt.d_name = name;
        	                      }
        	                    }
        	                  }
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesygusGTermEx; /* Prevent compiler warnings */
    rulesygusGTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sygusGTerm */

/**
 * $ANTLR start metaInfoInternal
 * ../../../../../../src/parser/smt2/Smt2.g:1091:1: metaInfoInternal[CVC4::PtrCloser<CVC4::Command>* cmd] : KEYWORD symbolicExpr[sexpr] ;
 */
static void
metaInfoInternal(pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{

      std::string name;
      SExpr sexpr;

    pANTLR3_COMMON_TOKEN    KEYWORD7;

    /* Initialize rule variables
     */

    KEYWORD7       = NULL;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:1096:3: ( KEYWORD symbolicExpr[sexpr] )
        // ../../../../../../src/parser/smt2/Smt2.g:1096:5: KEYWORD symbolicExpr[sexpr]
        {
            KEYWORD7 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_metaInfoInternal1718);
            if  (HASEXCEPTION())
            {
                goto rulemetaInfoInternalEx;
            }


            FOLLOWPUSH(FOLLOW_symbolicExpr_in_metaInfoInternal1720);
            symbolicExpr(ctx, sexpr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemetaInfoInternalEx;
            }


            {
                 name = AntlrInput::tokenText(KEYWORD7);
                      if(name == ":cvc4-logic" || name == ":cvc4_logic") {
                        PARSER_STATE->setLogic(sexpr.getValue());
                      } else if(name == ":smt-lib-version") {
                        // if we don't recognize the revision name, just keep the current mode
                        if( (sexpr.isRational() && sexpr.getRationalValue() == Rational(2)) ||
                            sexpr.getValue() == "2" ||
                            sexpr.getValue() == "2.0" ) {
                          PARSER_STATE->setLanguage(language::input::LANG_SMTLIB_V2_0);
                        } else if( (sexpr.isRational() &&
                                    sexpr.getRationalValue() == Rational(5, 2)) ||
                                  sexpr.getValue() == "2.5" ) {
                          PARSER_STATE->setLanguage(language::input::LANG_SMTLIB_V2_5);
                        }
                      }
                      PARSER_STATE->setInfo(name.c_str() + 1, sexpr);
                      cmd->reset(new SetInfoCommand(name.c_str() + 1, sexpr));
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetaInfoInternalEx; /* Prevent compiler warnings */
    rulemetaInfoInternalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end metaInfoInternal */

/**
 * $ANTLR start setOptionInternal
 * ../../../../../../src/parser/smt2/Smt2.g:1117:1: setOptionInternal[CVC4::PtrCloser<CVC4::Command>* cmd] : keyword[name] symbolicExpr[sexpr] ;
 */
static void
setOptionInternal(pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{
    /* Initialize rule variables
     */


      std::string name;
      SExpr sexpr;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:1122:3: ( keyword[name] symbolicExpr[sexpr] )
        // ../../../../../../src/parser/smt2/Smt2.g:1122:5: keyword[name] symbolicExpr[sexpr]
        {
            FOLLOWPUSH(FOLLOW_keyword_in_setOptionInternal1746);
            keyword(ctx, name);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesetOptionInternalEx;
            }


            FOLLOWPUSH(FOLLOW_symbolicExpr_in_setOptionInternal1749);
            symbolicExpr(ctx, sexpr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesetOptionInternalEx;
            }


            {
                 PARSER_STATE->setOption(name.c_str() + 1, sexpr);
                      cmd->reset(new SetOptionCommand(name.c_str() + 1, sexpr));
                      // Ugly that this changes the state of the parser; but
                      // global-declarations affects parsing, so we can't hold off
                      // on this until some SmtEngine eventually (if ever) executes it.
                      if(name == ":global-declarations") {
                        PARSER_STATE->setGlobalDeclarations(sexpr.getValue() == "true");
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesetOptionInternalEx; /* Prevent compiler warnings */
    rulesetOptionInternalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end setOptionInternal */

/**
 * $ANTLR start smt25Command
 * ../../../../../../src/parser/smt2/Smt2.g:1134:1: smt25Command[CVC4::PtrCloser<CVC4::Command>* cmd] : ( META_INFO_TOK metaInfoInternal[cmd] | DECLARE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] | GET_MODEL_TOK | ECHO_TOK ( simpleSymbolicExpr[sexpr] |) | RESET_TOK | RESET_ASSERTIONS_TOK | DEFINE_FUN_REC_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] term[expr, expr2] | DEFINE_FUNS_REC_TOK LPAREN_TOK ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )+ RPAREN_TOK LPAREN_TOK ( term[expr,expr2] )+ RPAREN_TOK );
 */
static void
smt25Command(pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{

      std::string name;
      std::string fname;
      Expr expr, expr2;
      std::vector<std::pair<std::string, Type> > sortedVarNames;
      SExpr sexpr;
      Type t;
      Expr func_app;
      std::vector<Expr> bvs;
      std::vector< std::vector<std::pair<std::string, Type> > > sortedVarNamesList;
      std::vector<Expr> funcs;
      std::vector<Expr> func_defs;
      Expr aexpr;
      CVC4::PtrCloser<CVC4::CommandSequence> seq;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1151:3: ( META_INFO_TOK metaInfoInternal[cmd] | DECLARE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] | GET_MODEL_TOK | ECHO_TOK ( simpleSymbolicExpr[sexpr] |) | RESET_TOK | RESET_ASSERTIONS_TOK | DEFINE_FUN_REC_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] term[expr, expr2] | DEFINE_FUNS_REC_TOK LPAREN_TOK ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )+ RPAREN_TOK LPAREN_TOK ( term[expr,expr2] )+ RPAREN_TOK )

            ANTLR3_UINT32 alt24;

            alt24=8;

            switch ( LA(1) )
            {
            case META_INFO_TOK:
            	{
            		alt24=1;
            	}
                break;
            case DECLARE_CONST_TOK:
            	{
            		alt24=2;
            	}
                break;
            case GET_MODEL_TOK:
            	{
            		alt24=3;
            	}
                break;
            case ECHO_TOK:
            	{
            		alt24=4;
            	}
                break;
            case RESET_TOK:
            	{
            		alt24=5;
            	}
                break;
            case RESET_ASSERTIONS_TOK:
            	{
            		alt24=6;
            	}
                break;
            case DEFINE_FUN_REC_TOK:
            	{
            		alt24=7;
            	}
                break;
            case DEFINE_FUNS_REC_TOK:
            	{
            		alt24=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto rulesmt25CommandEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1151:5: META_INFO_TOK metaInfoInternal[cmd]
        	    {
        	         MATCHT(META_INFO_TOK, &FOLLOW_META_INFO_TOK_in_smt25Command1781);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_metaInfoInternal_in_smt25Command1783);
        	        metaInfoInternal(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1154:5: DECLARE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED]
        	    {
        	         MATCHT(DECLARE_CONST_TOK, &FOLLOW_DECLARE_CONST_TOK_in_smt25Command1797);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_smt25Command1805);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_smt25Command1818);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             Expr c = PARSER_STATE->mkVar(name, t);
        	                  cmd->reset(new DeclareFunctionCommand(name, c, t)); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1162:5: GET_MODEL_TOK
        	    {
        	         MATCHT(GET_MODEL_TOK, &FOLLOW_GET_MODEL_TOK_in_smt25Command1838);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetModelCommand()); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1166:5: ECHO_TOK ( simpleSymbolicExpr[sexpr] |)
        	    {
        	         MATCHT(ECHO_TOK, &FOLLOW_ECHO_TOK_in_smt25Command1859);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1167:5: ( simpleSymbolicExpr[sexpr] |)
        	        {
        	            int alt21=2;
        	            switch ( LA(1) )
        	            {
        	            case AND_TOK:
        	            case ASSERT_TOK:
        	            case BINARY_LITERAL:
        	            case BV2NAT_TOK:
        	            case CHECKSAT_TOK:
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_DATATYPES_TOK:
        	            case DECLARE_FUN_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_SORT_TOK:
        	            case DECLARE_VAR_TOK:
        	            case DEFINE_FUNS_REC_TOK:
        	            case DEFINE_FUN_REC_TOK:
        	            case DEFINE_FUN_TOK:
        	            case DEFINE_SORT_TOK:
        	            case DISTINCT_TOK:
        	            case DIV_TOK:
        	            case DTSIZE_TOK:
        	            case ECHO_TOK:
        	            case EQUAL_TOK:
        	            case EXIT_TOK:
        	            case FMFCARDVAL_TOK:
        	            case FMFCARD_TOK:
        	            case GET_ASSERTIONS_TOK:
        	            case GET_ASSIGNMENT_TOK:
        	            case GET_INFO_TOK:
        	            case GET_MODEL_TOK:
        	            case GET_OPTION_TOK:
        	            case GET_PROOF_TOK:
        	            case GET_UNSAT_CORE_TOK:
        	            case GET_VALUE_TOK:
        	            case GREATER_THAN_EQUAL_TOK:
        	            case GREATER_THAN_TOK:
        	            case HEX_LITERAL:
        	            case IMPLIES_TOK:
        	            case INST_CLOSURE_TOK:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case ITE_TOK:
        	            case KEYWORD:
        	            case LESS_THAN_EQUAL_TOK:
        	            case LESS_THAN_TOK:
        	            case MINUS_TOK:
        	            case NOT_TOK:
        	            case OR_TOK:
        	            case PLUS_TOK:
        	            case POP_TOK:
        	            case PROPAGATION_RULE_TOK:
        	            case PUSH_TOK:
        	            case QUOTED_SYMBOL:
        	            case REDUCTION_RULE_TOK:
        	            case RESET_ASSERTIONS_TOK:
        	            case RESET_TOK:
        	            case REWRITE_RULE_TOK:
        	            case SET_INFO_TOK:
        	            case SET_LOGIC_TOK:
        	            case SET_OPTIONS_TOK:
        	            case SET_OPTION_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SIMPLIFY_TOK:
        	            case STAR_TOK:
        	            case STRING_LITERAL_2_0:
        	            case STRING_LITERAL_2_5:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case XOR_TOK:
        	            case 147:
        	            	{
        	            		alt21=1;
        	            	}
        	                break;
        	            case RPAREN_TOK:
        	            	{
        	            		alt21=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 21;
        	                EXCEPTION->state        = 0;


        	                goto rulesmt25CommandEx;

        	            }

        	            switch (alt21)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1167:7: simpleSymbolicExpr[sexpr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExpr_in_smt25Command1867);
        	        	        simpleSymbolicExpr(ctx, sexpr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesmt25CommandEx;
        	        	        }


        	        	        {
        	        	             cmd->reset(new EchoCommand(sexpr.toString())); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1169:7: 
        	        	    {
        	        	        {
        	        	             cmd->reset(new EchoCommand()); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1174:5: RESET_TOK
        	    {
        	         MATCHT(RESET_TOK, &FOLLOW_RESET_TOK_in_smt25Command1903);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             cmd->reset(new ResetCommand());
        	                  PARSER_STATE->reset();
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1180:5: RESET_ASSERTIONS_TOK
        	    {
        	         MATCHT(RESET_ASSERTIONS_TOK, &FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1921);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             cmd->reset(new ResetAssertionsCommand());
        	                  PARSER_STATE->resetAssertions();
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1184:5: DEFINE_FUN_REC_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] term[expr, expr2]
        	    {
        	         MATCHT(DEFINE_FUN_REC_TOK, &FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1933);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet();
        	                  seq.reset(new CVC4::CommandSequence());
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_smt25Command1945);
        	        symbol(ctx, fname, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(fname); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command1958);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_smt25Command1960);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command1963);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_smt25Command1969);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             if( sortedVarNames.size() > 0 ) {
        	                    std::vector<CVC4::Type> sorts;
        	                    sorts.reserve(sortedVarNames.size());
        	                    for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                        sortedVarNames.begin(), iend = sortedVarNames.end(); i != iend;
        	                        ++i) {
        	                      sorts.push_back((*i).second);
        	                    }
        	                    t = EXPR_MANAGER->mkFunctionType(sorts, t);
        	                  }
        	                  Expr func = PARSER_STATE->mkVar(fname, t);
        	                  seq->addCommand(new DeclareFunctionCommand(fname, func, t));
        	                  if( sortedVarNames.empty() ){
        	                    func_app = func;
        	                  }else{
        	                    std::vector< Expr > f_app;
        	                    f_app.push_back( func );
        	                    PARSER_STATE->pushScope(true);
        	                    for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                          sortedVarNames.begin(), iend = sortedVarNames.end(); i != iend;
        	                        ++i) {
        	                      Expr v = PARSER_STATE->mkBoundVar((*i).first, (*i).second);
        	                      bvs.push_back( v );
        	                      f_app.push_back( v );
        	                    }
        	                    func_app = MK_EXPR( kind::APPLY_UF, f_app );
        	                  }
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_smt25Command1982);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->popScope(); 
        	                  Expr as = MK_EXPR( kind::EQUAL, func_app, expr);
        	                  if( !bvs.empty() ){
        	                    std::string attr_name("fun-def");
        	                    aexpr = MK_EXPR(kind::INST_ATTRIBUTE, func_app);
        	                    aexpr = MK_EXPR(kind::INST_PATTERN_LIST, aexpr);
        	                    //set the attribute to denote this is a function definition
        	                    seq->addCommand( new SetUserAttributeCommand( attr_name, func_app ) );
        	                    //assert it
        	                    Expr boundVars = EXPR_MANAGER->mkExpr(kind::BOUND_VAR_LIST, bvs);
        	                    as = EXPR_MANAGER->mkExpr(kind::FORALL, boundVars, as, aexpr);
        	                  }
        	                  seq->addCommand( new AssertCommand(as, false) );
        	                  cmd->reset(seq.release());
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1236:5: DEFINE_FUNS_REC_TOK LPAREN_TOK ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )+ RPAREN_TOK LPAREN_TOK ( term[expr,expr2] )+ RPAREN_TOK
        	    {
        	         MATCHT(DEFINE_FUNS_REC_TOK, &FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1995);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet();
        	                  seq.reset(new CVC4::CommandSequence());
        	                
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command2007);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1241:5: ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )+
        	        {
        	            int cnt22=0;

        	            for (;;)
        	            {
        	                int alt22=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt22=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt22)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:1241:7: LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t,CHECK_DECLARED] RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command2015);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_symbol_in_smt25Command2023);
        	        	            symbol(ctx, fname, CHECK_UNDECLARED, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            {
        	        	                 PARSER_STATE->checkUserSymbol(fname); 
        	        	            }


        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command2040);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortedVarList_in_smt25Command2042);
        	        	            sortedVarList(ctx, sortedVarNames);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command2045);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortSymbol_in_smt25Command2053);
        	        	            sortSymbol(ctx, t, CHECK_DECLARED);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            {
        	        	                 sortedVarNamesList.push_back( sortedVarNames );
        	        	                        if( sortedVarNamesList[0].size() > 0 ) {
        	        	                          if( !sortedVarNames.empty() ){
        	        	                            std::vector<CVC4::Type> sorts;
        	        	                            for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator
        	        	                                    i = sortedVarNames.begin(), iend = sortedVarNames.end();
        	        	                                i != iend; ++i) {
        	        	                              sorts.push_back((*i).second);
        	        	                            }
        	        	                            t = EXPR_MANAGER->mkFunctionType(sorts, t);
        	        	                          }
        	        	                        }
        	        	                        sortedVarNames.clear();
        	        	                        Expr func = PARSER_STATE->mkVar(fname, t);
        	        	                        seq->addCommand(new DeclareFunctionCommand(fname, func, t));
        	        	                        funcs.push_back( func );
        	        	                      
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command2070);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt22 >= 1 )
        	        		{
        	        		    goto loop22;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulesmt25CommandEx;
        	        	}
        	        	cnt22++;
        	            }
        	            loop22: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command2083);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command2089);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             
        	                  //set up the first scope 
        	                  if( sortedVarNamesList.empty() ){
        	                    PARSER_STATE->parseError("Must define at least one function in "
        	                                             "define-funs-rec");
        	                  }
        	                  PARSER_STATE->pushScope(true);
        	                  bvs.clear();
        	                  if( sortedVarNamesList[0].empty() ){
        	                    func_app = funcs[0];
        	                  }else{
        	                    std::vector< Expr > f_app;
        	                    f_app.push_back( funcs[0] );
        	                    for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator
        	                          i = sortedVarNamesList[0].begin(),
        	                          iend = sortedVarNamesList[0].end(); i != iend; ++i) {
        	                      Expr v = PARSER_STATE->mkBoundVar((*i).first, (*i).second);
        	                      bvs.push_back( v );
        	                      f_app.push_back( v );
        	                    }
        	                    func_app = MK_EXPR( kind::APPLY_UF, f_app );
        	                  }
        	                
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1290:5: ( term[expr,expr2] )+
        	        {
        	            int cnt23=0;

        	            for (;;)
        	            {
        	                int alt23=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case BINARY_LITERAL:
        	        	case CHECK_SYNTH_TOK:
        	        	case CONSTRAINT_TOK:
        	        	case DECIMAL_LITERAL:
        	        	case DECLARE_PRIMED_VAR_TOK:
        	        	case DECLARE_VAR_TOK:
        	        	case EMPTYSET_TOK:
        	        	case FP_RNA_FULL_TOK:
        	        	case FP_RNA_TOK:
        	        	case FP_RNE_FULL_TOK:
        	        	case FP_RNE_TOK:
        	        	case FP_RTN_FULL_TOK:
        	        	case FP_RTN_TOK:
        	        	case FP_RTP_FULL_TOK:
        	        	case FP_RTP_TOK:
        	        	case FP_RTZ_FULL_TOK:
        	        	case FP_RTZ_TOK:
        	        	case HEX_LITERAL:
        	        	case INTEGER_LITERAL:
        	        	case INV_CONSTRAINT_TOK:
        	        	case LPAREN_TOK:
        	        	case NILREF_TOK:
        	        	case QUOTED_SYMBOL:
        	        	case REALLCHAR_TOK:
        	        	case RENOSTR_TOK:
        	        	case SET_OPTIONS_TOK:
        	        	case SIMPLE_SYMBOL:
        	        	case STRING_LITERAL_2_0:
        	        	case STRING_LITERAL_2_5:
        	        	case SYNTH_FUN_TOK:
        	        	case SYNTH_INV_TOK:
        	        	case UNIVSET_TOK:
        	        	case UNTERMINATED_QUOTED_SYMBOL:
        	        	case 147:
        	        		{
        	        			alt23=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt23)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:1291:5: term[expr,expr2]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_term_in_smt25Command2107);
        	        	            term(ctx, expr, expr2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            {
        	        	                 
        	        	                      func_defs.push_back( expr );
        	        	                      Expr as = MK_EXPR( kind::EQUAL, func_app, expr );
        	        	                      if( !bvs.empty() ){
        	        	                        std::string attr_name("fun-def");
        	        	                        aexpr = MK_EXPR(kind::INST_ATTRIBUTE, func_app);
        	        	                        aexpr = MK_EXPR(kind::INST_PATTERN_LIST, aexpr );
        	        	                        //set the attribute to denote these are function definitions
        	        	                        seq->addCommand( new SetUserAttributeCommand( attr_name, func_app ) );
        	        	                        //assert it
        	        	                        as = EXPR_MANAGER->mkExpr( kind::FORALL,
        	        	                                      EXPR_MANAGER->mkExpr(kind::BOUND_VAR_LIST, bvs),
        	        	                                      as, aexpr);
        	        	                      }
        	        	                      seq->addCommand( new AssertCommand(as, false) );
        	        	                      //set up the next scope 
        	        	                      PARSER_STATE->popScope();
        	        	                      if( func_defs.size()<funcs.size() ){
        	        	                        PARSER_STATE->pushScope(true);
        	        	                        bvs.clear();
        	        	                        unsigned j = func_defs.size();
        	        	                        if( sortedVarNamesList[j].empty() ){
        	        	                          func_app = funcs[j];
        	        	                        }else{
        	        	                          std::vector< Expr > f_app;
        	        	                          f_app.push_back( funcs[j] );
        	        	                          for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator
        	        	                                  i = sortedVarNamesList[j].begin(),
        	        	                                  iend = sortedVarNamesList[j].end(); i != iend; ++i) {
        	        	                            Expr v = PARSER_STATE->mkBoundVar((*i).first, (*i).second);
        	        	                            bvs.push_back( v );
        	        	                            f_app.push_back( v );
        	        	                          }
        	        	                          func_app = MK_EXPR( kind::APPLY_UF, f_app );
        	        	                        }
        	        	                      }
        	        	                    
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt23 >= 1 )
        	        		{
        	        		    goto loop23;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulesmt25CommandEx;
        	        	}
        	        	cnt23++;
        	            }
        	            loop23: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command2127);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             if( funcs.size()!=func_defs.size() ){
        	                    PARSER_STATE->parseError(std::string(
        	                        "Number of functions defined does not match number listed in "
        	                        "define-funs-rec"));
        	                  }
        	                  cmd->reset(seq.release());
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesmt25CommandEx; /* Prevent compiler warnings */
    rulesmt25CommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end smt25Command */

/**
 * $ANTLR start extendedCommand
 * ../../../../../../src/parser/smt2/Smt2.g:1342:1: extendedCommand[CVC4::PtrCloser<CVC4::Command>* cmd] : ( DECLARE_DATATYPES_TOK datatypesDefCommand[false, cmd] | DECLARE_CODATATYPES_TOK datatypesDefCommand[true, cmd] | rewriterulesCommand[cmd] | DECLARE_SORTS_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )+ RPAREN_TOK | DECLARE_FUNS_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] nonemptySortList[sorts] RPAREN_TOK )+ RPAREN_TOK | DECLARE_PREDS_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortList[sorts] RPAREN_TOK )+ RPAREN_TOK | DEFINE_TOK ( symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] | LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortedVarList[sortedVarNames] RPAREN_TOK term[e,e2] ) | DEFINE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] term[e, e2] | SIMPLIFY_TOK term[e,e2] | GET_QE_TOK term[e,e2] | GET_QE_DISJUNCT_TOK term[e,e2] );
 */
static void
extendedCommand(pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{

      std::vector<CVC4::Datatype> dts;
      Expr e, e2;
      Type t;
      std::string name;
      std::vector<std::string> names;
      std::vector<Expr> terms;
      std::vector<Type> sorts;
      std::vector<std::pair<std::string, Type> > sortedVarNames;
      CVC4::PtrCloser<CVC4::CommandSequence> seq;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1356:3: ( DECLARE_DATATYPES_TOK datatypesDefCommand[false, cmd] | DECLARE_CODATATYPES_TOK datatypesDefCommand[true, cmd] | rewriterulesCommand[cmd] | DECLARE_SORTS_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )+ RPAREN_TOK | DECLARE_FUNS_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] nonemptySortList[sorts] RPAREN_TOK )+ RPAREN_TOK | DECLARE_PREDS_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortList[sorts] RPAREN_TOK )+ RPAREN_TOK | DEFINE_TOK ( symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] | LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortedVarList[sortedVarNames] RPAREN_TOK term[e,e2] ) | DEFINE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] term[e, e2] | SIMPLIFY_TOK term[e,e2] | GET_QE_TOK term[e,e2] | GET_QE_DISJUNCT_TOK term[e,e2] )

            ANTLR3_UINT32 alt29;

            alt29=11;

            switch ( LA(1) )
            {
            case DECLARE_DATATYPES_TOK:
            	{
            		alt29=1;
            	}
                break;
            case DECLARE_CODATATYPES_TOK:
            	{
            		alt29=2;
            	}
                break;
            case PROPAGATION_RULE_TOK:
            case REDUCTION_RULE_TOK:
            case REWRITE_RULE_TOK:
            	{
            		alt29=3;
            	}
                break;
            case DECLARE_SORTS_TOK:
            	{
            		alt29=4;
            	}
                break;
            case DECLARE_FUNS_TOK:
            	{
            		alt29=5;
            	}
                break;
            case DECLARE_PREDS_TOK:
            	{
            		alt29=6;
            	}
                break;
            case DEFINE_TOK:
            	{
            		alt29=7;
            	}
                break;
            case DEFINE_CONST_TOK:
            	{
            		alt29=8;
            	}
                break;
            case SIMPLIFY_TOK:
            	{
            		alt29=9;
            	}
                break;
            case GET_QE_TOK:
            	{
            		alt29=10;
            	}
                break;
            case GET_QE_DISJUNCT_TOK:
            	{
            		alt29=11;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto ruleextendedCommandEx;

            }

            switch (alt29)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1356:5: DECLARE_DATATYPES_TOK datatypesDefCommand[false, cmd]
        	    {
        	         MATCHT(DECLARE_DATATYPES_TOK, &FOLLOW_DECLARE_DATATYPES_TOK_in_extendedCommand2164);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_datatypesDefCommand_in_extendedCommand2166);
        	        datatypesDefCommand(ctx, false, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1357:5: DECLARE_CODATATYPES_TOK datatypesDefCommand[true, cmd]
        	    {
        	         MATCHT(DECLARE_CODATATYPES_TOK, &FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2173);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_datatypesDefCommand_in_extendedCommand2175);
        	        datatypesDefCommand(ctx, true, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1358:5: rewriterulesCommand[cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_rewriterulesCommand_in_extendedCommand2182);
        	        rewriterulesCommand(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1362:5: DECLARE_SORTS_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )+ RPAREN_TOK
        	    {
        	         MATCHT(DECLARE_SORTS_TOK, &FOLLOW_DECLARE_SORTS_TOK_in_extendedCommand2197);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             if(!PARSER_STATE->isTheoryEnabled(Smt2::THEORY_UF) &&
        	                     !PARSER_STATE->isTheoryEnabled(Smt2::THEORY_ARRAYS) &&
        	                     !PARSER_STATE->isTheoryEnabled(Smt2::THEORY_DATATYPES) &&
        	                     !PARSER_STATE->isTheoryEnabled(Smt2::THEORY_SETS)) {
        	                    PARSER_STATE->parseErrorLogic("Free sort symbols not allowed in ");
        	                  }
        	                
        	        }


        	        {
        	             seq.reset(new CVC4::CommandSequence()); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2217);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1372:5: ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )+
        	        {
        	            int cnt25=0;

        	            for (;;)
        	            {
        	                int alt25=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case CHECK_SYNTH_TOK:
        	        	case CONSTRAINT_TOK:
        	        	case DECLARE_PRIMED_VAR_TOK:
        	        	case DECLARE_VAR_TOK:
        	        	case INV_CONSTRAINT_TOK:
        	        	case QUOTED_SYMBOL:
        	        	case SET_OPTIONS_TOK:
        	        	case SIMPLE_SYMBOL:
        	        	case SYNTH_FUN_TOK:
        	        	case SYNTH_INV_TOK:
        	        	case UNTERMINATED_QUOTED_SYMBOL:
        	        	case 147:
        	        		{
        	        			alt25=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt25)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:1372:7: symbol[name,CHECK_UNDECLARED,SYM_SORT]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2225);
        	        	            symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	            {
        	        	                 PARSER_STATE->checkUserSymbol(name);
        	        	                        Type type = PARSER_STATE->mkSort(name);
        	        	                        seq->addCommand(new DeclareTypeCommand(name, 0, type));
        	        	                      
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt25 >= 1 )
        	        		{
        	        		    goto loop25;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleextendedCommandEx;
        	        	}
        	        	cnt25++;
        	            }
        	            loop25: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2247);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(seq.release()); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1381:5: DECLARE_FUNS_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] nonemptySortList[sorts] RPAREN_TOK )+ RPAREN_TOK
        	    {
        	         MATCHT(DECLARE_FUNS_TOK, &FOLLOW_DECLARE_FUNS_TOK_in_extendedCommand2260);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             seq.reset(new CVC4::CommandSequence()); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2274);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1384:5: ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] nonemptySortList[sorts] RPAREN_TOK )+
        	        {
        	            int cnt26=0;

        	            for (;;)
        	            {
        	                int alt26=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt26=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt26)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:1384:7: LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] nonemptySortList[sorts] RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2282);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2284);
        	        	            symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	            {
        	        	                 PARSER_STATE->checkUserSymbol(name); 
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_nonemptySortList_in_extendedCommand2301);
        	        	            nonemptySortList(ctx, sorts);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2304);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	            {
        	        	                 Type t;
        	        	                        if(sorts.size() > 1) {
        	        	                          if(!PARSER_STATE->isTheoryEnabled(Smt2::THEORY_UF)) {
        	        	                            PARSER_STATE->parseErrorLogic("Functions (of non-zero arity) "
        	        	                                                          "cannot be declared in logic ");
        	        	                          }
        	        	                          t = EXPR_MANAGER->mkFunctionType(sorts);
        	        	                        } else {
        	        	                          t = sorts[0];
        	        	                        }
        	        	                        Expr func = PARSER_STATE->mkVar(name, t);
        	        	                        seq->addCommand(new DeclareFunctionCommand(name, func, t));
        	        	                        sorts.clear();
        	        	                      
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt26 >= 1 )
        	        		{
        	        		    goto loop26;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleextendedCommandEx;
        	        	}
        	        	cnt26++;
        	            }
        	            loop26: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2325);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(seq.release()); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1404:5: DECLARE_PREDS_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortList[sorts] RPAREN_TOK )+ RPAREN_TOK
        	    {
        	         MATCHT(DECLARE_PREDS_TOK, &FOLLOW_DECLARE_PREDS_TOK_in_extendedCommand2338);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             seq.reset(new CVC4::CommandSequence()); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2352);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1407:5: ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortList[sorts] RPAREN_TOK )+
        	        {
        	            int cnt27=0;

        	            for (;;)
        	            {
        	                int alt27=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt27=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt27)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:1407:7: LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortList[sorts] RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2360);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2362);
        	        	            symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	            {
        	        	                 PARSER_STATE->checkUserSymbol(name); 
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortList_in_extendedCommand2379);
        	        	            sortList(ctx, sorts);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2382);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleextendedCommandEx;
        	        	            }


        	        	            {
        	        	                 Type t = EXPR_MANAGER->booleanType();
        	        	                        if(sorts.size() > 0) {
        	        	                          if(!PARSER_STATE->isTheoryEnabled(Smt2::THEORY_UF)) {
        	        	                            PARSER_STATE->parseErrorLogic("Predicates (of non-zero arity) "
        	        	                                                          "cannot be declared in logic ");
        	        	                          }
        	        	                          t = EXPR_MANAGER->mkFunctionType(sorts, t);
        	        	                        }
        	        	                        Expr func = PARSER_STATE->mkVar(name, t);
        	        	                        seq->addCommand(new DeclareFunctionCommand(name, func, t));
        	        	                        sorts.clear();
        	        	                      
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt27 >= 1 )
        	        		{
        	        		    goto loop27;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleextendedCommandEx;
        	        	}
        	        	cnt27++;
        	            }
        	            loop27: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2403);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(seq.release()); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1426:5: DEFINE_TOK ( symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] | LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortedVarList[sortedVarNames] RPAREN_TOK term[e,e2] )
        	    {
        	         MATCHT(DEFINE_TOK, &FOLLOW_DEFINE_TOK_in_extendedCommand2416);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1427:5: ( symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] | LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortedVarList[sortedVarNames] RPAREN_TOK term[e,e2] )
        	        {
        	            int alt28=2;
        	            switch ( LA(1) )
        	            {
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_VAR_TOK:
        	            case INV_CONSTRAINT_TOK:
        	            case QUOTED_SYMBOL:
        	            case SET_OPTIONS_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case 147:
        	            	{
        	            		alt28=1;
        	            	}
        	                break;
        	            case LPAREN_TOK:
        	            	{
        	            		alt28=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 28;
        	                EXCEPTION->state        = 0;


        	                goto ruleextendedCommandEx;

        	            }

        	            switch (alt28)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1427:7: symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2426);
        	        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->checkUserSymbol(name); 
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2443);
        	        	        term(ctx, e, e2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             Expr func = PARSER_STATE->mkFunction(name, e.getType(),
        	        	                                                         ExprManager::VAR_FLAG_DEFINED);
        	        	                    cmd->reset(new DefineFunctionCommand(name, func, e));
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1434:7: LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortedVarList[sortedVarNames] RPAREN_TOK term[e,e2]
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2460);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2468);
        	        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->checkUserSymbol(name); 
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_extendedCommand2485);
        	        	        sortedVarList(ctx, sortedVarNames);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2488);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             /* add variables to parser state before parsing term */
        	        	                    Debug("parser") << "define fun: '" << name << "'" << std::endl;
        	        	                    PARSER_STATE->pushScope(true);
        	        	                    for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	        	                          sortedVarNames.begin(), iend = sortedVarNames.end(); i != iend;
        	        	                        ++i) {
        	        	                      terms.push_back(PARSER_STATE->mkBoundVar((*i).first, (*i).second));
        	        	                    }
        	        	                  
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2504);
        	        	        term(ctx, e, e2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->popScope();
        	        	                    // declare the name down here (while parsing term, signature
        	        	                    // must not be extended with the name itself; no recursion
        	        	                    // permitted)
        	        	                    Type t = e.getType();
        	        	                    if( sortedVarNames.size() > 0 ) {
        	        	                      std::vector<CVC4::Type> sorts;
        	        	                      sorts.reserve(sortedVarNames.size());
        	        	                      for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator
        	        	                            i = sortedVarNames.begin(), iend = sortedVarNames.end();
        	        	                          i != iend; ++i) {
        	        	                        sorts.push_back((*i).second);
        	        	                      }
        	        	                      t = EXPR_MANAGER->mkFunctionType(sorts, t);
        	        	                    }
        	        	                    Expr func = PARSER_STATE->mkFunction(name, t,
        	        	                                                         ExprManager::VAR_FLAG_DEFINED);
        	        	                    cmd->reset(new DefineFunctionCommand(name, func, terms, e));
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1468:5: DEFINE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] term[e, e2]
        	    {
        	         MATCHT(DEFINE_CONST_TOK, &FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2525);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2533);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_extendedCommand2546);
        	        sortSymbol(ctx, t, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             /* add variables to parser state before parsing term */
        	                  Debug("parser") << "define const: '" << name << "'" << std::endl;
        	                  PARSER_STATE->pushScope(true);
        	                  for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                        sortedVarNames.begin(), iend = sortedVarNames.end(); i != iend;
        	                      ++i) {
        	                    terms.push_back(PARSER_STATE->mkBoundVar((*i).first, (*i).second));
        	                  }
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2559);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  // declare the name down here (while parsing term, signature
        	                  // must not be extended with the name itself; no recursion
        	                  // permitted)
        	                  Expr func = PARSER_STATE->mkFunction(name, t,
        	                                                       ExprManager::VAR_FLAG_DEFINED);
        	                  cmd->reset(new DefineFunctionCommand(name, func, terms, e));
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1491:5: SIMPLIFY_TOK term[e,e2]
        	    {
        	         MATCHT(SIMPLIFY_TOK, &FOLLOW_SIMPLIFY_TOK_in_extendedCommand2573);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2581);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(new SimplifyCommand(e)); 
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1494:5: GET_QE_TOK term[e,e2]
        	    {
        	         MATCHT(GET_QE_TOK, &FOLLOW_GET_QE_TOK_in_extendedCommand2594);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2602);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(new GetQuantifierEliminationCommand(e, true)); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1497:5: GET_QE_DISJUNCT_TOK term[e,e2]
        	    {
        	         MATCHT(GET_QE_DISJUNCT_TOK, &FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2615);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2623);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(new GetQuantifierEliminationCommand(e, false)); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextendedCommandEx; /* Prevent compiler warnings */
    ruleextendedCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end extendedCommand */

/**
 * $ANTLR start datatypesDefCommand
 * ../../../../../../src/parser/smt2/Smt2.g:1503:1: datatypesDefCommand[bool isCo, CVC4::PtrCloser<CVC4::Command>* cmd] : LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK datatypeDef[isCo, dts, sorts] RPAREN_TOK )+ RPAREN_TOK ;
 */
static void
datatypesDefCommand(pSmt2Parser ctx, bool isCo, CVC4::PtrCloser<CVC4::Command>* cmd)
{

      std::vector<CVC4::Datatype> dts;
      std::string name;
      std::vector<Type> sorts;

    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:1509:3: ( LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK datatypeDef[isCo, dts, sorts] RPAREN_TOK )+ RPAREN_TOK )
        // ../../../../../../src/parser/smt2/Smt2.g:1509:5: LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK datatypeDef[isCo, dts, sorts] RPAREN_TOK )+ RPAREN_TOK
        {
            {
                 PARSER_STATE->checkThatLogicIsSet();
                    /* open a scope to keep the UnresolvedTypes contained */
                    PARSER_STATE->pushScope(true); 
            }


             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDefCommand2654);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


            // ../../../../../../src/parser/smt2/Smt2.g:1513:3: ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )*

            for (;;)
            {
                int alt30=2;
                switch ( LA(1) )
                {
                case CHECK_SYNTH_TOK:
                case CONSTRAINT_TOK:
                case DECLARE_PRIMED_VAR_TOK:
                case DECLARE_VAR_TOK:
                case INV_CONSTRAINT_TOK:
                case QUOTED_SYMBOL:
                case SET_OPTIONS_TOK:
                case SIMPLE_SYMBOL:
                case SYNTH_FUN_TOK:
                case SYNTH_INV_TOK:
                case UNTERMINATED_QUOTED_SYMBOL:
                case 147:
                	{
                		alt30=1;
                	}
                    break;

                }

                switch (alt30)
                {
            	case 1:
            	    // ../../../../../../src/parser/smt2/Smt2.g:1513:5: symbol[name,CHECK_UNDECLARED,SYM_SORT]
            	    {
            	        FOLLOWPUSH(FOLLOW_symbol_in_datatypesDefCommand2662);
            	        symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypesDefCommandEx;
            	        }


            	        {
            	             sorts.push_back( PARSER_STATE->mkSort(name) ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop30;	/* break out of the loop */
            	    break;
                }
            }
            loop30: ; /* Jump out to here if this rule does not match */


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDefCommand2678);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDefCommand2682);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


            // ../../../../../../src/parser/smt2/Smt2.g:1517:14: ( LPAREN_TOK datatypeDef[isCo, dts, sorts] RPAREN_TOK )+
            {
                int cnt31=0;

                for (;;)
                {
                    int alt31=2;
            	switch ( LA(1) )
            	{
            	case LPAREN_TOK:
            		{
            			alt31=1;
            		}
            	    break;

            	}

            	switch (alt31)
            	{
            	    case 1:
            	        // ../../../../../../src/parser/smt2/Smt2.g:1517:16: LPAREN_TOK datatypeDef[isCo, dts, sorts] RPAREN_TOK
            	        {
            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDefCommand2686);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypesDefCommandEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_datatypeDef_in_datatypesDefCommand2688);
            	            datatypeDef(ctx, isCo, dts, sorts);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypesDefCommandEx;
            	            }


            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDefCommand2691);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypesDefCommandEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt31 >= 1 )
            		{
            		    goto loop31;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledatatypesDefCommandEx;
            	}
            	cnt31++;
                }
                loop31: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDefCommand2696);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


            {
                 PARSER_STATE->popScope();
                    cmd->reset(new DatatypeDeclarationCommand(
                        PARSER_STATE->mkMutualDatatypeTypes(dts)));
                  
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledatatypesDefCommandEx; /* Prevent compiler warnings */
    ruledatatypesDefCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end datatypesDefCommand */

/**
 * $ANTLR start rewriterulesCommand
 * ../../../../../../src/parser/smt2/Smt2.g:1524:1: rewriterulesCommand[CVC4::PtrCloser<CVC4::Command>* cmd] : ( REWRITE_RULE_TOK LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK LPAREN_TOK ( pattern[expr] )* RPAREN_TOK LPAREN_TOK ( termList[guards,expr] )? RPAREN_TOK term[head, expr2] term[body, expr2] | rewritePropaKind[kind] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK LPAREN_TOK ( pattern[expr] )* RPAREN_TOK LPAREN_TOK ( termList[guards,expr] )? RPAREN_TOK LPAREN_TOK ( termList[heads,expr] )? RPAREN_TOK term[body, expr2] );
 */
static void
rewriterulesCommand(pSmt2Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{

      std::vector<std::pair<std::string, Type> > sortedVarNames;
      std::vector<Expr> args, guards, heads, triggers;
      Expr head, body, expr, expr2, bvl;
      Kind kind;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1531:3: ( REWRITE_RULE_TOK LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK LPAREN_TOK ( pattern[expr] )* RPAREN_TOK LPAREN_TOK ( termList[guards,expr] )? RPAREN_TOK term[head, expr2] term[body, expr2] | rewritePropaKind[kind] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK LPAREN_TOK ( pattern[expr] )* RPAREN_TOK LPAREN_TOK ( termList[guards,expr] )? RPAREN_TOK LPAREN_TOK ( termList[heads,expr] )? RPAREN_TOK term[body, expr2] )

            ANTLR3_UINT32 alt37;

            alt37=2;

            switch ( LA(1) )
            {
            case REWRITE_RULE_TOK:
            	{
            		alt37=1;
            	}
                break;
            case PROPAGATION_RULE_TOK:
            case REDUCTION_RULE_TOK:
            	{
            		alt37=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 37;
                EXCEPTION->state        = 0;


                goto rulerewriterulesCommandEx;

            }

            switch (alt37)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1532:5: REWRITE_RULE_TOK LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK LPAREN_TOK ( pattern[expr] )* RPAREN_TOK LPAREN_TOK ( termList[guards,expr] )? RPAREN_TOK term[head, expr2] term[body, expr2]
        	    {
        	         MATCHT(REWRITE_RULE_TOK, &FOLLOW_REWRITE_RULE_TOK_in_rewriterulesCommand2725);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_rewriterulesCommand2731);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_rewriterulesCommand2733);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_rewriterulesCommand2736);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        {

        	                  kind = CVC4::kind::RR_REWRITE;
        	                  PARSER_STATE->pushScope(true);
        	                  for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                        sortedVarNames.begin(), iend = sortedVarNames.end();
        	                      i != iend;
        	                      ++i) {
        	                    args.push_back(PARSER_STATE->mkBoundVar((*i).first, (*i).second));
        	                  }
        	                  bvl = MK_EXPR(kind::BOUND_VAR_LIST, args);
        	                
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_rewriterulesCommand2748);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1545:16: ( pattern[expr] )*

        	        for (;;)
        	        {
        	            int alt32=2;
        	            switch ( LA(1) )
        	            {
        	            case LPAREN_TOK:
        	            	{
        	            		alt32=1;
        	            	}
        	                break;

        	            }

        	            switch (alt32)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1545:18: pattern[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_pattern_in_rewriterulesCommand2752);
        	        	        pattern(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerewriterulesCommandEx;
        	        	        }


        	        	        {
        	        	             triggers.push_back( expr ); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop32;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop32: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_rewriterulesCommand2760);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_rewriterulesCommand2766);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1546:16: ( termList[guards,expr] )?
        	        {
        	            int alt33=2;
        	            switch ( LA(1) )
        	            {
        	                case BINARY_LITERAL:
        	                case CHECK_SYNTH_TOK:
        	                case CONSTRAINT_TOK:
        	                case DECIMAL_LITERAL:
        	                case DECLARE_PRIMED_VAR_TOK:
        	                case DECLARE_VAR_TOK:
        	                case EMPTYSET_TOK:
        	                case FP_RNA_FULL_TOK:
        	                case FP_RNA_TOK:
        	                case FP_RNE_FULL_TOK:
        	                case FP_RNE_TOK:
        	                case FP_RTN_FULL_TOK:
        	                case FP_RTN_TOK:
        	                case FP_RTP_FULL_TOK:
        	                case FP_RTP_TOK:
        	                case FP_RTZ_FULL_TOK:
        	                case FP_RTZ_TOK:
        	                case HEX_LITERAL:
        	                case INTEGER_LITERAL:
        	                case INV_CONSTRAINT_TOK:
        	                case LPAREN_TOK:
        	                case NILREF_TOK:
        	                case QUOTED_SYMBOL:
        	                case REALLCHAR_TOK:
        	                case RENOSTR_TOK:
        	                case SET_OPTIONS_TOK:
        	                case SIMPLE_SYMBOL:
        	                case STRING_LITERAL_2_0:
        	                case STRING_LITERAL_2_5:
        	                case SYNTH_FUN_TOK:
        	                case SYNTH_INV_TOK:
        	                case UNIVSET_TOK:
        	                case UNTERMINATED_QUOTED_SYMBOL:
        	                case 147:
        	                	{
        	                		alt33=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt33)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1546:17: termList[guards,expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termList_in_rewriterulesCommand2769);
        	        	        termList(ctx, guards, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerewriterulesCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_rewriterulesCommand2774);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_rewriterulesCommand2780);
        	        term(ctx, head, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_rewriterulesCommand2783);
        	        term(ctx, body, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        {

        	                  args.clear();
        	                  args.push_back(head);
        	                  args.push_back(body);
        	                  /* triggers */
        	                  if( !triggers.empty() ){
        	                    expr2 = MK_EXPR(kind::INST_PATTERN_LIST, triggers);
        	                    args.push_back(expr2);
        	                  };
        	                  expr = MK_EXPR(kind, args);
        	                  args.clear();
        	                  args.push_back(bvl);
        	                  /* guards */
        	                  switch( guards.size() ){
        	                  case 0:
        	                    args.push_back(MK_CONST(bool(true))); break;
        	                  case 1:
        	                    args.push_back(guards[0]); break;
        	                  default:
        	                    expr2 = MK_EXPR(kind::AND, guards);
        	                    args.push_back(expr2); break;
        	                  };
        	                  args.push_back(expr);
        	                  expr = MK_EXPR(CVC4::kind::REWRITE_RULE, args);
        	                  cmd->reset(new AssertCommand(expr, false)); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1574:5: rewritePropaKind[kind] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK LPAREN_TOK ( pattern[expr] )* RPAREN_TOK LPAREN_TOK ( termList[guards,expr] )? RPAREN_TOK LPAREN_TOK ( termList[heads,expr] )? RPAREN_TOK term[body, expr2]
        	    {
        	        FOLLOWPUSH(FOLLOW_rewritePropaKind_in_rewriterulesCommand2802);
        	        rewritePropaKind(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_rewriterulesCommand2809);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_rewriterulesCommand2811);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_rewriterulesCommand2814);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->pushScope(true);
        	                  for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                        sortedVarNames.begin(), iend = sortedVarNames.end();
        	                      i != iend;
        	                      ++i) {
        	                    args.push_back(PARSER_STATE->mkBoundVar((*i).first, (*i).second));
        	                  }
        	                  bvl = MK_EXPR(kind::BOUND_VAR_LIST, args);
        	                
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_rewriterulesCommand2826);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1586:16: ( pattern[expr] )*

        	        for (;;)
        	        {
        	            int alt34=2;
        	            switch ( LA(1) )
        	            {
        	            case LPAREN_TOK:
        	            	{
        	            		alt34=1;
        	            	}
        	                break;

        	            }

        	            switch (alt34)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1586:18: pattern[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_pattern_in_rewriterulesCommand2830);
        	        	        pattern(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerewriterulesCommandEx;
        	        	        }


        	        	        {
        	        	             triggers.push_back( expr ); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop34;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop34: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_rewriterulesCommand2838);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_rewriterulesCommand2844);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1587:16: ( termList[guards,expr] )?
        	        {
        	            int alt35=2;
        	            switch ( LA(1) )
        	            {
        	                case BINARY_LITERAL:
        	                case CHECK_SYNTH_TOK:
        	                case CONSTRAINT_TOK:
        	                case DECIMAL_LITERAL:
        	                case DECLARE_PRIMED_VAR_TOK:
        	                case DECLARE_VAR_TOK:
        	                case EMPTYSET_TOK:
        	                case FP_RNA_FULL_TOK:
        	                case FP_RNA_TOK:
        	                case FP_RNE_FULL_TOK:
        	                case FP_RNE_TOK:
        	                case FP_RTN_FULL_TOK:
        	                case FP_RTN_TOK:
        	                case FP_RTP_FULL_TOK:
        	                case FP_RTP_TOK:
        	                case FP_RTZ_FULL_TOK:
        	                case FP_RTZ_TOK:
        	                case HEX_LITERAL:
        	                case INTEGER_LITERAL:
        	                case INV_CONSTRAINT_TOK:
        	                case LPAREN_TOK:
        	                case NILREF_TOK:
        	                case QUOTED_SYMBOL:
        	                case REALLCHAR_TOK:
        	                case RENOSTR_TOK:
        	                case SET_OPTIONS_TOK:
        	                case SIMPLE_SYMBOL:
        	                case STRING_LITERAL_2_0:
        	                case STRING_LITERAL_2_5:
        	                case SYNTH_FUN_TOK:
        	                case SYNTH_INV_TOK:
        	                case UNIVSET_TOK:
        	                case UNTERMINATED_QUOTED_SYMBOL:
        	                case 147:
        	                	{
        	                		alt35=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt35)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1587:17: termList[guards,expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termList_in_rewriterulesCommand2847);
        	        	        termList(ctx, guards, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerewriterulesCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_rewriterulesCommand2852);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_rewriterulesCommand2858);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1588:16: ( termList[heads,expr] )?
        	        {
        	            int alt36=2;
        	            switch ( LA(1) )
        	            {
        	                case BINARY_LITERAL:
        	                case CHECK_SYNTH_TOK:
        	                case CONSTRAINT_TOK:
        	                case DECIMAL_LITERAL:
        	                case DECLARE_PRIMED_VAR_TOK:
        	                case DECLARE_VAR_TOK:
        	                case EMPTYSET_TOK:
        	                case FP_RNA_FULL_TOK:
        	                case FP_RNA_TOK:
        	                case FP_RNE_FULL_TOK:
        	                case FP_RNE_TOK:
        	                case FP_RTN_FULL_TOK:
        	                case FP_RTN_TOK:
        	                case FP_RTP_FULL_TOK:
        	                case FP_RTP_TOK:
        	                case FP_RTZ_FULL_TOK:
        	                case FP_RTZ_TOK:
        	                case HEX_LITERAL:
        	                case INTEGER_LITERAL:
        	                case INV_CONSTRAINT_TOK:
        	                case LPAREN_TOK:
        	                case NILREF_TOK:
        	                case QUOTED_SYMBOL:
        	                case REALLCHAR_TOK:
        	                case RENOSTR_TOK:
        	                case SET_OPTIONS_TOK:
        	                case SIMPLE_SYMBOL:
        	                case STRING_LITERAL_2_0:
        	                case STRING_LITERAL_2_5:
        	                case SYNTH_FUN_TOK:
        	                case SYNTH_INV_TOK:
        	                case UNIVSET_TOK:
        	                case UNTERMINATED_QUOTED_SYMBOL:
        	                case 147:
        	                	{
        	                		alt36=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt36)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1588:17: termList[heads,expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termList_in_rewriterulesCommand2861);
        	        	        termList(ctx, heads, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulerewriterulesCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_rewriterulesCommand2866);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_rewriterulesCommand2872);
        	        term(ctx, body, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewriterulesCommandEx;
        	        }


        	        {

        	                  args.clear();
        	                  /* heads */
        	                  switch( heads.size() ){
        	                  case 0:
        	                    args.push_back(MK_CONST(bool(true))); break;
        	                  case 1:
        	                    args.push_back(heads[0]); break;
        	                  default:
        	                    expr2 = MK_EXPR(kind::AND, heads);
        	                    args.push_back(expr2); break;
        	                  };
        	                  args.push_back(body);
        	                  /* triggers */
        	                  if( !triggers.empty() ){
        	                    expr2 = MK_EXPR(kind::INST_PATTERN_LIST, triggers);
        	                    args.push_back(expr2);
        	                  };
        	                  expr = MK_EXPR(kind, args);
        	                  args.clear();
        	                  args.push_back(bvl);
        	                  /* guards */
        	                  switch( guards.size() ){
        	                  case 0:
        	                    args.push_back(MK_CONST(bool(true))); break;
        	                  case 1:
        	                    args.push_back(guards[0]); break;
        	                  default:
        	                    expr2 = MK_EXPR(kind::AND, guards);
        	                    args.push_back(expr2); break;
        	                  };
        	                  args.push_back(expr);
        	                  expr = MK_EXPR(CVC4::kind::REWRITE_RULE, args);
        	                  cmd->reset(new AssertCommand(expr, false));
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulerewriterulesCommandEx; /* Prevent compiler warnings */
    rulerewriterulesCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end rewriterulesCommand */

/**
 * $ANTLR start rewritePropaKind
 * ../../../../../../src/parser/smt2/Smt2.g:1627:1: rewritePropaKind[CVC4::Kind& kind] : ( REDUCTION_RULE_TOK | PROPAGATION_RULE_TOK );
 */
static void
rewritePropaKind(pSmt2Parser ctx, CVC4::Kind& kind)
{
    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1628:3: ( REDUCTION_RULE_TOK | PROPAGATION_RULE_TOK )

            ANTLR3_UINT32 alt38;

            alt38=2;

            switch ( LA(1) )
            {
            case REDUCTION_RULE_TOK:
            	{
            		alt38=1;
            	}
                break;
            case PROPAGATION_RULE_TOK:
            	{
            		alt38=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 38;
                EXCEPTION->state        = 0;


                goto rulerewritePropaKindEx;

            }

            switch (alt38)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1628:5: REDUCTION_RULE_TOK
        	    {
        	         MATCHT(REDUCTION_RULE_TOK, &FOLLOW_REDUCTION_RULE_TOK_in_rewritePropaKind2893);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewritePropaKindEx;
        	        }


        	        {
        	             kind= CVC4::kind::RR_REDUCTION; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1629:5: PROPAGATION_RULE_TOK
        	    {
        	         MATCHT(PROPAGATION_RULE_TOK, &FOLLOW_PROPAGATION_RULE_TOK_in_rewritePropaKind2904);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerewritePropaKindEx;
        	        }


        	        {
        	             kind= CVC4::kind::RR_DEDUCTION; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulerewritePropaKindEx; /* Prevent compiler warnings */
    rulerewritePropaKindEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end rewritePropaKind */

/**
 * $ANTLR start pattern
 * ../../../../../../src/parser/smt2/Smt2.g:1632:1: pattern[CVC4::Expr& expr] : LPAREN_TOK termList[patexpr,expr] RPAREN_TOK ;
 */
static void
pattern(pSmt2Parser ctx, CVC4::Expr& expr)
{

      std::vector<Expr> patexpr;

    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:1636:3: ( LPAREN_TOK termList[patexpr,expr] RPAREN_TOK )
        // ../../../../../../src/parser/smt2/Smt2.g:1636:5: LPAREN_TOK termList[patexpr,expr] RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_pattern2926);
            if  (HASEXCEPTION())
            {
                goto rulepatternEx;
            }


            FOLLOWPUSH(FOLLOW_termList_in_pattern2928);
            termList(ctx, patexpr, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepatternEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_pattern2931);
            if  (HASEXCEPTION())
            {
                goto rulepatternEx;
            }


            {

                      expr = MK_EXPR(kind::INST_PATTERN, patexpr);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepatternEx; /* Prevent compiler warnings */
    rulepatternEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end pattern */

/**
 * $ANTLR start simpleSymbolicExprNoKeyword
 * ../../../../../../src/parser/smt2/Smt2.g:1642:1: simpleSymbolicExprNoKeyword[CVC4::SExpr& sexpr] : ( INTEGER_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | BINARY_LITERAL | str[s,false] | symbol[s,CHECK_NONE,SYM_SORT] |tok= ( ASSERT_TOK | CHECKSAT_TOK | DECLARE_FUN_TOK | DECLARE_SORT_TOK | DEFINE_FUN_TOK | DEFINE_FUN_REC_TOK | DEFINE_FUNS_REC_TOK | DEFINE_SORT_TOK | GET_VALUE_TOK | GET_ASSIGNMENT_TOK | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_CORE_TOK | EXIT_TOK | RESET_TOK | RESET_ASSERTIONS_TOK | SET_LOGIC_TOK | SET_INFO_TOK | GET_INFO_TOK | SET_OPTION_TOK | GET_OPTION_TOK | PUSH_TOK | POP_TOK | DECLARE_DATATYPES_TOK | GET_MODEL_TOK | ECHO_TOK | REWRITE_RULE_TOK | REDUCTION_RULE_TOK | PROPAGATION_RULE_TOK | SIMPLIFY_TOK ) | builtinOp[k] );
 */
static void
simpleSymbolicExprNoKeyword(pSmt2Parser ctx, CVC4::SExpr& sexpr)
{

      CVC4::Kind k;
      std::string s;
      std::vector<unsigned int> s_vec;

    pANTLR3_COMMON_TOKEN    tok;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL8;
    pANTLR3_COMMON_TOKEN    DECIMAL_LITERAL9;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL10;
    pANTLR3_COMMON_TOKEN    BINARY_LITERAL11;

    /* Initialize rule variables
     */

    tok       = NULL;
    INTEGER_LITERAL8       = NULL;
    DECIMAL_LITERAL9       = NULL;
    HEX_LITERAL10       = NULL;
    BINARY_LITERAL11       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1648:3: ( INTEGER_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | BINARY_LITERAL | str[s,false] | symbol[s,CHECK_NONE,SYM_SORT] |tok= ( ASSERT_TOK | CHECKSAT_TOK | DECLARE_FUN_TOK | DECLARE_SORT_TOK | DEFINE_FUN_TOK | DEFINE_FUN_REC_TOK | DEFINE_FUNS_REC_TOK | DEFINE_SORT_TOK | GET_VALUE_TOK | GET_ASSIGNMENT_TOK | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_CORE_TOK | EXIT_TOK | RESET_TOK | RESET_ASSERTIONS_TOK | SET_LOGIC_TOK | SET_INFO_TOK | GET_INFO_TOK | SET_OPTION_TOK | GET_OPTION_TOK | PUSH_TOK | POP_TOK | DECLARE_DATATYPES_TOK | GET_MODEL_TOK | ECHO_TOK | REWRITE_RULE_TOK | REDUCTION_RULE_TOK | PROPAGATION_RULE_TOK | SIMPLIFY_TOK ) | builtinOp[k] )

            ANTLR3_UINT32 alt39;

            alt39=8;

            switch ( LA(1) )
            {
            case INTEGER_LITERAL:
            	{
            		alt39=1;
            	}
                break;
            case DECIMAL_LITERAL:
            	{
            		alt39=2;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt39=3;
            	}
                break;
            case BINARY_LITERAL:
            	{
            		alt39=4;
            	}
                break;
            case STRING_LITERAL_2_0:
            case STRING_LITERAL_2_5:
            	{
            		alt39=5;
            	}
                break;
            case CHECK_SYNTH_TOK:
            case CONSTRAINT_TOK:
            case DECLARE_PRIMED_VAR_TOK:
            case DECLARE_VAR_TOK:
            case INV_CONSTRAINT_TOK:
            case QUOTED_SYMBOL:
            case SET_OPTIONS_TOK:
            case SIMPLE_SYMBOL:
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            case UNTERMINATED_QUOTED_SYMBOL:
            case 147:
            	{
            		alt39=6;
            	}
                break;
            case ASSERT_TOK:
            case CHECKSAT_TOK:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_SORT_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_INFO_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case POP_TOK:
            case PROPAGATION_RULE_TOK:
            case PUSH_TOK:
            case REDUCTION_RULE_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case REWRITE_RULE_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTION_TOK:
            case SIMPLIFY_TOK:
            	{
            		alt39=7;
            	}
                break;
            case AND_TOK:
            case BV2NAT_TOK:
            case DISTINCT_TOK:
            case DIV_TOK:
            case DTSIZE_TOK:
            case EQUAL_TOK:
            case FMFCARDVAL_TOK:
            case FMFCARD_TOK:
            case GREATER_THAN_EQUAL_TOK:
            case GREATER_THAN_TOK:
            case IMPLIES_TOK:
            case INST_CLOSURE_TOK:
            case ITE_TOK:
            case LESS_THAN_EQUAL_TOK:
            case LESS_THAN_TOK:
            case MINUS_TOK:
            case NOT_TOK:
            case OR_TOK:
            case PLUS_TOK:
            case STAR_TOK:
            case XOR_TOK:
            	{
            		alt39=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto rulesimpleSymbolicExprNoKeywordEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1648:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL8 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2956);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             sexpr = SExpr(Integer(AntlrInput::tokenText(INTEGER_LITERAL8))); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1650:5: DECIMAL_LITERAL
        	    {
        	        DECIMAL_LITERAL9 = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2968);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             sexpr = SExpr(AntlrInput::tokenToRational(DECIMAL_LITERAL9)); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1652:5: HEX_LITERAL
        	    {
        	        HEX_LITERAL10 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2980);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             assert( AntlrInput::tokenText(HEX_LITERAL10).find("#x") == 0 );
        	                  std::string hexString = AntlrInput::tokenTextSubstr(HEX_LITERAL10, 2);
        	                  sexpr = SExpr(Integer(hexString, 16));
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1657:5: BINARY_LITERAL
        	    {
        	        BINARY_LITERAL11 = (pANTLR3_COMMON_TOKEN) MATCHT(BINARY_LITERAL, &FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2992);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             assert( AntlrInput::tokenText(BINARY_LITERAL11).find("#b") == 0 );
        	                  std::string binString = AntlrInput::tokenTextSubstr(BINARY_LITERAL11, 2);
        	                  sexpr = SExpr(Integer(binString, 2));
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1662:5: str[s,false]
        	    {
        	        FOLLOWPUSH(FOLLOW_str_in_simpleSymbolicExprNoKeyword3004);
        	        str(ctx, s, false);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             sexpr = SExpr(s); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1671:5: symbol[s,CHECK_NONE,SYM_SORT]
        	    {
        	        FOLLOWPUSH(FOLLOW_symbol_in_simpleSymbolicExprNoKeyword3024);
        	        symbol(ctx, s, CHECK_NONE, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             sexpr = SExpr(SExpr::Keyword(s)); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1673:5: tok= ( ASSERT_TOK | CHECKSAT_TOK | DECLARE_FUN_TOK | DECLARE_SORT_TOK | DEFINE_FUN_TOK | DEFINE_FUN_REC_TOK | DEFINE_FUNS_REC_TOK | DEFINE_SORT_TOK | GET_VALUE_TOK | GET_ASSIGNMENT_TOK | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_CORE_TOK | EXIT_TOK | RESET_TOK | RESET_ASSERTIONS_TOK | SET_LOGIC_TOK | SET_INFO_TOK | GET_INFO_TOK | SET_OPTION_TOK | GET_OPTION_TOK | PUSH_TOK | POP_TOK | DECLARE_DATATYPES_TOK | GET_MODEL_TOK | ECHO_TOK | REWRITE_RULE_TOK | REDUCTION_RULE_TOK | PROPAGATION_RULE_TOK | SIMPLIFY_TOK )
        	    {
        	        tok=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == ASSERT_TOK || LA(1) == CHECKSAT_TOK || LA(1) == DECLARE_DATATYPES_TOK || LA(1) == DECLARE_FUN_TOK || LA(1) == DECLARE_SORT_TOK || ((LA(1) >= DEFINE_FUNS_REC_TOK) && (LA(1) <= DEFINE_SORT_TOK)) || LA(1) == ECHO_TOK || LA(1) == EXIT_TOK || ((LA(1) >= GET_ASSERTIONS_TOK) && (LA(1) <= GET_PROOF_TOK)) || ((LA(1) >= GET_UNSAT_CORE_TOK) && (LA(1) <= GET_VALUE_TOK)) || ((LA(1) >= POP_TOK) && (LA(1) <= PUSH_TOK)) || LA(1) == REDUCTION_RULE_TOK || ((LA(1) >= RESET_ASSERTIONS_TOK) && (LA(1) <= REWRITE_RULE_TOK)) || ((LA(1) >= SET_INFO_TOK) && (LA(1) <= SET_LOGIC_TOK)) || LA(1) == SET_OPTION_TOK || LA(1) == SIMPLIFY_TOK )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             sexpr = SExpr(SExpr::Keyword(AntlrInput::tokenText(tok))); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1682:5: builtinOp[k]
        	    {
        	        FOLLOWPUSH(FOLLOW_builtinOp_in_simpleSymbolicExprNoKeyword3225);
        	        builtinOp(ctx, k);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             std::stringstream ss;
        	                  ss << language::SetLanguage(CVC4::language::output::LANG_SMTLIB_V2_5)
        	                     << EXPR_MANAGER->mkConst(k);
        	                  sexpr = SExpr(ss.str());
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleSymbolicExprNoKeywordEx; /* Prevent compiler warnings */
    rulesimpleSymbolicExprNoKeywordEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleSymbolicExprNoKeyword */

/**
 * $ANTLR start keyword
 * ../../../../../../src/parser/smt2/Smt2.g:1690:1: keyword[std::string& s] : KEYWORD ;
 */
static void
keyword(pSmt2Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    KEYWORD12;

    /* Initialize rule variables
     */

    KEYWORD12       = NULL;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:1691:3: ( KEYWORD )
        // ../../../../../../src/parser/smt2/Smt2.g:1691:5: KEYWORD
        {
            KEYWORD12 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_keyword3246);
            if  (HASEXCEPTION())
            {
                goto rulekeywordEx;
            }


            {
                 s = AntlrInput::tokenText(KEYWORD12); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeywordEx; /* Prevent compiler warnings */
    rulekeywordEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyword */

/**
 * $ANTLR start simpleSymbolicExpr
 * ../../../../../../src/parser/smt2/Smt2.g:1695:1: simpleSymbolicExpr[CVC4::SExpr& sexpr] : ( simpleSymbolicExprNoKeyword[sexpr] | KEYWORD );
 */
static void
simpleSymbolicExpr(pSmt2Parser ctx, CVC4::SExpr& sexpr)
{
    pANTLR3_COMMON_TOKEN    KEYWORD13;

    /* Initialize rule variables
     */

    KEYWORD13       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1696:3: ( simpleSymbolicExprNoKeyword[sexpr] | KEYWORD )

            ANTLR3_UINT32 alt40;

            alt40=2;

            switch ( LA(1) )
            {
            case AND_TOK:
            case ASSERT_TOK:
            case BINARY_LITERAL:
            case BV2NAT_TOK:
            case CHECKSAT_TOK:
            case CHECK_SYNTH_TOK:
            case CONSTRAINT_TOK:
            case DECIMAL_LITERAL:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_PRIMED_VAR_TOK:
            case DECLARE_SORT_TOK:
            case DECLARE_VAR_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case DISTINCT_TOK:
            case DIV_TOK:
            case DTSIZE_TOK:
            case ECHO_TOK:
            case EQUAL_TOK:
            case EXIT_TOK:
            case FMFCARDVAL_TOK:
            case FMFCARD_TOK:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_INFO_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case GREATER_THAN_EQUAL_TOK:
            case GREATER_THAN_TOK:
            case HEX_LITERAL:
            case IMPLIES_TOK:
            case INST_CLOSURE_TOK:
            case INTEGER_LITERAL:
            case INV_CONSTRAINT_TOK:
            case ITE_TOK:
            case LESS_THAN_EQUAL_TOK:
            case LESS_THAN_TOK:
            case MINUS_TOK:
            case NOT_TOK:
            case OR_TOK:
            case PLUS_TOK:
            case POP_TOK:
            case PROPAGATION_RULE_TOK:
            case PUSH_TOK:
            case QUOTED_SYMBOL:
            case REDUCTION_RULE_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case REWRITE_RULE_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTIONS_TOK:
            case SET_OPTION_TOK:
            case SIMPLE_SYMBOL:
            case SIMPLIFY_TOK:
            case STAR_TOK:
            case STRING_LITERAL_2_0:
            case STRING_LITERAL_2_5:
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            case UNTERMINATED_QUOTED_SYMBOL:
            case XOR_TOK:
            case 147:
            	{
            		alt40=1;
            	}
                break;
            case KEYWORD:
            	{
            		alt40=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 40;
                EXCEPTION->state        = 0;


                goto rulesimpleSymbolicExprEx;

            }

            switch (alt40)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1696:5: simpleSymbolicExprNoKeyword[sexpr]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3266);
        	        simpleSymbolicExprNoKeyword(ctx, sexpr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1697:5: KEYWORD
        	    {
        	        KEYWORD13 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_simpleSymbolicExpr3273);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }


        	        {
        	             sexpr = SExpr(AntlrInput::tokenText(KEYWORD13)); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleSymbolicExprEx; /* Prevent compiler warnings */
    rulesimpleSymbolicExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleSymbolicExpr */

/**
 * $ANTLR start symbolicExpr
 * ../../../../../../src/parser/smt2/Smt2.g:1701:1: symbolicExpr[CVC4::SExpr& sexpr] : ( simpleSymbolicExpr[sexpr] | LPAREN_TOK ( symbolicExpr[sexpr] )* RPAREN_TOK );
 */
static void
symbolicExpr(pSmt2Parser ctx, CVC4::SExpr& sexpr)
{

      std::vector<SExpr> children;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1705:3: ( simpleSymbolicExpr[sexpr] | LPAREN_TOK ( symbolicExpr[sexpr] )* RPAREN_TOK )

            ANTLR3_UINT32 alt42;

            alt42=2;

            switch ( LA(1) )
            {
            case AND_TOK:
            case ASSERT_TOK:
            case BINARY_LITERAL:
            case BV2NAT_TOK:
            case CHECKSAT_TOK:
            case CHECK_SYNTH_TOK:
            case CONSTRAINT_TOK:
            case DECIMAL_LITERAL:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_PRIMED_VAR_TOK:
            case DECLARE_SORT_TOK:
            case DECLARE_VAR_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case DISTINCT_TOK:
            case DIV_TOK:
            case DTSIZE_TOK:
            case ECHO_TOK:
            case EQUAL_TOK:
            case EXIT_TOK:
            case FMFCARDVAL_TOK:
            case FMFCARD_TOK:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_INFO_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case GREATER_THAN_EQUAL_TOK:
            case GREATER_THAN_TOK:
            case HEX_LITERAL:
            case IMPLIES_TOK:
            case INST_CLOSURE_TOK:
            case INTEGER_LITERAL:
            case INV_CONSTRAINT_TOK:
            case ITE_TOK:
            case KEYWORD:
            case LESS_THAN_EQUAL_TOK:
            case LESS_THAN_TOK:
            case MINUS_TOK:
            case NOT_TOK:
            case OR_TOK:
            case PLUS_TOK:
            case POP_TOK:
            case PROPAGATION_RULE_TOK:
            case PUSH_TOK:
            case QUOTED_SYMBOL:
            case REDUCTION_RULE_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case REWRITE_RULE_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTIONS_TOK:
            case SET_OPTION_TOK:
            case SIMPLE_SYMBOL:
            case SIMPLIFY_TOK:
            case STAR_TOK:
            case STRING_LITERAL_2_0:
            case STRING_LITERAL_2_5:
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            case UNTERMINATED_QUOTED_SYMBOL:
            case XOR_TOK:
            case 147:
            	{
            		alt42=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt42=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 42;
                EXCEPTION->state        = 0;


                goto rulesymbolicExprEx;

            }

            switch (alt42)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1705:5: simpleSymbolicExpr[sexpr]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExpr_in_symbolicExpr3298);
        	        simpleSymbolicExpr(ctx, sexpr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1706:5: LPAREN_TOK ( symbolicExpr[sexpr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_symbolicExpr3305);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1707:5: ( symbolicExpr[sexpr] )*

        	        for (;;)
        	        {
        	            int alt41=2;
        	            switch ( LA(1) )
        	            {
        	            case AND_TOK:
        	            case ASSERT_TOK:
        	            case BINARY_LITERAL:
        	            case BV2NAT_TOK:
        	            case CHECKSAT_TOK:
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_DATATYPES_TOK:
        	            case DECLARE_FUN_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_SORT_TOK:
        	            case DECLARE_VAR_TOK:
        	            case DEFINE_FUNS_REC_TOK:
        	            case DEFINE_FUN_REC_TOK:
        	            case DEFINE_FUN_TOK:
        	            case DEFINE_SORT_TOK:
        	            case DISTINCT_TOK:
        	            case DIV_TOK:
        	            case DTSIZE_TOK:
        	            case ECHO_TOK:
        	            case EQUAL_TOK:
        	            case EXIT_TOK:
        	            case FMFCARDVAL_TOK:
        	            case FMFCARD_TOK:
        	            case GET_ASSERTIONS_TOK:
        	            case GET_ASSIGNMENT_TOK:
        	            case GET_INFO_TOK:
        	            case GET_MODEL_TOK:
        	            case GET_OPTION_TOK:
        	            case GET_PROOF_TOK:
        	            case GET_UNSAT_CORE_TOK:
        	            case GET_VALUE_TOK:
        	            case GREATER_THAN_EQUAL_TOK:
        	            case GREATER_THAN_TOK:
        	            case HEX_LITERAL:
        	            case IMPLIES_TOK:
        	            case INST_CLOSURE_TOK:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case ITE_TOK:
        	            case KEYWORD:
        	            case LESS_THAN_EQUAL_TOK:
        	            case LESS_THAN_TOK:
        	            case LPAREN_TOK:
        	            case MINUS_TOK:
        	            case NOT_TOK:
        	            case OR_TOK:
        	            case PLUS_TOK:
        	            case POP_TOK:
        	            case PROPAGATION_RULE_TOK:
        	            case PUSH_TOK:
        	            case QUOTED_SYMBOL:
        	            case REDUCTION_RULE_TOK:
        	            case RESET_ASSERTIONS_TOK:
        	            case RESET_TOK:
        	            case REWRITE_RULE_TOK:
        	            case SET_INFO_TOK:
        	            case SET_LOGIC_TOK:
        	            case SET_OPTIONS_TOK:
        	            case SET_OPTION_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SIMPLIFY_TOK:
        	            case STAR_TOK:
        	            case STRING_LITERAL_2_0:
        	            case STRING_LITERAL_2_5:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case XOR_TOK:
        	            case 147:
        	            	{
        	            		alt41=1;
        	            	}
        	                break;

        	            }

        	            switch (alt41)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1707:7: symbolicExpr[sexpr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_symbolicExpr_in_symbolicExpr3313);
        	        	        symbolicExpr(ctx, sexpr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolicExprEx;
        	        	        }


        	        	        {
        	        	             children.push_back(sexpr); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop41;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop41: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_symbolicExpr3321);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }


        	        {
        	             sexpr = SExpr(children); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesymbolicExprEx; /* Prevent compiler warnings */
    rulesymbolicExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end symbolicExpr */

/**
 * $ANTLR start term
 * ../../../../../../src/parser/smt2/Smt2.g:1715:1: term[CVC4::Expr& expr, CVC4::Expr& expr2] : ( LPAREN_TOK builtinOp[kind] termList[args,expr] RPAREN_TOK | LPAREN_TOK AS_TOK term[f, f2] sortSymbol[type, CHECK_DECLARED] RPAREN_TOK | LPAREN_TOK quantOp[kind] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK term[f, f2] RPAREN_TOK | LPAREN_TOK functionName[name, CHECK_NONE] termList[args,expr] RPAREN_TOK | LPAREN_TOK ( indexedFunctionName[op] termList[args,expr] RPAREN_TOK | LPAREN_TOK AS_TOK CONST_TOK sortSymbol[type, CHECK_DECLARED] RPAREN_TOK term[f, f2] RPAREN_TOK ) | LPAREN_TOK LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] ( term[expr, f2] | sortSymbol[type,CHECK_DECLARED] term[expr, f2] ) RPAREN_TOK )+ RPAREN_TOK term[expr, f2] RPAREN_TOK | symbol[name,CHECK_NONE,SYM_VARIABLE] SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE] | symbol[name,CHECK_DECLARED,SYM_VARIABLE] | LPAREN_TOK ATTRIBUTE_TOK term[expr, f2] ( attribute[expr, attexpr, attr] )+ RPAREN_TOK | INTEGER_LITERAL | DECIMAL_LITERAL | LPAREN_TOK INDEX_TOK (bvLit= SIMPLE_SYMBOL size= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL ) RPAREN_TOK | HEX_LITERAL | BINARY_LITERAL | str[s,false] | FP_RNE_TOK | FP_RNA_TOK | FP_RTP_TOK | FP_RTN_TOK | FP_RTZ_TOK | FP_RNE_FULL_TOK | FP_RNA_FULL_TOK | FP_RTP_FULL_TOK | FP_RTN_FULL_TOK | FP_RTZ_FULL_TOK | RENOSTR_TOK | REALLCHAR_TOK | EMPTYSET_TOK | UNIVSET_TOK | NILREF_TOK );
 */
static void
term(pSmt2Parser ctx, CVC4::Expr& expr, CVC4::Expr& expr2)
{
    pANTLR3_COMMON_TOKEN    bvLit;
    pANTLR3_COMMON_TOKEN    size;
    pANTLR3_COMMON_TOKEN    eb;
    pANTLR3_COMMON_TOKEN    sb;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL14;
    pANTLR3_COMMON_TOKEN    DECIMAL_LITERAL15;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL16;
    pANTLR3_COMMON_TOKEN    BINARY_LITERAL17;

    /* Initialize rule variables
     */


      Debug("parser") << "term: " << AntlrInput::tokenText(LT(1)) << std::endl;
      Kind kind = kind::NULL_EXPR;
      Expr op;
      std::string name, name2;
      std::vector<Expr> args;
      std::vector< std::pair<std::string, Type> > sortedVarNames;
      Expr f, f2, f3, f4;
      std::string attr;
      Expr attexpr;
      std::vector<Expr> patexprs;
      std::hash_set<std::string, StringHashFunction> names;
      std::vector< std::pair<std::string, Expr> > binders;
      Type type;
      std::string s;
      bool isBuiltinOperator = false;
      bool readLetSort = false;

    bvLit       = NULL;
    size       = NULL;
    eb       = NULL;
    sb       = NULL;
    INTEGER_LITERAL14       = NULL;
    DECIMAL_LITERAL15       = NULL;
    HEX_LITERAL16       = NULL;
    BINARY_LITERAL17       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:1734:3: ( LPAREN_TOK builtinOp[kind] termList[args,expr] RPAREN_TOK | LPAREN_TOK AS_TOK term[f, f2] sortSymbol[type, CHECK_DECLARED] RPAREN_TOK | LPAREN_TOK quantOp[kind] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK term[f, f2] RPAREN_TOK | LPAREN_TOK functionName[name, CHECK_NONE] termList[args,expr] RPAREN_TOK | LPAREN_TOK ( indexedFunctionName[op] termList[args,expr] RPAREN_TOK | LPAREN_TOK AS_TOK CONST_TOK sortSymbol[type, CHECK_DECLARED] RPAREN_TOK term[f, f2] RPAREN_TOK ) | LPAREN_TOK LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] ( term[expr, f2] | sortSymbol[type,CHECK_DECLARED] term[expr, f2] ) RPAREN_TOK )+ RPAREN_TOK term[expr, f2] RPAREN_TOK | symbol[name,CHECK_NONE,SYM_VARIABLE] SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE] | symbol[name,CHECK_DECLARED,SYM_VARIABLE] | LPAREN_TOK ATTRIBUTE_TOK term[expr, f2] ( attribute[expr, attexpr, attr] )+ RPAREN_TOK | INTEGER_LITERAL | DECIMAL_LITERAL | LPAREN_TOK INDEX_TOK (bvLit= SIMPLE_SYMBOL size= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL ) RPAREN_TOK | HEX_LITERAL | BINARY_LITERAL | str[s,false] | FP_RNE_TOK | FP_RNA_TOK | FP_RTP_TOK | FP_RTN_TOK | FP_RTZ_TOK | FP_RNE_FULL_TOK | FP_RNA_FULL_TOK | FP_RTP_FULL_TOK | FP_RTN_FULL_TOK | FP_RTZ_FULL_TOK | RENOSTR_TOK | REALLCHAR_TOK | EMPTYSET_TOK | UNIVSET_TOK | NILREF_TOK )

            ANTLR3_UINT32 alt48;

            alt48=30;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case AS_TOK:
            			{
            				alt48=2;
            			}
            		    break;
            		case LET_TOK:
            			{
            				alt48=6;
            			}
            		    break;
            		case ATTRIBUTE_TOK:
            			{
            				alt48=9;
            			}
            		    break;
            		case INDEX_TOK:
            			{
            				alt48=12;
            			}
            		    break;
            		case AND_TOK:
            		case BV2NAT_TOK:
            		case DISTINCT_TOK:
            		case DIV_TOK:
            		case DTSIZE_TOK:
            		case EQUAL_TOK:
            		case FMFCARDVAL_TOK:
            		case FMFCARD_TOK:
            		case GREATER_THAN_EQUAL_TOK:
            		case GREATER_THAN_TOK:
            		case IMPLIES_TOK:
            		case INST_CLOSURE_TOK:
            		case ITE_TOK:
            		case LESS_THAN_EQUAL_TOK:
            		case LESS_THAN_TOK:
            		case MINUS_TOK:
            		case NOT_TOK:
            		case OR_TOK:
            		case PLUS_TOK:
            		case STAR_TOK:
            		case XOR_TOK:
            			{
            				alt48=1;
            			}
            		    break;
            		case EXISTS_TOK:
            		case FORALL_TOK:
            			{
            				alt48=3;
            			}
            		    break;
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case INV_CONSTRAINT_TOK:
            		case QUOTED_SYMBOL:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=4;
            			}
            		    break;
            		case LPAREN_TOK:
            			{
            				alt48=5;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 1;


            		    goto ruletermEx;

            		}

            	}
                break;
            case SIMPLE_SYMBOL:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 2;


            		    goto ruletermEx;

            		}

            	}
                break;
            case 147:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 3;


            		    goto ruletermEx;

            		}

            	}
                break;
            case SET_OPTIONS_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 4;


            		    goto ruletermEx;

            		}

            	}
                break;
            case DECLARE_VAR_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 5;


            		    goto ruletermEx;

            		}

            	}
                break;
            case DECLARE_PRIMED_VAR_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 6;


            		    goto ruletermEx;

            		}

            	}
                break;
            case SYNTH_FUN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 7;


            		    goto ruletermEx;

            		}

            	}
                break;
            case SYNTH_INV_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 8;


            		    goto ruletermEx;

            		}

            	}
                break;
            case CONSTRAINT_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 9;


            		    goto ruletermEx;

            		}

            	}
                break;
            case INV_CONSTRAINT_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 10;


            		    goto ruletermEx;

            		}

            	}
                break;
            case CHECK_SYNTH_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 11;


            		    goto ruletermEx;

            		}

            	}
                break;
            case QUOTED_SYMBOL:
            	{
            		switch ( LA(2) )
            		{
            		case SYGUS_ENUM_CONS_TOK:
            			{
            				alt48=7;
            			}
            		    break;
            		case EOF:
            		case ATTRIBUTE_INST_LEVEL:
            		case ATTRIBUTE_NAMED_TOK:
            		case ATTRIBUTE_NO_PATTERN_TOK:
            		case ATTRIBUTE_PATTERN_TOK:
            		case ATTRIBUTE_RR_PRIORITY:
            		case BINARY_LITERAL:
            		case CHECK_SYNTH_TOK:
            		case CONSTRAINT_TOK:
            		case DECIMAL_LITERAL:
            		case DECLARE_PRIMED_VAR_TOK:
            		case DECLARE_VAR_TOK:
            		case EMPTYSET_TOK:
            		case FP_RNA_FULL_TOK:
            		case FP_RNA_TOK:
            		case FP_RNE_FULL_TOK:
            		case FP_RNE_TOK:
            		case FP_RTN_FULL_TOK:
            		case FP_RTN_TOK:
            		case FP_RTP_FULL_TOK:
            		case FP_RTP_TOK:
            		case FP_RTZ_FULL_TOK:
            		case FP_RTZ_TOK:
            		case HEX_LITERAL:
            		case INTEGER_LITERAL:
            		case INV_CONSTRAINT_TOK:
            		case KEYWORD:
            		case LPAREN_TOK:
            		case NILREF_TOK:
            		case QUOTED_SYMBOL:
            		case REALLCHAR_TOK:
            		case RENOSTR_TOK:
            		case RPAREN_TOK:
            		case SET_OPTIONS_TOK:
            		case SIMPLE_SYMBOL:
            		case STRING_LITERAL_2_0:
            		case STRING_LITERAL_2_5:
            		case SYNTH_FUN_TOK:
            		case SYNTH_INV_TOK:
            		case UNIVSET_TOK:
            		case UNTERMINATED_QUOTED_SYMBOL:
            		case 147:
            			{
            				alt48=8;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 12;


            		    goto ruletermEx;

            		}

            	}
                break;
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		switch ( LA(2) )
            		{
            		case EOF:
            			{
            				alt48=7;
            			}
            		    break;
            		case 145:
            			{
            				alt48=7;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 48;
            		    EXCEPTION->state        = 13;


            		    goto ruletermEx;

            		}

            	}
                break;
            case INTEGER_LITERAL:
            	{
            		alt48=10;
            	}
                break;
            case DECIMAL_LITERAL:
            	{
            		alt48=11;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt48=13;
            	}
                break;
            case BINARY_LITERAL:
            	{
            		alt48=14;
            	}
                break;
            case STRING_LITERAL_2_0:
            case STRING_LITERAL_2_5:
            	{
            		alt48=15;
            	}
                break;
            case FP_RNE_TOK:
            	{
            		alt48=16;
            	}
                break;
            case FP_RNA_TOK:
            	{
            		alt48=17;
            	}
                break;
            case FP_RTP_TOK:
            	{
            		alt48=18;
            	}
                break;
            case FP_RTN_TOK:
            	{
            		alt48=19;
            	}
                break;
            case FP_RTZ_TOK:
            	{
            		alt48=20;
            	}
                break;
            case FP_RNE_FULL_TOK:
            	{
            		alt48=21;
            	}
                break;
            case FP_RNA_FULL_TOK:
            	{
            		alt48=22;
            	}
                break;
            case FP_RTP_FULL_TOK:
            	{
            		alt48=23;
            	}
                break;
            case FP_RTN_FULL_TOK:
            	{
            		alt48=24;
            	}
                break;
            case FP_RTZ_FULL_TOK:
            	{
            		alt48=25;
            	}
                break;
            case RENOSTR_TOK:
            	{
            		alt48=26;
            	}
                break;
            case REALLCHAR_TOK:
            	{
            		alt48=27;
            	}
                break;
            case EMPTYSET_TOK:
            	{
            		alt48=28;
            	}
                break;
            case UNIVSET_TOK:
            	{
            		alt48=29;
            	}
                break;
            case NILREF_TOK:
            	{
            		alt48=30;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 48;
                EXCEPTION->state        = 0;


                goto ruletermEx;

            }

            switch (alt48)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1735:5: LPAREN_TOK builtinOp[kind] termList[args,expr] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3354);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_builtinOp_in_term3356);
        	        builtinOp(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_termList_in_term3359);
        	        termList(ctx, args, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3362);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {

        	                  if( !PARSER_STATE->strictModeEnabled() &&
        	                      (kind == CVC4::kind::AND || kind == CVC4::kind::OR) &&
        	                      args.size() == 1) {
        	                    /* Unary AND/OR can be replaced with the argument.
        	                     * It just so happens expr should already be the only argument. */
        	                    assert( expr == args[0] );
        	                  } else if( CVC4::kind::isAssociative(kind) &&
        	                             args.size() > EXPR_MANAGER->maxArity(kind) ) {
        	                    /* Special treatment for associative operators with lots of children */
        	                    expr = EXPR_MANAGER->mkAssociative(kind, args);
        	                  } else if( kind == CVC4::kind::MINUS && args.size() == 1 ) {
        	                    expr = MK_EXPR(CVC4::kind::UMINUS, args[0]);
        	                  } else if( ( kind == CVC4::kind::XOR || kind == CVC4::kind::MINUS ) &&
        	                             args.size() > 2 ) {
        	                    /* left-associative, but CVC4 internally only supports 2 args */
        	                    expr = args[0];
        	                    for(size_t i = 1; i < args.size(); ++i) {
        	                      expr = MK_EXPR(kind, expr, args[i]);
        	                    }
        	                  } else if( kind == CVC4::kind::IMPLIES && args.size() > 2 ) {
        	                    /* right-associative, but CVC4 internally only supports 2 args */
        	                    expr = args[args.size() - 1];
        	                    for(size_t i = args.size() - 1; i > 0;) {
        	                      expr = MK_EXPR(kind, args[--i], expr);
        	                    }
        	                  } else if( ( kind == CVC4::kind::EQUAL ||
        	                               kind == CVC4::kind::LT || kind == CVC4::kind::GT ||
        	                               kind == CVC4::kind::LEQ || kind == CVC4::kind::GEQ ) &&
        	                             args.size() > 2 ) {
        	                    /* "chainable", but CVC4 internally only supports 2 args */
        	                    expr = MK_EXPR(MK_CONST(Chain(kind)), args);
        	                  } else if( PARSER_STATE->strictModeEnabled() && kind == CVC4::kind::ABS &&
        	                             args.size() == 1 && !args[0].getType().isInteger() ) {
        	                    /* first, check that ABS is even defined in this logic */
        	                    PARSER_STATE->checkOperator(kind, args.size());
        	                    PARSER_STATE->parseError("abs can only be applied to Int, not Real, "
        	                                             "while in strict SMT-LIB compliance mode");
        	                  } else {
        	                    PARSER_STATE->checkOperator(kind, args.size());
        	                    expr = MK_EXPR(kind, args);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1779:5: LPAREN_TOK AS_TOK term[f, f2] sortSymbol[type, CHECK_DECLARED] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3374);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(AS_TOK, &FOLLOW_AS_TOK_in_term3376);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_term3378);
        	        term(ctx, f, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_term3381);
        	        sortSymbol(ctx, type, CHECK_DECLARED);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3384);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {

        	                  if(f.getKind() == CVC4::kind::APPLY_CONSTRUCTOR && type.isDatatype()) {
        	                    std::vector<CVC4::Expr> v;
        	                    Expr e = f.getOperator();
        	                    const DatatypeConstructor& dtc =
        	                        Datatype::datatypeOf(e)[Datatype::indexOf(e)];
        	                    v.push_back(MK_EXPR( CVC4::kind::APPLY_TYPE_ASCRIPTION,
        	                                         MK_CONST(AscriptionType(dtc.getSpecializedConstructorType(type))), f.getOperator() ));
        	                    v.insert(v.end(), f.begin(), f.end());
        	                    expr = MK_EXPR(CVC4::kind::APPLY_CONSTRUCTOR, v);
        	                  } else if(f.getKind() == CVC4::kind::EMPTYSET) {
        	                    Debug("parser") << "Empty set encountered: " << f << " "
        	                                      << f2 << " " << type <<  std::endl;
        	                    expr = MK_CONST( ::CVC4::EmptySet(type) );
        	                  } else if(f.getKind() == CVC4::kind::UNIVERSE_SET) {
        	                    expr = EXPR_MANAGER->mkUniqueVar(type, kind::UNIVERSE_SET);
        	                  } else if(f.getKind() == CVC4::kind::SEP_NIL) {
        	                    //We don't want the nil reference to be a constant: for instance, it
        	                    //could be of type Int but is not a const rational. However, the
        	                    //expression has 0 children. So we convert to a SEP_NIL variable.
        	                    expr = EXPR_MANAGER->mkUniqueVar(type, kind::SEP_NIL);
        	                  } else {
        	                    if(f.getType() != type) {
        	                      PARSER_STATE->parseError("Type ascription not satisfied.");
        	                    }
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1807:5: LPAREN_TOK quantOp[kind] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK term[f, f2] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3396);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_quantOp_in_term3398);
        	        quantOp(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3405);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_term3407);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3410);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {

        	                  PARSER_STATE->pushScope(true);
        	                  for(std::vector<std::pair<std::string, CVC4::Type> >::const_iterator i =
        	                        sortedVarNames.begin(), iend = sortedVarNames.end();
        	                      i != iend;
        	                      ++i) {
        	                    args.push_back(PARSER_STATE->mkBoundVar((*i).first, (*i).second));
        	                  }
        	                  Expr bvl = MK_EXPR(kind::BOUND_VAR_LIST, args);
        	                  args.clear();
        	                  args.push_back(bvl);
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_term3422);
        	        term(ctx, f, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3425);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {

        	                  PARSER_STATE->popScope();
        	                  switch(f.getKind()) {
        	                  case CVC4::kind::RR_REWRITE:
        	                  case CVC4::kind::RR_REDUCTION:
        	                  case CVC4::kind::RR_DEDUCTION:
        	                    if(kind == CVC4::kind::EXISTS) {
        	                      PARSER_STATE->parseError("Use Exists instead of Forall for a rewrite "
        	                                               "rule.");
        	                    }
        	                    args.push_back(f2); // guards
        	                    args.push_back(f); // rule
        	                    expr = MK_EXPR(CVC4::kind::REWRITE_RULE, args);
        	                    break;
        	                  default:
        	                    args.push_back(f);
        	                    if(! f2.isNull()){
        	                      args.push_back(f2);
        	                    }
        	                    expr = MK_EXPR(kind, args);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1844:5: LPAREN_TOK functionName[name, CHECK_NONE] termList[args,expr] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3437);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_functionName_in_term3439);
        	        functionName(ctx, name, CHECK_NONE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             isBuiltinOperator = PARSER_STATE->isOperatorEnabled(name);
        	                  if(isBuiltinOperator) {
        	                    /* A built-in operator not already handled by the lexer */
        	                    kind = PARSER_STATE->getOperatorKind(name);
        	                  } else {
        	                    /* A non-built-in function application */
        	                    PARSER_STATE->checkDeclaration(name, CHECK_DECLARED, SYM_VARIABLE);
        	                    //hack to allow constants with parentheses (disabled for now)
        	                    //if( PARSER_STATE->sygus() && !PARSER_STATE->isFunctionLike(name) ){
        	                    //  op = PARSER_STATE->getVariable(name);
        	                    //}else{
        	                    PARSER_STATE->checkFunctionLike(name);
        	                    const bool isDefinedFunction =
        	                      PARSER_STATE->isDefinedFunction(name);
        	                    if(isDefinedFunction) {
        	                      expr = PARSER_STATE->getFunction(name);
        	                      kind = CVC4::kind::APPLY;
        	                    } else {
        	                      expr = PARSER_STATE->getVariable(name);
        	                      Type t = expr.getType();
        	                      if(t.isConstructor()) {
        	                        kind = CVC4::kind::APPLY_CONSTRUCTOR;
        	                      } else if(t.isSelector()) {
        	                        kind = CVC4::kind::APPLY_SELECTOR;
        	                      } else if(t.isTester()) {
        	                        kind = CVC4::kind::APPLY_TESTER;
        	                      } else {
        	                        kind = CVC4::kind::APPLY_UF;
        	                      }
        	                    }
        	                    args.push_back(expr);
        	                  }
        	                    
        	        }


        	        FOLLOWPUSH(FOLLOW_termList_in_term3457);
        	        termList(ctx, args, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3460);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             Debug("parser") << "args has size " << args.size() << std::endl
        	                                  << "expr is " << expr << std::endl;
        	                  for(std::vector<Expr>::iterator i = args.begin(); i != args.end(); ++i) {
        	                    Debug("parser") << "++ " << *i << std::endl;
        	                  }
        	                  if(isBuiltinOperator) {
        	                    PARSER_STATE->checkOperator(kind, args.size());
        	                  }
        	                  expr = MK_EXPR(kind, args); 
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1891:5: LPAREN_TOK ( indexedFunctionName[op] termList[args,expr] RPAREN_TOK | LPAREN_TOK AS_TOK CONST_TOK sortSymbol[type, CHECK_DECLARED] RPAREN_TOK term[f, f2] RPAREN_TOK )
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3473);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1892:5: ( indexedFunctionName[op] termList[args,expr] RPAREN_TOK | LPAREN_TOK AS_TOK CONST_TOK sortSymbol[type, CHECK_DECLARED] RPAREN_TOK term[f, f2] RPAREN_TOK )
        	        {
        	            int alt43=2;
        	            switch ( LA(1) )
        	            {
        	            case LPAREN_TOK:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case INDEX_TOK:
        	            			{
        	            				alt43=1;
        	            			}
        	            		    break;
        	            		case AS_TOK:
        	            			{
        	            				alt43=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 43;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruletermEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 43;
        	                EXCEPTION->state        = 0;


        	                goto ruletermEx;

        	            }

        	            switch (alt43)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1893:7: indexedFunctionName[op] termList[args,expr] RPAREN_TOK
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_indexedFunctionName_in_term3489);
        	        	        indexedFunctionName(ctx, op);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_termList_in_term3492);
        	        	        termList(ctx, args, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3495);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        {
        	        	             expr = MK_EXPR(op, args);
        	        	                    PARSER_STATE->checkOperator(expr.getKind(), args.size());
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:1898:7: LPAREN_TOK AS_TOK CONST_TOK sortSymbol[type, CHECK_DECLARED] RPAREN_TOK term[f, f2] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3519);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	         MATCHT(AS_TOK, &FOLLOW_AS_TOK_in_term3521);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	         MATCHT(CONST_TOK, &FOLLOW_CONST_TOK_in_term3523);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_term3525);
        	        	        sortSymbol(ctx, type, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3534);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_term_in_term3536);
        	        	        term(ctx, f, f2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3539);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        {

        	        	                    if(!type.isArray()) {
        	        	                      std::stringstream ss;
        	        	                      ss << "expected array constant term, but cast is not of array type"
        	        	                         << std::endl
        	        	                         << "cast type: " << type;
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                    if(!f.isConst()) {
        	        	                      std::stringstream ss;
        	        	                      ss << "expected constant term inside array constant, but found "
        	        	                         << "nonconstant term:" << std::endl
        	        	                         << "the term: " << f;
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                    if(!ArrayType(type).getConstituentType().isComparableTo(f.getType())) {
        	        	                      std::stringstream ss;
        	        	                      ss << "type mismatch inside array constant term:" << std::endl
        	        	                         << "array type:          " << type << std::endl
        	        	                         << "expected const type: " << ArrayType(type).getConstituentType()
        	        	                         << std::endl
        	        	                         << "computed const type: " << f.getType();
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                    expr = MK_CONST( ::CVC4::ArrayStoreAll(type, f) );
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1928:5: LPAREN_TOK LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] ( term[expr, f2] | sortSymbol[type,CHECK_DECLARED] term[expr, f2] ) RPAREN_TOK )+ RPAREN_TOK term[expr, f2] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3565);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_term3567);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3569);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(true); 
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1930:5: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] ( term[expr, f2] | sortSymbol[type,CHECK_DECLARED] term[expr, f2] ) RPAREN_TOK )+
        	        {
        	            int cnt45=0;

        	            for (;;)
        	            {
        	                int alt45=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt45=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt45)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:1930:7: LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] ( term[expr, f2] | sortSymbol[type,CHECK_DECLARED] term[expr, f2] ) RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3583);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_symbol_in_term3585);
        	        	            symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermEx;
        	        	            }


        	        	            // ../../../../../../src/parser/smt2/Smt2.g:1931:7: ( term[expr, f2] | sortSymbol[type,CHECK_DECLARED] term[expr, f2] )
        	        	            {
        	        	                int alt44=2;
        	        	                switch ( LA(1) )
        	        	                {
        	        	                case LPAREN_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case AND_TOK:
        	        	                		case AS_TOK:
        	        	                		case ATTRIBUTE_TOK:
        	        	                		case BV2NAT_TOK:
        	        	                		case DISTINCT_TOK:
        	        	                		case DIV_TOK:
        	        	                		case DTSIZE_TOK:
        	        	                		case EQUAL_TOK:
        	        	                		case EXISTS_TOK:
        	        	                		case FMFCARDVAL_TOK:
        	        	                		case FMFCARD_TOK:
        	        	                		case FORALL_TOK:
        	        	                		case GREATER_THAN_EQUAL_TOK:
        	        	                		case GREATER_THAN_TOK:
        	        	                		case IMPLIES_TOK:
        	        	                		case INST_CLOSURE_TOK:
        	        	                		case ITE_TOK:
        	        	                		case LESS_THAN_EQUAL_TOK:
        	        	                		case LESS_THAN_TOK:
        	        	                		case LET_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case MINUS_TOK:
        	        	                		case NOT_TOK:
        	        	                		case OR_TOK:
        	        	                		case PLUS_TOK:
        	        	                		case STAR_TOK:
        	        	                		case XOR_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case INDEX_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case SIMPLE_SYMBOL:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case SET_OPTIONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case DECLARE_VAR_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case SYNTH_FUN_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case SYNTH_INV_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case CONSTRAINT_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case CHECK_SYNTH_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case QUOTED_SYMBOL:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 1;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case SIMPLE_SYMBOL:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 2;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case 147:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 3;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case SET_OPTIONS_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 4;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case DECLARE_VAR_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 5;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case DECLARE_PRIMED_VAR_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 6;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case SYNTH_FUN_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 7;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case SYNTH_INV_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 8;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case CONSTRAINT_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 9;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case INV_CONSTRAINT_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 10;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case CHECK_SYNTH_TOK:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 11;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case QUOTED_SYMBOL:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case RPAREN_TOK:
        	        	                		case SYGUS_ENUM_CONS_TOK:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case BINARY_LITERAL:
        	        	                		case CHECK_SYNTH_TOK:
        	        	                		case CONSTRAINT_TOK:
        	        	                		case DECIMAL_LITERAL:
        	        	                		case DECLARE_PRIMED_VAR_TOK:
        	        	                		case DECLARE_VAR_TOK:
        	        	                		case EMPTYSET_TOK:
        	        	                		case FP_RNA_FULL_TOK:
        	        	                		case FP_RNA_TOK:
        	        	                		case FP_RNE_FULL_TOK:
        	        	                		case FP_RNE_TOK:
        	        	                		case FP_RTN_FULL_TOK:
        	        	                		case FP_RTN_TOK:
        	        	                		case FP_RTP_FULL_TOK:
        	        	                		case FP_RTP_TOK:
        	        	                		case FP_RTZ_FULL_TOK:
        	        	                		case FP_RTZ_TOK:
        	        	                		case HEX_LITERAL:
        	        	                		case INTEGER_LITERAL:
        	        	                		case INV_CONSTRAINT_TOK:
        	        	                		case LPAREN_TOK:
        	        	                		case NILREF_TOK:
        	        	                		case QUOTED_SYMBOL:
        	        	                		case REALLCHAR_TOK:
        	        	                		case RENOSTR_TOK:
        	        	                		case SET_OPTIONS_TOK:
        	        	                		case SIMPLE_SYMBOL:
        	        	                		case STRING_LITERAL_2_0:
        	        	                		case STRING_LITERAL_2_5:
        	        	                		case SYNTH_FUN_TOK:
        	        	                		case SYNTH_INV_TOK:
        	        	                		case UNIVSET_TOK:
        	        	                		case UNTERMINATED_QUOTED_SYMBOL:
        	        	                		case 147:
        	        	                			{
        	        	                				alt44=2;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 12;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case UNTERMINATED_QUOTED_SYMBOL:
        	        	                	{
        	        	                		switch ( LA(2) )
        	        	                		{
        	        	                		case EOF:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;
        	        	                		case 145:
        	        	                			{
        	        	                				alt44=1;
        	        	                			}
        	        	                		    break;

        	        	                		default:
        	        	                		    CONSTRUCTEX();
        	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                		    EXCEPTION->message      = (void *)"";
        	        	                		    EXCEPTION->decisionNum  = 44;
        	        	                		    EXCEPTION->state        = 13;


        	        	                		    goto ruletermEx;

        	        	                		}

        	        	                	}
        	        	                    break;
        	        	                case BINARY_LITERAL:
        	        	                case DECIMAL_LITERAL:
        	        	                case EMPTYSET_TOK:
        	        	                case FP_RNA_FULL_TOK:
        	        	                case FP_RNA_TOK:
        	        	                case FP_RNE_FULL_TOK:
        	        	                case FP_RNE_TOK:
        	        	                case FP_RTN_FULL_TOK:
        	        	                case FP_RTN_TOK:
        	        	                case FP_RTP_FULL_TOK:
        	        	                case FP_RTP_TOK:
        	        	                case FP_RTZ_FULL_TOK:
        	        	                case FP_RTZ_TOK:
        	        	                case HEX_LITERAL:
        	        	                case INTEGER_LITERAL:
        	        	                case NILREF_TOK:
        	        	                case REALLCHAR_TOK:
        	        	                case RENOSTR_TOK:
        	        	                case STRING_LITERAL_2_0:
        	        	                case STRING_LITERAL_2_5:
        	        	                case UNIVSET_TOK:
        	        	                	{
        	        	                		alt44=1;
        	        	                	}
        	        	                    break;

        	        	                default:
        	        	                    CONSTRUCTEX();
        	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                    EXCEPTION->message      = (void *)"";
        	        	                    EXCEPTION->decisionNum  = 44;
        	        	                    EXCEPTION->state        = 0;


        	        	                    goto ruletermEx;

        	        	                }

        	        	                switch (alt44)
        	        	                {
        	        	            	case 1:
        	        	            	    // ../../../../../../src/parser/smt2/Smt2.g:1931:8: term[expr, f2]
        	        	            	    {
        	        	            	        FOLLOWPUSH(FOLLOW_term_in_term3595);
        	        	            	        term(ctx, expr, f2);

        	        	            	        FOLLOWPOP();
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruletermEx;
        	        	            	        }


        	        	            	    }
        	        	            	    break;
        	        	            	case 2:
        	        	            	    // ../../../../../../src/parser/smt2/Smt2.g:1931:25: sortSymbol[type,CHECK_DECLARED] term[expr, f2]
        	        	            	    {
        	        	            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_term3600);
        	        	            	        sortSymbol(ctx, type, CHECK_DECLARED);

        	        	            	        FOLLOWPOP();
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruletermEx;
        	        	            	        }


        	        	            	        {
        	        	            	             readLetSort = true; 
        	        	            	        }


        	        	            	        FOLLOWPUSH(FOLLOW_term_in_term3612);
        	        	            	        term(ctx, expr, f2);

        	        	            	        FOLLOWPOP();
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruletermEx;
        	        	            	        }


        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }

        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3629);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermEx;
        	        	            }


        	        	            {
        	        	                 if( !PARSER_STATE->sygus() && readLetSort ){
        	        	                          PARSER_STATE->parseError("Bad syntax for let term.");
        	        	                        }else if(names.count(name) == 1) {
        	        	                          std::stringstream ss;
        	        	                          ss << "warning: symbol `" << name << "' bound multiple times by let;"
        	        	                             << " the last binding will be used, shadowing earlier ones";
        	        	                          PARSER_STATE->warning(ss.str());
        	        	                        } else {
        	        	                          names.insert(name);
        	        	                        }
        	        	                        binders.push_back(std::make_pair(name, expr)); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt45 >= 1 )
        	        		{
        	        		    goto loop45;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruletermEx;
        	        	}
        	        	cnt45++;
        	            }
        	            loop45: ;	/* Jump to here if this rule does not match */
        	        }

        	        {
        	             // now implement these bindings
        	                  for(std::vector< std::pair<std::string, Expr> >::iterator
        	                        i = binders.begin(); i != binders.end(); ++i) {
        	                    PARSER_STATE->defineVar((*i).first, (*i).second);
        	                  }
        	                
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3666);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_term3672);
        	        term(ctx, expr, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3679);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1958:5: symbol[name,CHECK_NONE,SYM_VARIABLE] SYGUS_ENUM_CONS_TOK symbol[name2,CHECK_NONE,SYM_VARIABLE]
        	    {
        	        FOLLOWPUSH(FOLLOW_symbol_in_term3691);
        	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(SYGUS_ENUM_CONS_TOK, &FOLLOW_SYGUS_ENUM_CONS_TOK_in_term3694);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_term3700);
        	        symbol(ctx, name2, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             std::string cname = name + "__Enum__" + name2;
        	                  Debug("parser-sygus") << "Check for enum const " << cname << std::endl;
        	                  expr = PARSER_STATE->getVariable(cname);
        	                  // expr.getType().isConstructor() &&
        	                  // ConstructorType(expr.getType()).getArity()==0;
        	                  expr = MK_EXPR(CVC4::kind::APPLY_CONSTRUCTOR, expr);
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1968:5: symbol[name,CHECK_DECLARED,SYM_VARIABLE]
        	    {
        	        FOLLOWPUSH(FOLLOW_symbol_in_term3719);
        	        symbol(ctx, name, CHECK_DECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             if( PARSER_STATE->sygus() && name[0]=='-' && 
        	                      name.find_first_not_of("0123456789", 1) == std::string::npos ){
        	                    //allow unary minus in sygus
        	                    expr = MK_CONST(Rational(name));
        	                  }else{
        	                    const bool isDefinedFunction =
        	                      PARSER_STATE->isDefinedFunction(name);
        	                    if(PARSER_STATE->isAbstractValue(name)) {
        	                      expr = PARSER_STATE->mkAbstractValue(name);
        	                    } else if(isDefinedFunction) {
        	                      expr = MK_EXPR(CVC4::kind::APPLY,
        	                                    PARSER_STATE->getFunction(name));
        	                    } else {
        	                      expr = PARSER_STATE->getVariable(name);
        	                      Type t = PARSER_STATE->getType(name);
        	                      if(t.isConstructor() && ConstructorType(t).getArity() == 0) {
        	                        // don't require parentheses, immediately turn it into an apply
        	                        expr = MK_EXPR(CVC4::kind::APPLY_CONSTRUCTOR, expr);
        	                      }
        	                    }
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/smt2/Smt2.g:1993:5: LPAREN_TOK ATTRIBUTE_TOK term[expr, f2] ( attribute[expr, attexpr, attr] )+ RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3739);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(ATTRIBUTE_TOK, &FOLLOW_ATTRIBUTE_TOK_in_term3741);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_term3743);
        	        term(ctx, expr, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:1994:5: ( attribute[expr, attexpr, attr] )+
        	        {
        	            int cnt46=0;

        	            for (;;)
        	            {
        	                int alt46=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case ATTRIBUTE_INST_LEVEL:
        	        	case ATTRIBUTE_NAMED_TOK:
        	        	case ATTRIBUTE_NO_PATTERN_TOK:
        	        	case ATTRIBUTE_PATTERN_TOK:
        	        	case ATTRIBUTE_RR_PRIORITY:
        	        	case KEYWORD:
        	        		{
        	        			alt46=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt46)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:1994:7: attribute[expr, attexpr, attr]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_attribute_in_term3752);
        	        	            attribute(ctx, expr, attexpr, attr);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermEx;
        	        	            }


        	        	            {
        	        	                 if( ! attexpr.isNull()) {
        	        	                          patexprs.push_back( attexpr );
        	        	                        }
        	        	                      
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt46 >= 1 )
        	        		{
        	        		    goto loop46;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruletermEx;
        	        	}
        	        	cnt46++;
        	            }
        	            loop46: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3770);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {

        	                  if(attr == ":rewrite-rule") {
        	                    Expr guard;
        	                    Expr body;
        	                    if(expr[1].getKind() == kind::IMPLIES ||
        	                       expr[1].getKind() == kind::EQUAL) {
        	                      guard = expr[0];
        	                      body = expr[1];
        	                    } else {
        	                      guard = MK_CONST(bool(true));
        	                      body = expr;
        	                    }
        	                    expr2 = guard;
        	                    args.push_back(body[0]);
        	                    args.push_back(body[1]);
        	                    if(!f2.isNull()) {
        	                      args.push_back(f2);
        	                    }

        	                    if( body.getKind()==kind::IMPLIES ){  
        	                      kind = kind::RR_DEDUCTION;
        	                    }else if( body.getKind()==kind::EQUAL ){
        	                      kind = body[0].getType().isBoolean() ? kind::RR_REDUCTION : kind::RR_REWRITE;
        	                    }else{
        	                      PARSER_STATE->parseError("Error parsing rewrite rule.");
        	                    }
        	                    expr = MK_EXPR( kind, args );
        	                  } else if(! patexprs.empty()) {
        	                    if( !f2.isNull() && f2.getKind()==kind::INST_PATTERN_LIST ){
        	                      for( size_t i=0; i<f2.getNumChildren(); i++ ){
        	                        if( f2[i].getKind()==kind::INST_PATTERN ){
        	                          patexprs.push_back( f2[i] );
        	                        }else{
        	                          std::stringstream ss;
        	                          ss << "warning: rewrite rules do not support " << f2[i]
        	                             << " within instantiation pattern list";
        	                          PARSER_STATE->warning(ss.str());
        	                        }
        	                      }
        	                    }
        	                    expr2 = MK_EXPR(kind::INST_PATTERN_LIST, patexprs);
        	                  } else {
        	                    expr2 = f2;
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2046:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL14 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3788);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST( AntlrInput::tokenToInteger(INTEGER_LITERAL14) ); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2049:5: DECIMAL_LITERAL
        	    {
        	        DECIMAL_LITERAL15 = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_term3801);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             // FIXME: This doesn't work because an SMT rational is not a
        	                  // valid GMP rational string
        	                  expr = MK_CONST( AntlrInput::tokenToRational(DECIMAL_LITERAL15) ); 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2054:5: LPAREN_TOK INDEX_TOK (bvLit= SIMPLE_SYMBOL size= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL ) RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_term3814);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	         MATCHT(INDEX_TOK, &FOLLOW_INDEX_TOK_in_term3816);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:2055:5: (bvLit= SIMPLE_SYMBOL size= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL )
        	        {
        	            int alt47=4;
        	            switch ( LA(1) )
        	            {
        	            case SIMPLE_SYMBOL:
        	            	{
        	            		alt47=1;
        	            	}
        	                break;
        	            case FP_PINF_TOK:
        	            	{
        	            		alt47=2;
        	            	}
        	                break;
        	            case FP_NINF_TOK:
        	            	{
        	            		alt47=3;
        	            	}
        	                break;
        	            case FP_NAN_TOK:
        	            	{
        	            		alt47=4;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 47;
        	                EXCEPTION->state        = 0;


        	                goto ruletermEx;

        	            }

        	            switch (alt47)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2055:7: bvLit= SIMPLE_SYMBOL size= INTEGER_LITERAL
        	        	    {
        	        	        bvLit = (pANTLR3_COMMON_TOKEN) MATCHT(SIMPLE_SYMBOL, &FOLLOW_SIMPLE_SYMBOL_in_term3827);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        size = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3831);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        {
        	        	             if(AntlrInput::tokenText(bvLit).find("bv") == 0) {
        	        	                       expr = MK_CONST( AntlrInput::tokenToBitvector(bvLit, size) );
        	        	                    } else {
        	        	                       PARSER_STATE->parseError("Unexpected symbol `" +
        	        	                                                AntlrInput::tokenText(bvLit) + "'");
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2063:7: FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
        	        	    {
        	        	         MATCHT(FP_PINF_TOK, &FOLLOW_FP_PINF_TOK_in_term3848);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3852);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3856);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        {
        	        	             expr = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
        	        	                                                  AntlrInput::tokenToUnsigned(sb),
        	        	                                                  +INFINITY)); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2067:7: FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
        	        	    {
        	        	         MATCHT(FP_NINF_TOK, &FOLLOW_FP_NINF_TOK_in_term3872);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3876);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3880);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        {
        	        	             expr = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
        	        	                                                  AntlrInput::tokenToUnsigned(sb),
        	        	                                                 -INFINITY)); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2071:7: FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
        	        	    {
        	        	         MATCHT(FP_NAN_TOK, &FOLLOW_FP_NAN_TOK_in_term3896);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3900);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_term3904);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermEx;
        	        	        }


        	        	        {
        	        	             expr = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
        	        	                                                  AntlrInput::tokenToUnsigned(sb),
        	        	                                                  NAN)); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_term3930);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2080:5: HEX_LITERAL
        	    {
        	        HEX_LITERAL16 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_term3937);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             assert( AntlrInput::tokenText(HEX_LITERAL16).find("#x") == 0 );
        	                  std::string hexString = AntlrInput::tokenTextSubstr(HEX_LITERAL16, 2);
        	                  expr = MK_CONST( BitVector(hexString, 16) ); 
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2085:5: BINARY_LITERAL
        	    {
        	        BINARY_LITERAL17 = (pANTLR3_COMMON_TOKEN) MATCHT(BINARY_LITERAL, &FOLLOW_BINARY_LITERAL_in_term3950);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             assert( AntlrInput::tokenText(BINARY_LITERAL17).find("#b") == 0 );
        	                  std::string binString = AntlrInput::tokenTextSubstr(BINARY_LITERAL17, 2);
        	                  expr = MK_CONST( BitVector(binString, 2) ); 
        	        }


        	    }
        	    break;
        	case 15:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2090:5: str[s,false]
        	    {
        	        FOLLOWPUSH(FOLLOW_str_in_term3963);
        	        str(ctx, s, false);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST( ::CVC4::String(s) ); 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2092:5: FP_RNE_TOK
        	    {
        	         MATCHT(FP_RNE_TOK, &FOLLOW_FP_RNE_TOK_in_term3976);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundNearestTiesToEven); 
        	        }


        	    }
        	    break;
        	case 17:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2093:5: FP_RNA_TOK
        	    {
        	         MATCHT(FP_RNA_TOK, &FOLLOW_FP_RNA_TOK_in_term3989);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundNearestTiesToAway); 
        	        }


        	    }
        	    break;
        	case 18:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2094:5: FP_RTP_TOK
        	    {
        	         MATCHT(FP_RTP_TOK, &FOLLOW_FP_RTP_TOK_in_term4002);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundTowardPositive); 
        	        }


        	    }
        	    break;
        	case 19:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2095:5: FP_RTN_TOK
        	    {
        	         MATCHT(FP_RTN_TOK, &FOLLOW_FP_RTN_TOK_in_term4015);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundTowardNegative); 
        	        }


        	    }
        	    break;
        	case 20:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2096:5: FP_RTZ_TOK
        	    {
        	         MATCHT(FP_RTZ_TOK, &FOLLOW_FP_RTZ_TOK_in_term4028);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundTowardZero); 
        	        }


        	    }
        	    break;
        	case 21:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2097:5: FP_RNE_FULL_TOK
        	    {
        	         MATCHT(FP_RNE_FULL_TOK, &FOLLOW_FP_RNE_FULL_TOK_in_term4041);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundNearestTiesToEven); 
        	        }


        	    }
        	    break;
        	case 22:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2098:5: FP_RNA_FULL_TOK
        	    {
        	         MATCHT(FP_RNA_FULL_TOK, &FOLLOW_FP_RNA_FULL_TOK_in_term4049);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundNearestTiesToAway); 
        	        }


        	    }
        	    break;
        	case 23:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2099:5: FP_RTP_FULL_TOK
        	    {
        	         MATCHT(FP_RTP_FULL_TOK, &FOLLOW_FP_RTP_FULL_TOK_in_term4057);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundTowardPositive); 
        	        }


        	    }
        	    break;
        	case 24:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2100:5: FP_RTN_FULL_TOK
        	    {
        	         MATCHT(FP_RTN_FULL_TOK, &FOLLOW_FP_RTN_FULL_TOK_in_term4065);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundTowardNegative); 
        	        }


        	    }
        	    break;
        	case 25:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2101:5: FP_RTZ_FULL_TOK
        	    {
        	         MATCHT(FP_RTZ_FULL_TOK, &FOLLOW_FP_RTZ_FULL_TOK_in_term4073);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST(roundTowardZero); 
        	        }


        	    }
        	    break;
        	case 26:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2103:5: RENOSTR_TOK
        	    {
        	         MATCHT(RENOSTR_TOK, &FOLLOW_RENOSTR_TOK_in_term4082);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             std::vector< Expr > nvec;
        	                  expr = MK_EXPR( CVC4::kind::REGEXP_EMPTY, nvec );
        	                
        	        }


        	    }
        	    break;
        	case 27:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2108:5: REALLCHAR_TOK
        	    {
        	         MATCHT(REALLCHAR_TOK, &FOLLOW_REALLCHAR_TOK_in_term4095);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             std::vector< Expr > nvec;
        	                  expr = MK_EXPR( CVC4::kind::REGEXP_SIGMA, nvec );
        	                
        	        }


        	    }
        	    break;
        	case 28:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2113:5: EMPTYSET_TOK
        	    {
        	         MATCHT(EMPTYSET_TOK, &FOLLOW_EMPTYSET_TOK_in_term4108);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             expr = MK_CONST( ::CVC4::EmptySet(Type())); 
        	        }


        	    }
        	    break;
        	case 29:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2116:5: UNIVSET_TOK
        	    {
        	         MATCHT(UNIVSET_TOK, &FOLLOW_UNIVSET_TOK_in_term4121);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             //booleanType is placeholder here since we don't have type info without type annotation
        	                  expr = EXPR_MANAGER->mkUniqueVar(EXPR_MANAGER->booleanType(), kind::UNIVERSE_SET); 
        	        }


        	    }
        	    break;
        	case 30:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2120:5: NILREF_TOK
        	    {
        	         MATCHT(NILREF_TOK, &FOLLOW_NILREF_TOK_in_term4134);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {
        	             //booleanType is placeholder here since we don't have type info without type annotation
        	                  expr = EXPR_MANAGER->mkUniqueVar(EXPR_MANAGER->booleanType(), kind::SEP_NIL); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start attribute
 * ../../../../../../src/parser/smt2/Smt2.g:2129:1: attribute[CVC4::Expr& expr, CVC4::Expr& retExpr, std::string& attr] : ( KEYWORD ( simpleSymbolicExprNoKeyword[sexpr] )? | ATTRIBUTE_PATTERN_TOK LPAREN_TOK ( term[patexpr, e2] )+ RPAREN_TOK | ATTRIBUTE_NO_PATTERN_TOK term[patexpr, e2] |tok= ( ATTRIBUTE_INST_LEVEL | ATTRIBUTE_RR_PRIORITY ) INTEGER_LITERAL | ATTRIBUTE_NAMED_TOK symbolicExpr[sexpr] );
 */
static void
attribute(pSmt2Parser ctx, CVC4::Expr& expr, CVC4::Expr& retExpr, std::string& attr)
{
    pANTLR3_COMMON_TOKEN    tok;
    pANTLR3_COMMON_TOKEN    KEYWORD18;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL19;

    /* Initialize rule variables
     */


      SExpr sexpr;
      Expr patexpr;
      std::vector<Expr> patexprs;
      Expr e2;
      bool hasValue = false;

    tok       = NULL;
    KEYWORD18       = NULL;
    INTEGER_LITERAL19       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:2137:3: ( KEYWORD ( simpleSymbolicExprNoKeyword[sexpr] )? | ATTRIBUTE_PATTERN_TOK LPAREN_TOK ( term[patexpr, e2] )+ RPAREN_TOK | ATTRIBUTE_NO_PATTERN_TOK term[patexpr, e2] |tok= ( ATTRIBUTE_INST_LEVEL | ATTRIBUTE_RR_PRIORITY ) INTEGER_LITERAL | ATTRIBUTE_NAMED_TOK symbolicExpr[sexpr] )

            ANTLR3_UINT32 alt51;

            alt51=5;

            switch ( LA(1) )
            {
            case KEYWORD:
            	{
            		alt51=1;
            	}
                break;
            case ATTRIBUTE_PATTERN_TOK:
            	{
            		alt51=2;
            	}
                break;
            case ATTRIBUTE_NO_PATTERN_TOK:
            	{
            		alt51=3;
            	}
                break;
            case ATTRIBUTE_INST_LEVEL:
            case ATTRIBUTE_RR_PRIORITY:
            	{
            		alt51=4;
            	}
                break;
            case ATTRIBUTE_NAMED_TOK:
            	{
            		alt51=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 51;
                EXCEPTION->state        = 0;


                goto ruleattributeEx;

            }

            switch (alt51)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2137:5: KEYWORD ( simpleSymbolicExprNoKeyword[sexpr] )?
        	    {
        	        KEYWORD18 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_attribute4166);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:2137:13: ( simpleSymbolicExprNoKeyword[sexpr] )?
        	        {
        	            int alt49=2;
        	            switch ( LA(1) )
        	            {
        	                case AND_TOK:
        	                case ASSERT_TOK:
        	                case BINARY_LITERAL:
        	                case BV2NAT_TOK:
        	                case CHECKSAT_TOK:
        	                case CHECK_SYNTH_TOK:
        	                case CONSTRAINT_TOK:
        	                case DECIMAL_LITERAL:
        	                case DECLARE_DATATYPES_TOK:
        	                case DECLARE_FUN_TOK:
        	                case DECLARE_PRIMED_VAR_TOK:
        	                case DECLARE_SORT_TOK:
        	                case DECLARE_VAR_TOK:
        	                case DEFINE_FUNS_REC_TOK:
        	                case DEFINE_FUN_REC_TOK:
        	                case DEFINE_FUN_TOK:
        	                case DEFINE_SORT_TOK:
        	                case DISTINCT_TOK:
        	                case DIV_TOK:
        	                case DTSIZE_TOK:
        	                case ECHO_TOK:
        	                case EQUAL_TOK:
        	                case EXIT_TOK:
        	                case FMFCARDVAL_TOK:
        	                case FMFCARD_TOK:
        	                case GET_ASSERTIONS_TOK:
        	                case GET_ASSIGNMENT_TOK:
        	                case GET_INFO_TOK:
        	                case GET_MODEL_TOK:
        	                case GET_OPTION_TOK:
        	                case GET_PROOF_TOK:
        	                case GET_UNSAT_CORE_TOK:
        	                case GET_VALUE_TOK:
        	                case GREATER_THAN_EQUAL_TOK:
        	                case GREATER_THAN_TOK:
        	                case HEX_LITERAL:
        	                case IMPLIES_TOK:
        	                case INST_CLOSURE_TOK:
        	                case INTEGER_LITERAL:
        	                case INV_CONSTRAINT_TOK:
        	                case ITE_TOK:
        	                case LESS_THAN_EQUAL_TOK:
        	                case LESS_THAN_TOK:
        	                case MINUS_TOK:
        	                case NOT_TOK:
        	                case OR_TOK:
        	                case PLUS_TOK:
        	                case POP_TOK:
        	                case PROPAGATION_RULE_TOK:
        	                case PUSH_TOK:
        	                case QUOTED_SYMBOL:
        	                case REDUCTION_RULE_TOK:
        	                case RESET_ASSERTIONS_TOK:
        	                case RESET_TOK:
        	                case REWRITE_RULE_TOK:
        	                case SET_INFO_TOK:
        	                case SET_LOGIC_TOK:
        	                case SET_OPTIONS_TOK:
        	                case SET_OPTION_TOK:
        	                case SIMPLE_SYMBOL:
        	                case SIMPLIFY_TOK:
        	                case STAR_TOK:
        	                case STRING_LITERAL_2_0:
        	                case STRING_LITERAL_2_5:
        	                case SYNTH_FUN_TOK:
        	                case SYNTH_INV_TOK:
        	                case UNTERMINATED_QUOTED_SYMBOL:
        	                case XOR_TOK:
        	                case 147:
        	                	{
        	                		alt49=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt49)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2137:15: simpleSymbolicExprNoKeyword[sexpr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4170);
        	        	        simpleSymbolicExprNoKeyword(ctx, sexpr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattributeEx;
        	        	        }


        	        	        {
        	        	             hasValue = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                attr = AntlrInput::tokenText(KEYWORD18);
        	                // EXPR_MANAGER->setNamedAttribute( expr, attr );
        	                if(attr == ":rewrite-rule") {
        	                  if(hasValue) {
        	                    std::stringstream ss;
        	                    ss << "warning: Attribute " << attr
        	                       << " does not take a value (ignoring)";
        	                    PARSER_STATE->warning(ss.str());
        	                  }
        	                  // do nothing
        	                } else if(attr==":axiom" || attr==":conjecture" || attr==":fun-def" ||
        	                          attr==":sygus" || attr==":synthesis") {
        	                  if(hasValue) {
        	                    std::stringstream ss;
        	                    ss << "warning: Attribute " << attr
        	                       << " does not take a value (ignoring)";
        	                    PARSER_STATE->warning(ss.str());
        	                  }
        	                  Expr avar;
        	                  bool success = true;
        	                  std::string attr_name = attr;
        	                  attr_name.erase( attr_name.begin() );
        	                  if( attr==":fun-def" ){
        	                    if( expr.getKind()!=kind::EQUAL || expr[0].getKind()!=kind::APPLY_UF ){
        	                      success = false;
        	                    }else{
        	                      FunctionType t = (FunctionType)expr[0].getOperator().getType();
        	                      for( unsigned i=0; i<expr[0].getNumChildren(); i++ ){
        	                        if( expr[0][i].getKind() != kind::BOUND_VARIABLE ||
        	                            expr[0][i].getType() != t.getArgTypes()[i] ){
        	                          success = false;
        	                          break;
        	                        }else{
        	                          for( unsigned j=0; j<i; j++ ){
        	                            if( expr[0][j]==expr[0][i] ){
        	                              success = false;
        	                              break;
        	                            }
        	                          }
        	                        }
        	                      }
        	                    }
        	                    if( !success ){
        	                      std::stringstream ss;
        	                      ss << "warning: Function definition should be an equality whose LHS "
        	                         << "is an uninterpreted function applied to unique variables.";
        	                      PARSER_STATE->warning(ss.str());
        	                    }else{
        	                      avar = expr[0];
        	                    }
        	                  }else{
        	                    Type t = EXPR_MANAGER->booleanType();
        	                    avar = PARSER_STATE->mkVar(attr_name, t);
        	                  }
        	                  if( success ){
        	                    //Will set the attribute on auxiliary var (preserves attribute on
        	                    //formula through rewriting).
        	                    retExpr = MK_EXPR(kind::INST_ATTRIBUTE, avar);
        	                    Command* c = new SetUserAttributeCommand( attr_name, avar );
        	                    c->setMuted(true);
        	                    PARSER_STATE->preemptCommand(c);
        	                  }
        	                } else {
        	                  PARSER_STATE->attributeNotSupported(attr);
        	                }
        	              
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2205:5: ATTRIBUTE_PATTERN_TOK LPAREN_TOK ( term[patexpr, e2] )+ RPAREN_TOK
        	    {
        	         MATCHT(ATTRIBUTE_PATTERN_TOK, &FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4186);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_attribute4188);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:2206:5: ( term[patexpr, e2] )+
        	        {
        	            int cnt50=0;

        	            for (;;)
        	            {
        	                int alt50=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case BINARY_LITERAL:
        	        	case CHECK_SYNTH_TOK:
        	        	case CONSTRAINT_TOK:
        	        	case DECIMAL_LITERAL:
        	        	case DECLARE_PRIMED_VAR_TOK:
        	        	case DECLARE_VAR_TOK:
        	        	case EMPTYSET_TOK:
        	        	case FP_RNA_FULL_TOK:
        	        	case FP_RNA_TOK:
        	        	case FP_RNE_FULL_TOK:
        	        	case FP_RNE_TOK:
        	        	case FP_RTN_FULL_TOK:
        	        	case FP_RTN_TOK:
        	        	case FP_RTP_FULL_TOK:
        	        	case FP_RTP_TOK:
        	        	case FP_RTZ_FULL_TOK:
        	        	case FP_RTZ_TOK:
        	        	case HEX_LITERAL:
        	        	case INTEGER_LITERAL:
        	        	case INV_CONSTRAINT_TOK:
        	        	case LPAREN_TOK:
        	        	case NILREF_TOK:
        	        	case QUOTED_SYMBOL:
        	        	case REALLCHAR_TOK:
        	        	case RENOSTR_TOK:
        	        	case SET_OPTIONS_TOK:
        	        	case SIMPLE_SYMBOL:
        	        	case STRING_LITERAL_2_0:
        	        	case STRING_LITERAL_2_5:
        	        	case SYNTH_FUN_TOK:
        	        	case SYNTH_INV_TOK:
        	        	case UNIVSET_TOK:
        	        	case UNTERMINATED_QUOTED_SYMBOL:
        	        	case 147:
        	        		{
        	        			alt50=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt50)
        	        	{
        	        	    case 1:
        	        	        // ../../../../../../src/parser/smt2/Smt2.g:2206:7: term[patexpr, e2]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_term_in_attribute4196);
        	        	            term(ctx, patexpr, e2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleattributeEx;
        	        	            }


        	        	            {
        	        	                 patexprs.push_back( patexpr ); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt50 >= 1 )
        	        		{
        	        		    goto loop50;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleattributeEx;
        	        	}
        	        	cnt50++;
        	            }
        	            loop50: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_attribute4214);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  attr = std::string(":pattern");
        	                  retExpr = MK_EXPR(kind::INST_PATTERN, patexprs);
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2213:5: ATTRIBUTE_NO_PATTERN_TOK term[patexpr, e2]
        	    {
        	         MATCHT(ATTRIBUTE_NO_PATTERN_TOK, &FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4226);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_attribute4228);
        	        term(ctx, patexpr, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  attr = std::string(":no-pattern");
        	                  retExpr = MK_EXPR(kind::INST_NO_PATTERN, patexpr);
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2218:5: tok= ( ATTRIBUTE_INST_LEVEL | ATTRIBUTE_RR_PRIORITY ) INTEGER_LITERAL
        	    {
        	        tok=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == ATTRIBUTE_INST_LEVEL || LA(1) == ATTRIBUTE_RR_PRIORITY )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto ruleattributeEx;
        	        }


        	        INTEGER_LITERAL19 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_attribute4253);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  Expr n = MK_CONST( AntlrInput::tokenToInteger(INTEGER_LITERAL19) );
        	                  std::vector<Expr> values;
        	                  values.push_back( n );
        	                  std::string attr_name(AntlrInput::tokenText(tok));
        	                  attr_name.erase( attr_name.begin() );
        	                  Type t = EXPR_MANAGER->booleanType();
        	                  Expr avar = PARSER_STATE->mkVar(attr_name, t);
        	                  retExpr = MK_EXPR(kind::INST_ATTRIBUTE, avar);
        	                  Command* c = new SetUserAttributeCommand( attr_name, avar, values );
        	                  c->setMuted(true);
        	                  PARSER_STATE->preemptCommand(c);
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2232:5: ATTRIBUTE_NAMED_TOK symbolicExpr[sexpr]
        	    {
        	         MATCHT(ATTRIBUTE_NAMED_TOK, &FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4265);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbolicExpr_in_attribute4267);
        	        symbolicExpr(ctx, sexpr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  attr = std::string(":named");
        	                  if(!sexpr.isKeyword()) {
        	                    PARSER_STATE->parseError("improperly formed :named annotation");
        	                  }
        	                  std::string name = sexpr.getValue();
        	                  PARSER_STATE->checkUserSymbol(name);
        	                  // ensure expr is a closed subterm
        	                  std::set<Expr> freeVars;
        	                  if(!isClosed(expr, freeVars)) {
        	                    assert(!freeVars.empty());
        	                    std::stringstream ss;
        	                    ss << ":named annotations can only name terms that are closed; this "
        	                       << "one contains free variables:";
        	                    for(std::set<Expr>::const_iterator i = freeVars.begin();
        	                        i != freeVars.end(); ++i) {
        	                      ss << " " << *i;
        	                    }
        	                    PARSER_STATE->parseError(ss.str());
        	                  }
        	                  // check that sexpr is a fresh function symbol, and reserve it
        	                  PARSER_STATE->reserveSymbolAtAssertionLevel(name);
        	                  // define it
        	                  Expr func = PARSER_STATE->mkFunction(name, expr.getType());
        	                  // remember the last term to have been given a :named attribute
        	                  PARSER_STATE->setLastNamedTerm(expr, name);
        	                  // bind name to expr with define-fun
        	                  Command* c =
        	                    new DefineNamedFunctionCommand(name, func, std::vector<Expr>(), expr);
        	                  c->setMuted(true);
        	                  PARSER_STATE->preemptCommand(c);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleattributeEx; /* Prevent compiler warnings */
    ruleattributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end attribute */

/**
 * $ANTLR start indexedFunctionName
 * ../../../../../../src/parser/smt2/Smt2.g:2270:1: indexedFunctionName[CVC4::Expr& op] : LPAREN_TOK INDEX_TOK ( 'extract' n1= INTEGER_LITERAL n2= INTEGER_LITERAL | 'repeat' n= INTEGER_LITERAL | 'zero_extend' n= INTEGER_LITERAL | 'sign_extend' n= INTEGER_LITERAL | 'rotate_left' n= INTEGER_LITERAL | 'rotate_right' n= INTEGER_LITERAL | DIVISIBLE_TOK n= INTEGER_LITERAL | INT2BV_TOK n= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_PZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPBV_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPFP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPR_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPS_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPU_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_UBV_TOK m= INTEGER_LITERAL | FP_TO_SBV_TOK m= INTEGER_LITERAL | badIndexedFunctionName ) RPAREN_TOK ;
 */
static void
indexedFunctionName(pSmt2Parser ctx, CVC4::Expr& op)
{
    pANTLR3_COMMON_TOKEN    n1;
    pANTLR3_COMMON_TOKEN    n2;
    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    eb;
    pANTLR3_COMMON_TOKEN    sb;
    pANTLR3_COMMON_TOKEN    m;

    /* Initialize rule variables
     */

    n1       = NULL;
    n2       = NULL;
    n       = NULL;
    eb       = NULL;
    sb       = NULL;
    m       = NULL;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2271:3: ( LPAREN_TOK INDEX_TOK ( 'extract' n1= INTEGER_LITERAL n2= INTEGER_LITERAL | 'repeat' n= INTEGER_LITERAL | 'zero_extend' n= INTEGER_LITERAL | 'sign_extend' n= INTEGER_LITERAL | 'rotate_left' n= INTEGER_LITERAL | 'rotate_right' n= INTEGER_LITERAL | DIVISIBLE_TOK n= INTEGER_LITERAL | INT2BV_TOK n= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_PZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPBV_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPFP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPR_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPS_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPU_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_UBV_TOK m= INTEGER_LITERAL | FP_TO_SBV_TOK m= INTEGER_LITERAL | badIndexedFunctionName ) RPAREN_TOK )
        // ../../../../../../src/parser/smt2/Smt2.g:2271:5: LPAREN_TOK INDEX_TOK ( 'extract' n1= INTEGER_LITERAL n2= INTEGER_LITERAL | 'repeat' n= INTEGER_LITERAL | 'zero_extend' n= INTEGER_LITERAL | 'sign_extend' n= INTEGER_LITERAL | 'rotate_left' n= INTEGER_LITERAL | 'rotate_right' n= INTEGER_LITERAL | DIVISIBLE_TOK n= INTEGER_LITERAL | INT2BV_TOK n= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_PZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPBV_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPFP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPR_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPS_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPU_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_UBV_TOK m= INTEGER_LITERAL | FP_TO_SBV_TOK m= INTEGER_LITERAL | badIndexedFunctionName ) RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_indexedFunctionName4290);
            if  (HASEXCEPTION())
            {
                goto ruleindexedFunctionNameEx;
            }


             MATCHT(INDEX_TOK, &FOLLOW_INDEX_TOK_in_indexedFunctionName4292);
            if  (HASEXCEPTION())
            {
                goto ruleindexedFunctionNameEx;
            }


            // ../../../../../../src/parser/smt2/Smt2.g:2272:5: ( 'extract' n1= INTEGER_LITERAL n2= INTEGER_LITERAL | 'repeat' n= INTEGER_LITERAL | 'zero_extend' n= INTEGER_LITERAL | 'sign_extend' n= INTEGER_LITERAL | 'rotate_left' n= INTEGER_LITERAL | 'rotate_right' n= INTEGER_LITERAL | DIVISIBLE_TOK n= INTEGER_LITERAL | INT2BV_TOK n= INTEGER_LITERAL | FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_PZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_NZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPBV_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPFP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPR_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPS_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_FPU_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL | FP_TO_UBV_TOK m= INTEGER_LITERAL | FP_TO_SBV_TOK m= INTEGER_LITERAL | badIndexedFunctionName )
            {
                int alt52=22;
                switch ( LA(1) )
                {
                case 146:
                	{
                		alt52=1;
                	}
                    break;
                case 147:
                	{
                		alt52=2;
                	}
                    break;
                case 151:
                	{
                		alt52=3;
                	}
                    break;
                case 150:
                	{
                		alt52=4;
                	}
                    break;
                case 148:
                	{
                		alt52=5;
                	}
                    break;
                case 149:
                	{
                		alt52=6;
                	}
                    break;
                case DIVISIBLE_TOK:
                	{
                		alt52=7;
                	}
                    break;
                case INT2BV_TOK:
                	{
                		alt52=8;
                	}
                    break;
                case FP_PINF_TOK:
                	{
                		alt52=9;
                	}
                    break;
                case FP_NINF_TOK:
                	{
                		alt52=10;
                	}
                    break;
                case FP_NAN_TOK:
                	{
                		alt52=11;
                	}
                    break;
                case FP_PZERO_TOK:
                	{
                		alt52=12;
                	}
                    break;
                case FP_NZERO_TOK:
                	{
                		alt52=13;
                	}
                    break;
                case FP_TO_FP_TOK:
                	{
                		alt52=14;
                	}
                    break;
                case FP_TO_FPBV_TOK:
                	{
                		alt52=15;
                	}
                    break;
                case FP_TO_FPFP_TOK:
                	{
                		alt52=16;
                	}
                    break;
                case FP_TO_FPR_TOK:
                	{
                		alt52=17;
                	}
                    break;
                case FP_TO_FPS_TOK:
                	{
                		alt52=18;
                	}
                    break;
                case FP_TO_FPU_TOK:
                	{
                		alt52=19;
                	}
                    break;
                case FP_TO_UBV_TOK:
                	{
                		alt52=20;
                	}
                    break;
                case FP_TO_SBV_TOK:
                	{
                		alt52=21;
                	}
                    break;
                case QUOTED_SYMBOL:
                case SIMPLE_SYMBOL:
                case UNTERMINATED_QUOTED_SYMBOL:
                	{
                		alt52=22;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 52;
                    EXCEPTION->state        = 0;


                    goto ruleindexedFunctionNameEx;

                }

                switch (alt52)
                {
            	case 1:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2272:7: 'extract' n1= INTEGER_LITERAL n2= INTEGER_LITERAL
            	    {
            	         MATCHT(146, &FOLLOW_146_in_indexedFunctionName4300);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n1 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4304);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n2 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4308);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(BitVectorExtract(AntlrInput::tokenToUnsigned(n1),
            	                                                   AntlrInput::tokenToUnsigned(n2))); 
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2275:7: 'repeat' n= INTEGER_LITERAL
            	    {
            	         MATCHT(147, &FOLLOW_147_in_indexedFunctionName4324);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4328);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(BitVectorRepeat(AntlrInput::tokenToUnsigned(n))); 
            	        }


            	    }
            	    break;
            	case 3:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2277:7: 'zero_extend' n= INTEGER_LITERAL
            	    {
            	         MATCHT(151, &FOLLOW_151_in_indexedFunctionName4344);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4348);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(BitVectorZeroExtend(AntlrInput::tokenToUnsigned(n))); 
            	        }


            	    }
            	    break;
            	case 4:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2279:7: 'sign_extend' n= INTEGER_LITERAL
            	    {
            	         MATCHT(150, &FOLLOW_150_in_indexedFunctionName4364);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4368);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(BitVectorSignExtend(AntlrInput::tokenToUnsigned(n))); 
            	        }


            	    }
            	    break;
            	case 5:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2281:7: 'rotate_left' n= INTEGER_LITERAL
            	    {
            	         MATCHT(148, &FOLLOW_148_in_indexedFunctionName4384);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4388);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(BitVectorRotateLeft(AntlrInput::tokenToUnsigned(n))); 
            	        }


            	    }
            	    break;
            	case 6:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2283:7: 'rotate_right' n= INTEGER_LITERAL
            	    {
            	         MATCHT(149, &FOLLOW_149_in_indexedFunctionName4404);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4408);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(BitVectorRotateRight(AntlrInput::tokenToUnsigned(n))); 
            	        }


            	    }
            	    break;
            	case 7:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2285:7: DIVISIBLE_TOK n= INTEGER_LITERAL
            	    {
            	         MATCHT(DIVISIBLE_TOK, &FOLLOW_DIVISIBLE_TOK_in_indexedFunctionName4424);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4428);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(Divisible(AntlrInput::tokenToUnsigned(n))); 
            	        }


            	    }
            	    break;
            	case 8:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2287:7: INT2BV_TOK n= INTEGER_LITERAL
            	    {
            	         MATCHT(INT2BV_TOK, &FOLLOW_INT2BV_TOK_in_indexedFunctionName4444);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4448);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(IntToBitVector(AntlrInput::tokenToUnsigned(n)));
            	                    if(PARSER_STATE->strictModeEnabled()) {
            	                      PARSER_STATE->parseError(
            	                          "bv2nat and int2bv are not part of SMT-LIB, and aren't available "
            	                          "in SMT-LIB strict compliance mode");
            	                    } 
            	        }


            	    }
            	    break;
            	case 9:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2294:7: FP_PINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_PINF_TOK, &FOLLOW_FP_PINF_TOK_in_indexedFunctionName4464);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4468);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4472);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
            	                                                AntlrInput::tokenToUnsigned(sb),
            	                                                +INFINITY)); 
            	        }


            	    }
            	    break;
            	case 10:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2298:7: FP_NINF_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_NINF_TOK, &FOLLOW_FP_NINF_TOK_in_indexedFunctionName4488);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4492);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4496);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
            	                                                AntlrInput::tokenToUnsigned(sb),
            	                                                -INFINITY)); 
            	        }


            	    }
            	    break;
            	case 11:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2302:7: FP_NAN_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_NAN_TOK, &FOLLOW_FP_NAN_TOK_in_indexedFunctionName4512);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4516);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4520);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
            	                                                AntlrInput::tokenToUnsigned(sb),
            	                                                NAN)); 
            	        }


            	    }
            	    break;
            	case 12:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2306:7: FP_PZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_PZERO_TOK, &FOLLOW_FP_PZERO_TOK_in_indexedFunctionName4536);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4540);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4544);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
            	                                                AntlrInput::tokenToUnsigned(sb),
            	                                                +0.0)); 
            	        }


            	    }
            	    break;
            	case 13:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2310:7: FP_NZERO_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_NZERO_TOK, &FOLLOW_FP_NZERO_TOK_in_indexedFunctionName4560);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4564);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4568);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPoint(AntlrInput::tokenToUnsigned(eb),
            	                                                AntlrInput::tokenToUnsigned(sb),
            	                                                -0.0)); 
            	        }


            	    }
            	    break;
            	case 14:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2314:7: FP_TO_FP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_FP_TOK, &FOLLOW_FP_TO_FP_TOK_in_indexedFunctionName4584);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4588);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4592);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToFPGeneric(
            	                            AntlrInput::tokenToUnsigned(eb),
            	                            AntlrInput::tokenToUnsigned(sb)));
            	                  
            	        }


            	    }
            	    break;
            	case 15:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2319:7: FP_TO_FPBV_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_FPBV_TOK, &FOLLOW_FP_TO_FPBV_TOK_in_indexedFunctionName4608);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4612);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4616);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToFPIEEEBitVector(
            	                            AntlrInput::tokenToUnsigned(eb),
            	                            AntlrInput::tokenToUnsigned(sb)));
            	                  
            	        }


            	    }
            	    break;
            	case 16:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2324:7: FP_TO_FPFP_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_FPFP_TOK, &FOLLOW_FP_TO_FPFP_TOK_in_indexedFunctionName4632);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4636);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4640);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToFPFloatingPoint(
            	                            AntlrInput::tokenToUnsigned(eb),
            	                            AntlrInput::tokenToUnsigned(sb)));
            	                  
            	        }


            	    }
            	    break;
            	case 17:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2329:7: FP_TO_FPR_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_FPR_TOK, &FOLLOW_FP_TO_FPR_TOK_in_indexedFunctionName4656);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4660);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4664);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToFPReal(AntlrInput::tokenToUnsigned(eb),
            	                                                        AntlrInput::tokenToUnsigned(sb)));
            	                  
            	        }


            	    }
            	    break;
            	case 18:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2333:7: FP_TO_FPS_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_FPS_TOK, &FOLLOW_FP_TO_FPS_TOK_in_indexedFunctionName4680);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4684);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4688);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToFPSignedBitVector(
            	                            AntlrInput::tokenToUnsigned(eb),
            	                            AntlrInput::tokenToUnsigned(sb)));
            	                  
            	        }


            	    }
            	    break;
            	case 19:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2338:7: FP_TO_FPU_TOK eb= INTEGER_LITERAL sb= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_FPU_TOK, &FOLLOW_FP_TO_FPU_TOK_in_indexedFunctionName4704);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        eb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4708);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        sb = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4712);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToFPUnsignedBitVector(
            	                            AntlrInput::tokenToUnsigned(eb),
            	                            AntlrInput::tokenToUnsigned(sb)));
            	                  
            	        }


            	    }
            	    break;
            	case 20:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2343:7: FP_TO_UBV_TOK m= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_UBV_TOK, &FOLLOW_FP_TO_UBV_TOK_in_indexedFunctionName4728);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        m = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4732);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToUBV(AntlrInput::tokenToUnsigned(m))); 
            	        }


            	    }
            	    break;
            	case 21:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2345:7: FP_TO_SBV_TOK m= INTEGER_LITERAL
            	    {
            	         MATCHT(FP_TO_SBV_TOK, &FOLLOW_FP_TO_SBV_TOK_in_indexedFunctionName4748);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        m = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_indexedFunctionName4752);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	        {
            	             op = MK_CONST(FloatingPointToSBV(AntlrInput::tokenToUnsigned(m))); 
            	        }


            	    }
            	    break;
            	case 22:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2347:7: badIndexedFunctionName
            	    {
            	        FOLLOWPUSH(FOLLOW_badIndexedFunctionName_in_indexedFunctionName4768);
            	        badIndexedFunctionName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexedFunctionNameEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_indexedFunctionName4780);
            if  (HASEXCEPTION())
            {
                goto ruleindexedFunctionNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleindexedFunctionNameEx; /* Prevent compiler warnings */
    ruleindexedFunctionNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end indexedFunctionName */

/**
 * $ANTLR start badIndexedFunctionName
 * ../../../../../../src/parser/smt2/Smt2.g:2356:1: badIndexedFunctionName : id= ( SIMPLE_SYMBOL | QUOTED_SYMBOL | UNTERMINATED_QUOTED_SYMBOL ) ;
 */
static void
badIndexedFunctionName(pSmt2Parser ctx)
{

      std::string name;

    pANTLR3_COMMON_TOKEN    id;

    /* Initialize rule variables
     */

    id       = NULL;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2360:3: (id= ( SIMPLE_SYMBOL | QUOTED_SYMBOL | UNTERMINATED_QUOTED_SYMBOL ) )
        // ../../../../../../src/parser/smt2/Smt2.g:2360:5: id= ( SIMPLE_SYMBOL | QUOTED_SYMBOL | UNTERMINATED_QUOTED_SYMBOL )
        {
            id=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == QUOTED_SYMBOL || LA(1) == SIMPLE_SYMBOL || LA(1) == UNTERMINATED_QUOTED_SYMBOL )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulebadIndexedFunctionNameEx;
            }


            {
                 PARSER_STATE->parseError(std::string("Unknown indexed function `") +
                          AntlrInput::tokenText(id) + "'");
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebadIndexedFunctionNameEx; /* Prevent compiler warnings */
    rulebadIndexedFunctionNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end badIndexedFunctionName */

/**
 * $ANTLR start termList
 * ../../../../../../src/parser/smt2/Smt2.g:2374:1: termList[std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr] : ( term[expr, expr2] )+ ;
 */
static void
termList(pSmt2Parser ctx, std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr)
{

      Expr expr2;

    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2378:3: ( ( term[expr, expr2] )+ )
        // ../../../../../../src/parser/smt2/Smt2.g:2378:5: ( term[expr, expr2] )+
        {
            // ../../../../../../src/parser/smt2/Smt2.g:2378:5: ( term[expr, expr2] )+
            {
                int cnt53=0;

                for (;;)
                {
                    int alt53=2;
            	switch ( LA(1) )
            	{
            	case BINARY_LITERAL:
            	case CHECK_SYNTH_TOK:
            	case CONSTRAINT_TOK:
            	case DECIMAL_LITERAL:
            	case DECLARE_PRIMED_VAR_TOK:
            	case DECLARE_VAR_TOK:
            	case EMPTYSET_TOK:
            	case FP_RNA_FULL_TOK:
            	case FP_RNA_TOK:
            	case FP_RNE_FULL_TOK:
            	case FP_RNE_TOK:
            	case FP_RTN_FULL_TOK:
            	case FP_RTN_TOK:
            	case FP_RTP_FULL_TOK:
            	case FP_RTP_TOK:
            	case FP_RTZ_FULL_TOK:
            	case FP_RTZ_TOK:
            	case HEX_LITERAL:
            	case INTEGER_LITERAL:
            	case INV_CONSTRAINT_TOK:
            	case LPAREN_TOK:
            	case NILREF_TOK:
            	case QUOTED_SYMBOL:
            	case REALLCHAR_TOK:
            	case RENOSTR_TOK:
            	case SET_OPTIONS_TOK:
            	case SIMPLE_SYMBOL:
            	case STRING_LITERAL_2_0:
            	case STRING_LITERAL_2_5:
            	case SYNTH_FUN_TOK:
            	case SYNTH_INV_TOK:
            	case UNIVSET_TOK:
            	case UNTERMINATED_QUOTED_SYMBOL:
            	case 147:
            		{
            			alt53=1;
            		}
            	    break;

            	}

            	switch (alt53)
            	{
            	    case 1:
            	        // ../../../../../../src/parser/smt2/Smt2.g:2378:7: term[expr, expr2]
            	        {
            	            FOLLOWPUSH(FOLLOW_term_in_termList4843);
            	            term(ctx, expr, expr2);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletermListEx;
            	            }


            	            {
            	                 formulas.push_back(expr); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt53 >= 1 )
            		{
            		    goto loop53;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletermListEx;
            	}
            	cnt53++;
                }
                loop53: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletermListEx; /* Prevent compiler warnings */
    ruletermListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end termList */

/**
 * $ANTLR start str
 * ../../../../../../src/parser/smt2/Smt2.g:2384:1: str[std::string& s, bool fsmtlib] : ( STRING_LITERAL_2_0 | STRING_LITERAL_2_5 );
 */
static void
str(pSmt2Parser ctx, std::string& s, bool fsmtlib)
{
    pANTLR3_COMMON_TOKEN    STRING_LITERAL_2_020;
    pANTLR3_COMMON_TOKEN    STRING_LITERAL_2_521;

    /* Initialize rule variables
     */

    STRING_LITERAL_2_020       = NULL;
    STRING_LITERAL_2_521       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:2385:3: ( STRING_LITERAL_2_0 | STRING_LITERAL_2_5 )

            ANTLR3_UINT32 alt54;

            alt54=2;

            switch ( LA(1) )
            {
            case STRING_LITERAL_2_0:
            	{
            		alt54=1;
            	}
                break;
            case STRING_LITERAL_2_5:
            	{
            		alt54=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 54;
                EXCEPTION->state        = 0;


                goto rulestrEx;

            }

            switch (alt54)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2385:5: STRING_LITERAL_2_0
        	    {
        	        STRING_LITERAL_2_020 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL_2_0, &FOLLOW_STRING_LITERAL_2_0_in_str4865);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestrEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(STRING_LITERAL_2_020);
        	                  /* strip off the quotes */
        	                  s = s.substr(1, s.size() - 2);
        	                  for(size_t i=0; i<s.size(); i++) {
        	                    if((unsigned)s[i] > 127 && !isprint(s[i])) {
        	                      PARSER_STATE->parseError("Extended/unprintable characters are not "
        	                                               "part of SMT-LIB, and they must be encoded "
        	                                               "as escape sequences");
        	                    }
        	                  }
        	                  if(fsmtlib) {
        	                    /* handle SMT-LIB standard escapes '\\' and '\"' */
        	                    char* p_orig = strdup(s.c_str());
        	                    char *p = p_orig, *q = p_orig;
        	                    while(*q != '\0') {
        	                      if(*q == '\\') {
        	                        ++q;
        	                        if(*q == '\\' || *q == '"') {
        	                          *p++ = *q++;
        	                        } else {
        	                          assert(*q != '\0');
        	                          *p++ = '\\';
        	                          *p++ = *q++;
        	                        }
        	                      } else {
        	                        *p++ = *q++;
        	                      }
        	                    }
        	                    *p = '\0';
        	                    s = p_orig;
        	                    free(p_orig);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2419:5: STRING_LITERAL_2_5
        	    {
        	        STRING_LITERAL_2_521 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL_2_5, &FOLLOW_STRING_LITERAL_2_5_in_str4877);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestrEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(STRING_LITERAL_2_521);
        	                  /* strip off the quotes */
        	                  s = s.substr(1, s.size() - 2);
        	                  for(size_t i=0; i<s.size(); i++) {
        	                    if((unsigned)s[i] > 127 && !isprint(s[i])) {
        	                      PARSER_STATE->parseError("Extended/unprintable characters are not "
        	                                               "part of SMT-LIB, and they must be encoded "
        	                                               "as escape sequences");
        	                    }
        	                  }
        	                  // In the 2.5 version, always handle escapes (regardless of fsmtlib flag).
        	                  char* p_orig = strdup(s.c_str());
        	                  char *p = p_orig, *q = p_orig;
        	                  while(*q != '\0') {
        	                    if(*q == '"') {
        	                      ++q;
        	                      assert(*q == '"');
        	                    }
        	                    *p++ = *q++;
        	                  }
        	                  *p = '\0';
        	                  s = p_orig;
        	                  free(p_orig);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestrEx; /* Prevent compiler warnings */
    rulestrEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end str */

/**
 * $ANTLR start builtinOp
 * ../../../../../../src/parser/smt2/Smt2.g:2449:1: builtinOp[CVC4::Kind& kind] : ( NOT_TOK | IMPLIES_TOK | AND_TOK | OR_TOK | XOR_TOK | EQUAL_TOK | DISTINCT_TOK | ITE_TOK | GREATER_THAN_TOK | GREATER_THAN_EQUAL_TOK | LESS_THAN_EQUAL_TOK | LESS_THAN_TOK | PLUS_TOK | MINUS_TOK | STAR_TOK | DIV_TOK | BV2NAT_TOK | DTSIZE_TOK | FMFCARD_TOK | FMFCARDVAL_TOK | INST_CLOSURE_TOK );
 */
static void
builtinOp(pSmt2Parser ctx, CVC4::Kind& kind)
{
    /* Initialize rule variables
     */


      Debug("parser") << "builtin: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:2453:3: ( NOT_TOK | IMPLIES_TOK | AND_TOK | OR_TOK | XOR_TOK | EQUAL_TOK | DISTINCT_TOK | ITE_TOK | GREATER_THAN_TOK | GREATER_THAN_EQUAL_TOK | LESS_THAN_EQUAL_TOK | LESS_THAN_TOK | PLUS_TOK | MINUS_TOK | STAR_TOK | DIV_TOK | BV2NAT_TOK | DTSIZE_TOK | FMFCARD_TOK | FMFCARDVAL_TOK | INST_CLOSURE_TOK )

            ANTLR3_UINT32 alt55;

            alt55=21;

            switch ( LA(1) )
            {
            case NOT_TOK:
            	{
            		alt55=1;
            	}
                break;
            case IMPLIES_TOK:
            	{
            		alt55=2;
            	}
                break;
            case AND_TOK:
            	{
            		alt55=3;
            	}
                break;
            case OR_TOK:
            	{
            		alt55=4;
            	}
                break;
            case XOR_TOK:
            	{
            		alt55=5;
            	}
                break;
            case EQUAL_TOK:
            	{
            		alt55=6;
            	}
                break;
            case DISTINCT_TOK:
            	{
            		alt55=7;
            	}
                break;
            case ITE_TOK:
            	{
            		alt55=8;
            	}
                break;
            case GREATER_THAN_TOK:
            	{
            		alt55=9;
            	}
                break;
            case GREATER_THAN_EQUAL_TOK:
            	{
            		alt55=10;
            	}
                break;
            case LESS_THAN_EQUAL_TOK:
            	{
            		alt55=11;
            	}
                break;
            case LESS_THAN_TOK:
            	{
            		alt55=12;
            	}
                break;
            case PLUS_TOK:
            	{
            		alt55=13;
            	}
                break;
            case MINUS_TOK:
            	{
            		alt55=14;
            	}
                break;
            case STAR_TOK:
            	{
            		alt55=15;
            	}
                break;
            case DIV_TOK:
            	{
            		alt55=16;
            	}
                break;
            case BV2NAT_TOK:
            	{
            		alt55=17;
            	}
                break;
            case DTSIZE_TOK:
            	{
            		alt55=18;
            	}
                break;
            case FMFCARD_TOK:
            	{
            		alt55=19;
            	}
                break;
            case FMFCARDVAL_TOK:
            	{
            		alt55=20;
            	}
                break;
            case INST_CLOSURE_TOK:
            	{
            		alt55=21;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 55;
                EXCEPTION->state        = 0;


                goto rulebuiltinOpEx;

            }

            switch (alt55)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2453:5: NOT_TOK
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_builtinOp4904);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::NOT;     
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2454:5: IMPLIES_TOK
        	    {
        	         MATCHT(IMPLIES_TOK, &FOLLOW_IMPLIES_TOK_in_builtinOp4917);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::IMPLIES; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2455:5: AND_TOK
        	    {
        	         MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_builtinOp4926);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::AND;     
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2456:5: OR_TOK
        	    {
        	         MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_builtinOp4939);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::OR;      
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2457:5: XOR_TOK
        	    {
        	         MATCHT(XOR_TOK, &FOLLOW_XOR_TOK_in_builtinOp4953);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::XOR;     
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2458:5: EQUAL_TOK
        	    {
        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_builtinOp4966);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::EQUAL;   
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2459:5: DISTINCT_TOK
        	    {
        	         MATCHT(DISTINCT_TOK, &FOLLOW_DISTINCT_TOK_in_builtinOp4977);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::DISTINCT; 
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2460:5: ITE_TOK
        	    {
        	         MATCHT(ITE_TOK, &FOLLOW_ITE_TOK_in_builtinOp4985);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::ITE; 
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2461:5: GREATER_THAN_TOK
        	    {
        	         MATCHT(GREATER_THAN_TOK, &FOLLOW_GREATER_THAN_TOK_in_builtinOp4998);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::GT; 
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2463:5: GREATER_THAN_EQUAL_TOK
        	    {
        	         MATCHT(GREATER_THAN_EQUAL_TOK, &FOLLOW_GREATER_THAN_EQUAL_TOK_in_builtinOp5023);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::GEQ; 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2465:5: LESS_THAN_EQUAL_TOK
        	    {
        	         MATCHT(LESS_THAN_EQUAL_TOK, &FOLLOW_LESS_THAN_EQUAL_TOK_in_builtinOp5048);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::LEQ; 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2467:5: LESS_THAN_TOK
        	    {
        	         MATCHT(LESS_THAN_TOK, &FOLLOW_LESS_THAN_TOK_in_builtinOp5073);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::LT; 
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2469:5: PLUS_TOK
        	    {
        	         MATCHT(PLUS_TOK, &FOLLOW_PLUS_TOK_in_builtinOp5098);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::PLUS; 
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2470:5: MINUS_TOK
        	    {
        	         MATCHT(MINUS_TOK, &FOLLOW_MINUS_TOK_in_builtinOp5110);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::MINUS; 
        	        }


        	    }
        	    break;
        	case 15:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2471:5: STAR_TOK
        	    {
        	         MATCHT(STAR_TOK, &FOLLOW_STAR_TOK_in_builtinOp5121);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::MULT; 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2472:5: DIV_TOK
        	    {
        	         MATCHT(DIV_TOK, &FOLLOW_DIV_TOK_in_builtinOp5133);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::DIVISION; 
        	        }


        	    }
        	    break;
        	case 17:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2474:5: BV2NAT_TOK
        	    {
        	         MATCHT(BV2NAT_TOK, &FOLLOW_BV2NAT_TOK_in_builtinOp5147);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_TO_NAT;
        	                  if(PARSER_STATE->strictModeEnabled()) {
        	                    PARSER_STATE->parseError("bv2nat and int2bv are not part of SMT-LIB, "
        	                                             "and aren't available in SMT-LIB strict "
        	                                             "compliance mode");
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 18:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2483:5: DTSIZE_TOK
        	    {
        	         MATCHT(DTSIZE_TOK, &FOLLOW_DTSIZE_TOK_in_builtinOp5160);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::DT_SIZE; 
        	        }


        	    }
        	    break;
        	case 19:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2484:5: FMFCARD_TOK
        	    {
        	         MATCHT(FMFCARD_TOK, &FOLLOW_FMFCARD_TOK_in_builtinOp5174);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::CARDINALITY_CONSTRAINT; 
        	        }


        	    }
        	    break;
        	case 20:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2485:5: FMFCARDVAL_TOK
        	    {
        	         MATCHT(FMFCARDVAL_TOK, &FOLLOW_FMFCARDVAL_TOK_in_builtinOp5187);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::CARDINALITY_VALUE; 
        	        }


        	    }
        	    break;
        	case 21:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2486:5: INST_CLOSURE_TOK
        	    {
        	         MATCHT(INST_CLOSURE_TOK, &FOLLOW_INST_CLOSURE_TOK_in_builtinOp5197);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::INST_CLOSURE; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebuiltinOpEx; /* Prevent compiler warnings */
    rulebuiltinOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end builtinOp */

/**
 * $ANTLR start quantOp
 * ../../../../../../src/parser/smt2/Smt2.g:2496:1: quantOp[CVC4::Kind& kind] : ( EXISTS_TOK | FORALL_TOK );
 */
static void
quantOp(pSmt2Parser ctx, CVC4::Kind& kind)
{
    /* Initialize rule variables
     */


      Debug("parser") << "quant: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:2500:3: ( EXISTS_TOK | FORALL_TOK )

            ANTLR3_UINT32 alt56;

            alt56=2;

            switch ( LA(1) )
            {
            case EXISTS_TOK:
            	{
            		alt56=1;
            	}
                break;
            case FORALL_TOK:
            	{
            		alt56=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 56;
                EXCEPTION->state        = 0;


                goto rulequantOpEx;

            }

            switch (alt56)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2500:5: EXISTS_TOK
        	    {
        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_quantOp5239);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequantOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::EXISTS; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2501:5: FORALL_TOK
        	    {
        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_quantOp5250);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequantOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::FORALL; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulequantOpEx; /* Prevent compiler warnings */
    rulequantOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end quantOp */

/**
 * $ANTLR start functionName
 * ../../../../../../src/parser/smt2/Smt2.g:2508:1: functionName[std::string& name, CVC4::parser::DeclarationCheck check] : symbol[name,check,SYM_VARIABLE] ;
 */
static void
functionName(pSmt2Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2509:3: ( symbol[name,check,SYM_VARIABLE] )
        // ../../../../../../src/parser/smt2/Smt2.g:2509:5: symbol[name,check,SYM_VARIABLE]
        {
            FOLLOWPUSH(FOLLOW_symbol_in_functionName5271);
            symbol(ctx, name, check, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionNameEx; /* Prevent compiler warnings */
    rulefunctionNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionName */

/**
 * $ANTLR start sortList
 * ../../../../../../src/parser/smt2/Smt2.g:2516:1: sortList[std::vector<CVC4::Type>& sorts] : ( sortSymbol[t,CHECK_DECLARED] )* ;
 */
static void
sortList(pSmt2Parser ctx, std::vector<CVC4::Type>& sorts)
{

      Type t;

    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2520:3: ( ( sortSymbol[t,CHECK_DECLARED] )* )
        // ../../../../../../src/parser/smt2/Smt2.g:2520:5: ( sortSymbol[t,CHECK_DECLARED] )*
        {
            // ../../../../../../src/parser/smt2/Smt2.g:2520:5: ( sortSymbol[t,CHECK_DECLARED] )*

            for (;;)
            {
                int alt57=2;
                switch ( LA(1) )
                {
                case CHECK_SYNTH_TOK:
                case CONSTRAINT_TOK:
                case DECLARE_PRIMED_VAR_TOK:
                case DECLARE_VAR_TOK:
                case INV_CONSTRAINT_TOK:
                case LPAREN_TOK:
                case QUOTED_SYMBOL:
                case SET_OPTIONS_TOK:
                case SIMPLE_SYMBOL:
                case SYNTH_FUN_TOK:
                case SYNTH_INV_TOK:
                case UNTERMINATED_QUOTED_SYMBOL:
                case 147:
                	{
                		alt57=1;
                	}
                    break;

                }

                switch (alt57)
                {
            	case 1:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2520:7: sortSymbol[t,CHECK_DECLARED]
            	    {
            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sortList5295);
            	        sortSymbol(ctx, t, CHECK_DECLARED);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortListEx;
            	        }


            	        {
            	             sorts.push_back(t); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop57;	/* break out of the loop */
            	    break;
                }
            }
            loop57: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortListEx; /* Prevent compiler warnings */
    rulesortListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortList */

/**
 * $ANTLR start nonemptySortList
 * ../../../../../../src/parser/smt2/Smt2.g:2523:1: nonemptySortList[std::vector<CVC4::Type>& sorts] : ( sortSymbol[t,CHECK_DECLARED] )+ ;
 */
static void
nonemptySortList(pSmt2Parser ctx, std::vector<CVC4::Type>& sorts)
{

      Type t;

    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2527:3: ( ( sortSymbol[t,CHECK_DECLARED] )+ )
        // ../../../../../../src/parser/smt2/Smt2.g:2527:5: ( sortSymbol[t,CHECK_DECLARED] )+
        {
            // ../../../../../../src/parser/smt2/Smt2.g:2527:5: ( sortSymbol[t,CHECK_DECLARED] )+
            {
                int cnt58=0;

                for (;;)
                {
                    int alt58=2;
            	switch ( LA(1) )
            	{
            	case CHECK_SYNTH_TOK:
            	case CONSTRAINT_TOK:
            	case DECLARE_PRIMED_VAR_TOK:
            	case DECLARE_VAR_TOK:
            	case INV_CONSTRAINT_TOK:
            	case LPAREN_TOK:
            	case QUOTED_SYMBOL:
            	case SET_OPTIONS_TOK:
            	case SIMPLE_SYMBOL:
            	case SYNTH_FUN_TOK:
            	case SYNTH_INV_TOK:
            	case UNTERMINATED_QUOTED_SYMBOL:
            	case 147:
            		{
            			alt58=1;
            		}
            	    break;

            	}

            	switch (alt58)
            	{
            	    case 1:
            	        // ../../../../../../src/parser/smt2/Smt2.g:2527:7: sortSymbol[t,CHECK_DECLARED]
            	        {
            	            FOLLOWPUSH(FOLLOW_sortSymbol_in_nonemptySortList5322);
            	            sortSymbol(ctx, t, CHECK_DECLARED);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulenonemptySortListEx;
            	            }


            	            {
            	                 sorts.push_back(t); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt58 >= 1 )
            		{
            		    goto loop58;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulenonemptySortListEx;
            	}
            	cnt58++;
                }
                loop58: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenonemptySortListEx; /* Prevent compiler warnings */
    rulenonemptySortListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nonemptySortList */

/**
 * $ANTLR start sortedVarList
 * ../../../../../../src/parser/smt2/Smt2.g:2534:1: sortedVarList[std::vector<std::pair<std::string, CVC4::Type> >& sortedVars] : ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )* ;
 */
static void
sortedVarList(pSmt2Parser ctx, std::vector<std::pair<std::string, CVC4::Type> >& sortedVars)
{

      std::string name;
      Type t;

    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2539:3: ( ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )* )
        // ../../../../../../src/parser/smt2/Smt2.g:2539:5: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )*
        {
            // ../../../../../../src/parser/smt2/Smt2.g:2539:5: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] RPAREN_TOK )*

            for (;;)
            {
                int alt59=2;
                switch ( LA(1) )
                {
                case LPAREN_TOK:
                	{
                		alt59=1;
                	}
                    break;

                }

                switch (alt59)
                {
            	case 1:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2539:7: LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t,CHECK_DECLARED] RPAREN_TOK
            	    {
            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sortedVarList5351);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_symbol_in_sortedVarList5353);
            	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sortedVarList5362);
            	        sortSymbol(ctx, t, CHECK_DECLARED);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sortedVarList5365);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	        {
            	             sortedVars.push_back(make_pair(name, t)); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop59;	/* break out of the loop */
            	    break;
                }
            }
            loop59: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortedVarListEx; /* Prevent compiler warnings */
    rulesortedVarListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortedVarList */

/**
 * $ANTLR start sortName
 * ../../../../../../src/parser/smt2/Smt2.g:2549:1: sortName[std::string& name, CVC4::parser::DeclarationCheck check] : symbol[name,check,SYM_SORT] ;
 */
static void
sortName(pSmt2Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2550:3: ( symbol[name,check,SYM_SORT] )
        // ../../../../../../src/parser/smt2/Smt2.g:2550:5: symbol[name,check,SYM_SORT]
        {
            FOLLOWPUSH(FOLLOW_symbol_in_sortName5396);
            symbol(ctx, name, check, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesortNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortNameEx; /* Prevent compiler warnings */
    rulesortNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortName */

/**
 * $ANTLR start sortSymbol
 * ../../../../../../src/parser/smt2/Smt2.g:2553:1: sortSymbol[CVC4::Type& t, CVC4::parser::DeclarationCheck check] : ( sortName[name,CHECK_NONE] | LPAREN_TOK ( INDEX_TOK |) symbol[name,CHECK_NONE,SYM_SORT] ( nonemptyNumeralList[numerals] | sortList[args] ) RPAREN_TOK );
 */
static void
sortSymbol(pSmt2Parser ctx, CVC4::Type& t, CVC4::parser::DeclarationCheck check)
{

      std::string name;
      std::vector<CVC4::Type> args;
      std::vector<uint64_t> numerals;
      bool indexed = false;

    /* Initialize rule variables
     */

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:2560:3: ( sortName[name,CHECK_NONE] | LPAREN_TOK ( INDEX_TOK |) symbol[name,CHECK_NONE,SYM_SORT] ( nonemptyNumeralList[numerals] | sortList[args] ) RPAREN_TOK )

            ANTLR3_UINT32 alt62;

            alt62=2;

            switch ( LA(1) )
            {
            case CHECK_SYNTH_TOK:
            case CONSTRAINT_TOK:
            case DECLARE_PRIMED_VAR_TOK:
            case DECLARE_VAR_TOK:
            case INV_CONSTRAINT_TOK:
            case QUOTED_SYMBOL:
            case SET_OPTIONS_TOK:
            case SIMPLE_SYMBOL:
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            case UNTERMINATED_QUOTED_SYMBOL:
            case 147:
            	{
            		alt62=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt62=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 62;
                EXCEPTION->state        = 0;


                goto rulesortSymbolEx;

            }

            switch (alt62)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2560:5: sortName[name,CHECK_NONE]
        	    {
        	        FOLLOWPUSH(FOLLOW_sortName_in_sortSymbol5416);
        	        sortName(ctx, name, CHECK_NONE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {

        	                  if(check == CHECK_DECLARED || PARSER_STATE->isDeclared(name, SYM_SORT)) {
        	                    t = PARSER_STATE->getSort(name);
        	                  } else {
        	                    t = PARSER_STATE->mkUnresolvedType(name);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2568:5: LPAREN_TOK ( INDEX_TOK |) symbol[name,CHECK_NONE,SYM_SORT] ( nonemptyNumeralList[numerals] | sortList[args] ) RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sortSymbol5429);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:2568:16: ( INDEX_TOK |)
        	        {
        	            int alt60=2;
        	            switch ( LA(1) )
        	            {
        	            case INDEX_TOK:
        	            	{
        	            		alt60=1;
        	            	}
        	                break;
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_VAR_TOK:
        	            case INV_CONSTRAINT_TOK:
        	            case QUOTED_SYMBOL:
        	            case SET_OPTIONS_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case 147:
        	            	{
        	            		alt60=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 60;
        	                EXCEPTION->state        = 0;


        	                goto rulesortSymbolEx;

        	            }

        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2568:17: INDEX_TOK
        	        	    {
        	        	         MATCHT(INDEX_TOK, &FOLLOW_INDEX_TOK_in_sortSymbol5432);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesortSymbolEx;
        	        	        }


        	        	        {
        	        	            indexed = true;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2568:47: 
        	        	    {
        	        	        {
        	        	            indexed = false;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_symbol_in_sortSymbol5445);
        	        symbol(ctx, name, CHECK_NONE, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:2570:5: ( nonemptyNumeralList[numerals] | sortList[args] )
        	        {
        	            int alt61=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt61=1;
        	            	}
        	                break;
        	            case CHECK_SYNTH_TOK:
        	            case CONSTRAINT_TOK:
        	            case DECLARE_PRIMED_VAR_TOK:
        	            case DECLARE_VAR_TOK:
        	            case INV_CONSTRAINT_TOK:
        	            case LPAREN_TOK:
        	            case QUOTED_SYMBOL:
        	            case RPAREN_TOK:
        	            case SET_OPTIONS_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case 147:
        	            	{
        	            		alt61=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 61;
        	                EXCEPTION->state        = 0;


        	                goto rulesortSymbolEx;

        	            }

        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2570:7: nonemptyNumeralList[numerals]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_nonemptyNumeralList_in_sortSymbol5454);
        	        	        nonemptyNumeralList(ctx, numerals);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesortSymbolEx;
        	        	        }


        	        	        {
        	        	             // allow sygus inputs to elide the `_'
        	        	                    if( !indexed && !PARSER_STATE->sygus() ) {
        	        	                      std::stringstream ss;
        	        	                      ss << "SMT-LIB requires use of an indexed sort here, e.g. (_ " << name
        	        	                         << " ...)";
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                    if( name == "BitVec" ) {
        	        	                      if( numerals.size() != 1 ) {
        	        	                        PARSER_STATE->parseError("Illegal bitvector type.");
        	        	                      }
        	        	                      if(numerals.front() == 0) {
        	        	                        PARSER_STATE->parseError("Illegal bitvector size: 0");
        	        	                      }
        	        	                      t = EXPR_MANAGER->mkBitVectorType(numerals.front());
        	        	                    } else if ( name == "FloatingPoint" ) {
        	        	                      if( numerals.size() != 2 ) {
        	        	                        PARSER_STATE->parseError("Illegal floating-point type.");
        	        	                      }
        	        	                      if(!validExponentSize(numerals[0])) {
        	        	                        PARSER_STATE->parseError("Illegal floating-point exponent size");
        	        	                      }
        	        	                      if(!validSignificandSize(numerals[1])) {
        	        	                        PARSER_STATE->parseError("Illegal floating-point significand size");
        	        	                      }
        	        	                      t = EXPR_MANAGER->mkFloatingPointType(numerals[0],numerals[1]);
        	        	                    } else {
        	        	                      std::stringstream ss;
        	        	                      ss << "unknown indexed sort symbol `" << name << "'";
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2603:7: sortList[args]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sortList_in_sortSymbol5471);
        	        	        sortList(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesortSymbolEx;
        	        	        }


        	        	        {
        	        	             if( indexed ) {
        	        	                      std::stringstream ss;
        	        	                      ss << "Unexpected use of indexing operator `_' before `" << name
        	        	                         << "', try leaving it out";
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                    if(args.empty()) {
        	        	                      PARSER_STATE->parseError("Extra parentheses around sort name not "
        	        	                                               "permitted in SMT-LIB");
        	        	                    } else if(name == "Array" &&
        	        	                       PARSER_STATE->isTheoryEnabled(Smt2::THEORY_ARRAYS) ) {
        	        	                      if(args.size() != 2) {
        	        	                        PARSER_STATE->parseError("Illegal array type.");
        	        	                      }
        	        	                      t = EXPR_MANAGER->mkArrayType( args[0], args[1] );
        	        	                    } else if(name == "Set" &&
        	        	                              PARSER_STATE->isTheoryEnabled(Smt2::THEORY_SETS) ) {
        	        	                      if(args.size() != 1) {
        	        	                        PARSER_STATE->parseError("Illegal set type.");
        	        	                      }
        	        	                      t = EXPR_MANAGER->mkSetType( args[0] );
        	        	                    } else if(check == CHECK_DECLARED ||
        	        	                              PARSER_STATE->isDeclared(name, SYM_SORT)) {
        	        	                      t = PARSER_STATE->getSort(name, args);
        	        	                    } else {
        	        	                      // make unresolved type
        	        	                      if(args.empty()) {
        	        	                        t = PARSER_STATE->mkUnresolvedType(name);
        	        	                        Debug("parser-param") << "param: make unres type " << name
        	        	                                              << std::endl;
        	        	                      } else {
        	        	                        t = PARSER_STATE->mkUnresolvedTypeConstructor(name,args);
        	        	                        t = SortConstructorType(t).instantiate( args );
        	        	                        Debug("parser-param")
        	        	                            << "param: make unres param type " << name << " " << args.size()
        	        	                            << " " << PARSER_STATE->getArity( name ) << std::endl;
        	        	                      }
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sortSymbol5488);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesortSymbolEx; /* Prevent compiler warnings */
    rulesortSymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortSymbol */

/**
 * $ANTLR start symbolList
 * ../../../../../../src/parser/smt2/Smt2.g:2650:1: symbolList[std::vector<std::string>& names,\n CVC4::parser::DeclarationCheck check,\n CVC4::parser::SymbolType type] : ( symbol[id,check,type] )* ;
 */
static void
symbolList(pSmt2Parser ctx, std::vector<std::string>& names, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type)
{

      std::string id;

    /* Initialize rule variables
     */

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2656:3: ( ( symbol[id,check,type] )* )
        // ../../../../../../src/parser/smt2/Smt2.g:2656:5: ( symbol[id,check,type] )*
        {
            // ../../../../../../src/parser/smt2/Smt2.g:2656:5: ( symbol[id,check,type] )*

            for (;;)
            {
                int alt63=2;
                switch ( LA(1) )
                {
                case CHECK_SYNTH_TOK:
                case CONSTRAINT_TOK:
                case DECLARE_PRIMED_VAR_TOK:
                case DECLARE_VAR_TOK:
                case INV_CONSTRAINT_TOK:
                case QUOTED_SYMBOL:
                case SET_OPTIONS_TOK:
                case SIMPLE_SYMBOL:
                case SYNTH_FUN_TOK:
                case SYNTH_INV_TOK:
                case UNTERMINATED_QUOTED_SYMBOL:
                case 147:
                	{
                		alt63=1;
                	}
                    break;

                }

                switch (alt63)
                {
            	case 1:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2656:7: symbol[id,check,type]
            	    {
            	        FOLLOWPUSH(FOLLOW_symbol_in_symbolList5511);
            	        symbol(ctx, id, check, type);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesymbolListEx;
            	        }


            	        {
            	             names.push_back(id); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop63;	/* break out of the loop */
            	    break;
                }
            }
            loop63: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesymbolListEx; /* Prevent compiler warnings */
    rulesymbolListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end symbolList */

/**
 * $ANTLR start symbol
 * ../../../../../../src/parser/smt2/Smt2.g:2665:1: symbol[std::string& id,\n CVC4::parser::DeclarationCheck check,\n CVC4::parser::SymbolType type] : ( SIMPLE_SYMBOL | ( 'repeat' | SET_OPTIONS_TOK | DECLARE_VAR_TOK | DECLARE_PRIMED_VAR_TOK | SYNTH_FUN_TOK | SYNTH_INV_TOK | CONSTRAINT_TOK | INV_CONSTRAINT_TOK | CHECK_SYNTH_TOK ) | QUOTED_SYMBOL | UNTERMINATED_QUOTED_SYMBOL ( EOF | '\\\\' ) );
 */
static void
symbol(pSmt2Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type)
{
    pANTLR3_COMMON_TOKEN    SIMPLE_SYMBOL22;
    pANTLR3_COMMON_TOKEN    QUOTED_SYMBOL23;

    /* Initialize rule variables
     */

    SIMPLE_SYMBOL22       = NULL;
    QUOTED_SYMBOL23       = NULL;

    {
        {
            //  ../../../../../../src/parser/smt2/Smt2.g:2668:3: ( SIMPLE_SYMBOL | ( 'repeat' | SET_OPTIONS_TOK | DECLARE_VAR_TOK | DECLARE_PRIMED_VAR_TOK | SYNTH_FUN_TOK | SYNTH_INV_TOK | CONSTRAINT_TOK | INV_CONSTRAINT_TOK | CHECK_SYNTH_TOK ) | QUOTED_SYMBOL | UNTERMINATED_QUOTED_SYMBOL ( EOF | '\\\\' ) )

            ANTLR3_UINT32 alt66;

            alt66=4;

            switch ( LA(1) )
            {
            case SIMPLE_SYMBOL:
            	{
            		alt66=1;
            	}
                break;
            case CHECK_SYNTH_TOK:
            case CONSTRAINT_TOK:
            case DECLARE_PRIMED_VAR_TOK:
            case DECLARE_VAR_TOK:
            case INV_CONSTRAINT_TOK:
            case SET_OPTIONS_TOK:
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            case 147:
            	{
            		alt66=2;
            	}
                break;
            case QUOTED_SYMBOL:
            	{
            		alt66=3;
            	}
                break;
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		alt66=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 66;
                EXCEPTION->state        = 0;


                goto rulesymbolEx;

            }

            switch (alt66)
            {
        	case 1:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2668:5: SIMPLE_SYMBOL
        	    {
        	        SIMPLE_SYMBOL22 = (pANTLR3_COMMON_TOKEN) MATCHT(SIMPLE_SYMBOL, &FOLLOW_SIMPLE_SYMBOL_in_symbol5533);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolEx;
        	        }


        	        {
        	             id = AntlrInput::tokenText(SIMPLE_SYMBOL22);
        	                  if(!PARSER_STATE->isAbstractValue(id)) {
        	                    // if an abstract value, SmtEngine handles declaration
        	                    PARSER_STATE->checkDeclaration(id, check, type);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2675:5: ( 'repeat' | SET_OPTIONS_TOK | DECLARE_VAR_TOK | DECLARE_PRIMED_VAR_TOK | SYNTH_FUN_TOK | SYNTH_INV_TOK | CONSTRAINT_TOK | INV_CONSTRAINT_TOK | CHECK_SYNTH_TOK )
        	    {
        	        // ../../../../../../src/parser/smt2/Smt2.g:2675:5: ( 'repeat' | SET_OPTIONS_TOK | DECLARE_VAR_TOK | DECLARE_PRIMED_VAR_TOK | SYNTH_FUN_TOK | SYNTH_INV_TOK | CONSTRAINT_TOK | INV_CONSTRAINT_TOK | CHECK_SYNTH_TOK )
        	        {
        	            int alt64=9;
        	            switch ( LA(1) )
        	            {
        	            case 147:
        	            	{
        	            		alt64=1;
        	            	}
        	                break;
        	            case SET_OPTIONS_TOK:
        	            	{
        	            		alt64=2;
        	            	}
        	                break;
        	            case DECLARE_VAR_TOK:
        	            	{
        	            		alt64=3;
        	            	}
        	                break;
        	            case DECLARE_PRIMED_VAR_TOK:
        	            	{
        	            		alt64=4;
        	            	}
        	                break;
        	            case SYNTH_FUN_TOK:
        	            	{
        	            		alt64=5;
        	            	}
        	                break;
        	            case SYNTH_INV_TOK:
        	            	{
        	            		alt64=6;
        	            	}
        	                break;
        	            case CONSTRAINT_TOK:
        	            	{
        	            		alt64=7;
        	            	}
        	                break;
        	            case INV_CONSTRAINT_TOK:
        	            	{
        	            		alt64=8;
        	            	}
        	                break;
        	            case CHECK_SYNTH_TOK:
        	            	{
        	            		alt64=9;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 64;
        	                EXCEPTION->state        = 0;


        	                goto rulesymbolEx;

        	            }

        	            switch (alt64)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2675:7: 'repeat'
        	        	    {
        	        	         MATCHT(147, &FOLLOW_147_in_symbol5547);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "repeat"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2678:7: SET_OPTIONS_TOK
        	        	    {
        	        	         MATCHT(SET_OPTIONS_TOK, &FOLLOW_SET_OPTIONS_TOK_in_symbol5563);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "set-options"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2679:7: DECLARE_VAR_TOK
        	        	    {
        	        	         MATCHT(DECLARE_VAR_TOK, &FOLLOW_DECLARE_VAR_TOK_in_symbol5573);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "declare-var"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2680:7: DECLARE_PRIMED_VAR_TOK
        	        	    {
        	        	         MATCHT(DECLARE_PRIMED_VAR_TOK, &FOLLOW_DECLARE_PRIMED_VAR_TOK_in_symbol5583);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "declare-primed-var"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 5:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2681:7: SYNTH_FUN_TOK
        	        	    {
        	        	         MATCHT(SYNTH_FUN_TOK, &FOLLOW_SYNTH_FUN_TOK_in_symbol5593);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "synth-fun"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 6:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2682:7: SYNTH_INV_TOK
        	        	    {
        	        	         MATCHT(SYNTH_INV_TOK, &FOLLOW_SYNTH_INV_TOK_in_symbol5603);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "synth-inv"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 7:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2683:7: CONSTRAINT_TOK
        	        	    {
        	        	         MATCHT(CONSTRAINT_TOK, &FOLLOW_CONSTRAINT_TOK_in_symbol5613);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "constraint"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 8:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2684:7: INV_CONSTRAINT_TOK
        	        	    {
        	        	         MATCHT(INV_CONSTRAINT_TOK, &FOLLOW_INV_CONSTRAINT_TOK_in_symbol5623);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "inv-constraint"; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 9:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2685:7: CHECK_SYNTH_TOK
        	        	    {
        	        	         MATCHT(CHECK_SYNTH_TOK, &FOLLOW_CHECK_SYNTH_TOK_in_symbol5633);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             id = "check-synth"; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->checkDeclaration(id, check, type); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2688:5: QUOTED_SYMBOL
        	    {
        	        QUOTED_SYMBOL23 = (pANTLR3_COMMON_TOKEN) MATCHT(QUOTED_SYMBOL, &FOLLOW_QUOTED_SYMBOL_in_symbol5653);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolEx;
        	        }


        	        {
        	             id = AntlrInput::tokenText(QUOTED_SYMBOL23);
        	                  /* strip off the quotes */
        	                  id = id.substr(1, id.size() - 2);
        	                  if(!PARSER_STATE->isAbstractValue(id)) {
        	                    // if an abstract value, SmtEngine handles declaration
        	                    PARSER_STATE->checkDeclaration(id, check, type);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../../../src/parser/smt2/Smt2.g:2697:5: UNTERMINATED_QUOTED_SYMBOL ( EOF | '\\\\' )
        	    {
        	         MATCHT(UNTERMINATED_QUOTED_SYMBOL, &FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol5665);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolEx;
        	        }


        	        // ../../../../../../src/parser/smt2/Smt2.g:2698:5: ( EOF | '\\\\' )
        	        {
        	            int alt65=2;
        	            switch ( LA(1) )
        	            {
        	            case EOF:
        	            	{
        	            		alt65=1;
        	            	}
        	                break;
        	            case 145:
        	            	{
        	            		alt65=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 65;
        	                EXCEPTION->state        = 0;


        	                goto rulesymbolEx;

        	            }

        	            switch (alt65)
        	            {
        	        	case 1:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2698:7: EOF
        	        	    {
        	        	         MATCHT(EOF, &FOLLOW_EOF_in_symbol5673);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->unexpectedEOF("unterminated |quoted| symbol"); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../../../src/parser/smt2/Smt2.g:2700:7: '\\\\'
        	        	    {
        	        	         MATCHT(145, &FOLLOW_145_in_symbol5689);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->unexpectedEOF("backslash not permitted in |quoted| "
        	        	                                                "symbol"); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesymbolEx; /* Prevent compiler warnings */
    rulesymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end symbol */

/**
 * $ANTLR start nonemptyNumeralList
 * ../../../../../../src/parser/smt2/Smt2.g:2710:1: nonemptyNumeralList[std::vector<uint64_t>& numerals] : ( INTEGER_LITERAL )+ ;
 */
static void
nonemptyNumeralList(pSmt2Parser ctx, std::vector<uint64_t>& numerals)
{
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL24;

    /* Initialize rule variables
     */

    INTEGER_LITERAL24       = NULL;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2711:3: ( ( INTEGER_LITERAL )+ )
        // ../../../../../../src/parser/smt2/Smt2.g:2711:5: ( INTEGER_LITERAL )+
        {
            // ../../../../../../src/parser/smt2/Smt2.g:2711:5: ( INTEGER_LITERAL )+
            {
                int cnt67=0;

                for (;;)
                {
                    int alt67=2;
            	switch ( LA(1) )
            	{
            	case INTEGER_LITERAL:
            		{
            			alt67=1;
            		}
            	    break;

            	}

            	switch (alt67)
            	{
            	    case 1:
            	        // ../../../../../../src/parser/smt2/Smt2.g:2711:7: INTEGER_LITERAL
            	        {
            	            INTEGER_LITERAL24 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList5721);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulenonemptyNumeralListEx;
            	            }


            	            {
            	                 numerals.push_back(AntlrInput::tokenToUnsigned(INTEGER_LITERAL24)); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt67 >= 1 )
            		{
            		    goto loop67;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulenonemptyNumeralListEx;
            	}
            	cnt67++;
                }
                loop67: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenonemptyNumeralListEx; /* Prevent compiler warnings */
    rulenonemptyNumeralListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nonemptyNumeralList */

/**
 * $ANTLR start datatypeDef
 * ../../../../../../src/parser/smt2/Smt2.g:2719:1: datatypeDef[bool isCo, std::vector<CVC4::Datatype>& datatypes,\n std::vector< CVC4::Type >& params] : symbol[id,CHECK_NONE,SYM_SORT] ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+ ;
 */
static void
datatypeDef(pSmt2Parser ctx, bool isCo, std::vector<CVC4::Datatype>& datatypes, std::vector< CVC4::Type >& params)
{
    /* Initialize rule variables
     */


      std::string id;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2728:3: ( symbol[id,CHECK_NONE,SYM_SORT] ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+ )
        // ../../../../../../src/parser/smt2/Smt2.g:2728:5: symbol[id,CHECK_NONE,SYM_SORT] ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+
        {
            FOLLOWPUSH(FOLLOW_symbol_in_datatypeDef5763);
            symbol(ctx, id, CHECK_NONE, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledatatypeDefEx;
            }


            {
                 PARSER_STATE->pushScope(true); 
            }


            {
                 datatypes.push_back(Datatype(id,params,isCo));
                      if(!PARSER_STATE->isUnresolvedType(id)) {
                        // if not unresolved, must be undeclared
                        PARSER_STATE->checkDeclaration(id, CHECK_UNDECLARED, SYM_SORT);
                      }
                    
            }


            // ../../../../../../src/parser/smt2/Smt2.g:2744:5: ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+
            {
                int cnt68=0;

                for (;;)
                {
                    int alt68=2;
            	switch ( LA(1) )
            	{
            	case LPAREN_TOK:
            		{
            			alt68=1;
            		}
            	    break;

            	}

            	switch (alt68)
            	{
            	    case 1:
            	        // ../../../../../../src/parser/smt2/Smt2.g:2744:7: LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK
            	        {
            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypeDef5786);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypeDefEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_constructorDef_in_datatypeDef5788);
            	            constructorDef(ctx, datatypes.back());

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypeDefEx;
            	            }


            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypeDef5791);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypeDefEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt68 >= 1 )
            		{
            		    goto loop68;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledatatypeDefEx;
            	}
            	cnt68++;
                }
                loop68: ;	/* Jump to here if this rule does not match */
            }

            {
                 PARSER_STATE->popScope(); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledatatypeDefEx; /* Prevent compiler warnings */
    ruledatatypeDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end datatypeDef */

/**
 * $ANTLR start constructorDef
 * ../../../../../../src/parser/smt2/Smt2.g:2751:1: constructorDef[CVC4::Datatype& type] : symbol[id,CHECK_UNDECLARED,SYM_VARIABLE] ( LPAREN_TOK selector[*ctor] RPAREN_TOK )* ;
 */
static void
constructorDef(pSmt2Parser ctx, CVC4::Datatype& type)
{
    /* Initialize rule variables
     */


      std::string id;
      CVC4::DatatypeConstructor* ctor = NULL;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2756:3: ( symbol[id,CHECK_UNDECLARED,SYM_VARIABLE] ( LPAREN_TOK selector[*ctor] RPAREN_TOK )* )
        // ../../../../../../src/parser/smt2/Smt2.g:2756:5: symbol[id,CHECK_UNDECLARED,SYM_VARIABLE] ( LPAREN_TOK selector[*ctor] RPAREN_TOK )*
        {
            FOLLOWPUSH(FOLLOW_symbol_in_constructorDef5821);
            symbol(ctx, id, CHECK_UNDECLARED, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstructorDefEx;
            }


            {
                 // make the tester
                      std::string testerId("is-");
                      testerId.append(id);
                      PARSER_STATE->checkDeclaration(testerId, CHECK_UNDECLARED, SYM_VARIABLE);
                      ctor = new CVC4::DatatypeConstructor(id, testerId);
                    
            }


            // ../../../../../../src/parser/smt2/Smt2.g:2763:5: ( LPAREN_TOK selector[*ctor] RPAREN_TOK )*

            for (;;)
            {
                int alt69=2;
                switch ( LA(1) )
                {
                case LPAREN_TOK:
                	{
                		alt69=1;
                	}
                    break;

                }

                switch (alt69)
                {
            	case 1:
            	    // ../../../../../../src/parser/smt2/Smt2.g:2763:7: LPAREN_TOK selector[*ctor] RPAREN_TOK
            	    {
            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_constructorDef5836);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_selector_in_constructorDef5838);
            	        selector(ctx, *ctor);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }


            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_constructorDef5841);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop69;	/* break out of the loop */
            	    break;
                }
            }
            loop69: ; /* Jump out to here if this rule does not match */


            {
                 // make the constructor
                      type.addConstructor(*ctor);
                      Debug("parser-idt") << "constructor: " << id.c_str() << std::endl;
                      delete ctor;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructorDefEx; /* Prevent compiler warnings */
    ruleconstructorDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end constructorDef */

/**
 * $ANTLR start selector
 * ../../../../../../src/parser/smt2/Smt2.g:2771:1: selector[CVC4::DatatypeConstructor& ctor] : symbol[id,CHECK_UNDECLARED,SYM_SORT] sortSymbol[t,CHECK_NONE] ;
 */
static void
selector(pSmt2Parser ctx, CVC4::DatatypeConstructor& ctor)
{
    /* Initialize rule variables
     */


      std::string id;
      Type t, t2;

    {
        // ../../../../../../src/parser/smt2/Smt2.g:2776:3: ( symbol[id,CHECK_UNDECLARED,SYM_SORT] sortSymbol[t,CHECK_NONE] )
        // ../../../../../../src/parser/smt2/Smt2.g:2776:5: symbol[id,CHECK_UNDECLARED,SYM_SORT] sortSymbol[t,CHECK_NONE]
        {
            FOLLOWPUSH(FOLLOW_symbol_in_selector5869);
            symbol(ctx, id, CHECK_UNDECLARED, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }


            FOLLOWPUSH(FOLLOW_sortSymbol_in_selector5872);
            sortSymbol(ctx, t, CHECK_NONE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }


            {
                 ctor.addArg(id, t);
                      Debug("parser-idt") << "selector: " << id.c_str()
                                          << " of type " << t << std::endl;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectorEx; /* Prevent compiler warnings */
    ruleselectorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end selector */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
